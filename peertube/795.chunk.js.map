{"version":3,"file":"795.chunk.js?v=552","mappings":"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","sources":["webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/loader-interface.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/stringly-typed-event-emitter.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/http-media-manager.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/media-peer.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/p2p-media-manager.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/bandwidth-approximator.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/segments-memory-storage.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/hybrid-loader.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/byte-range.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/segment-manager.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/hlsjs-loader.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/engine.ts","webpack://peertube-client/./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/index.ts"],"sourcesContent":["/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { EventEmitter } from \"events\";\n\nexport type Segment = {\n    readonly id: string;\n    readonly url: string;\n    readonly masterSwarmId: string;\n    readonly masterManifestUri: string;\n    readonly streamId: string | undefined;\n    readonly sequence: string;\n    readonly range: string | undefined;\n    readonly priority: number;\n    data?: ArrayBuffer;\n    downloadBandwidth?: number;\n    requestUrl?: string;\n    responseUrl?: string;\n};\n\nexport enum Events {\n    /**\n     * Emitted when segment has been downloaded.\n     * Args: segment\n     */\n    SegmentLoaded = \"segment_loaded\",\n\n    /**\n     * Emitted when an error occurred while loading the segment.\n     * Args: segment, error\n     */\n    SegmentError = \"segment_error\",\n\n\n    /**\n     * Emitter when we the segment size is known\n     * Args: segment, size\n     */\n    SegmentSize = \"segment_size\",\n\n    /**\n     * Emitted for each segment that does not hit into a new segments queue when the load() method is called.\n     * Args: segment\n     */\n    SegmentAbort = \"segment_abort\",\n\n\n    /**\n     * Emitted when the loader started to load a segment\n     * Args: method, segment\n     */\n    SegmentStartLoad = \"segment_start_load\",\n\n    /**\n     * Emitted when a peer is connected.\n     * Args: peer\n     */\n    PeerConnect = \"peer_connect\",\n\n    /**\n     * Emitted when a peer is disconnected.\n     * Args: peerId\n     */\n    PeerClose = \"peer_close\",\n\n    /**\n     * Emitted when a segment piece has been downloaded.\n     * Args: method (can be \"http\" or \"p2p\" only), bytes\n     */\n    PieceBytesDownloaded = \"piece_bytes_downloaded\",\n\n    /**\n     * Emitted when a segment piece has been uploaded.\n     * Args: method (can be \"p2p\" only), bytes\n     */\n    PieceBytesUploaded = \"piece_bytes_uploaded\",\n}\n\nexport interface LoaderInterface extends EventEmitter {\n    on: ((eventName: string, listener: (...params: unknown[]) => void) => this) &\n        ((eventName: Events.SegmentStartLoad, listener: (method: \"http\" | \"p2p\", segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentSize, listener: (segment: Segment, size: number) => void) => this) &\n        ((eventName: Events.PieceBytesDownloaded | Events.PieceBytesUploaded, listener: (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => void) => this) &\n        ((eventName: Events.SegmentLoaded, listener: (segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentError, listener: (segment: Segment, error: unknown) => void) => this) &\n        ((eventName: Events.SegmentAbort, listener: (segment: Segment) => void) => this);\n    load: (segments: Segment[], streamSwarmId: string) => void;\n    getSegment: (id: string) => Promise<Segment | undefined>;\n    getSettings: () => unknown;\n    getDetails: () => unknown;\n    getBandwidthEstimate: () => number;\n    destroy: () => Promise<void>;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { EventEmitter } from \"events\";\n\nexport class STEEmitter<T extends string | symbol> extends EventEmitter {\n    public on = (event: T, listener: (...args: any[]) => void): this => super.on(event, listener);\n    public emit = (event: T, ...args: any[]): boolean => super.emit(event, ...args);\n}\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport Debug from \"debug\";\r\n\r\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\r\nimport { Segment } from \"./loader-interface\";\r\nimport { SegmentValidatorCallback /*, XhrSetupCallback */, SegmentUrlBuilder } from \"./hybrid-loader\";\r\n\r\nclass FilteredEmitter extends STEEmitter<\r\n    \"segment-start-load\" | \"segment-loaded\" | \"segment-error\" | \"segment-size\" | \"bytes-downloaded\"\r\n> { }\r\n\r\nexport class HttpMediaManager extends FilteredEmitter {\r\n    private fetchRequests = new Map<string, { request?: Promise<Response>; fetchAbort: AbortController, segment: Segment, initialPriority: number, segmentUrl: string }>();\r\n    private failedSegments = new Map<string, number>();\r\n    private debug = Debug(\"p2pml:http-media-manager\");\r\n    private fetch: typeof fetch = (...args) => fetch(...args);\r\n\r\n    public constructor(\r\n        readonly settings: {\r\n            httpFailedSegmentTimeout: number;\r\n            httpUseRanges: boolean;\r\n            requiredSegmentsPriority: number;\r\n            segmentValidator?: SegmentValidatorCallback;\r\n            /* xhrSetup?: XhrSetupCallback; */\r\n            segmentUrlBuilder?: SegmentUrlBuilder;\r\n            localTransport?: typeof fetch;\r\n        }\r\n    ) {\r\n        super();\r\n\r\n        if (settings.localTransport) {\r\n            this.fetch = settings.localTransport;\r\n        }\r\n    }\r\n\r\n    public download = (segment: Segment, downloadedPieces?: ArrayBuffer[]): void => {\r\n        if (this.isDownloading(segment)) {\r\n            return;\r\n        }\r\n\r\n        this.cleanTimedOutFailedSegments();\r\n\r\n        this.emit(\"segment-start-load\", segment);\r\n\r\n        const segmentUrl = this.buildSegmentUrl(segment);\r\n\r\n        const fetchAbort = new AbortController();\r\n\r\n        this.fetchRequests.set(segment.id, { fetchAbort, segment, initialPriority: segment.priority, segmentUrl });\r\n\r\n        this.debug(\"http segment download\", segmentUrl);\r\n\r\n        segment.requestUrl = segmentUrl;\r\n\r\n        const headers = new Headers();\r\n\r\n        if (segment.range) {\r\n            headers.append('Range', segment.range);\r\n        } else if (downloadedPieces !== undefined && this.settings.httpUseRanges) {\r\n            let bytesDownloaded = 0;\r\n            for (const piece of downloadedPieces) {\r\n                bytesDownloaded += piece.byteLength;\r\n            }\r\n\r\n            headers.append(\"Range\", `bytes=${bytesDownloaded}-`);\r\n\r\n            this.debug(\"continue download from\", bytesDownloaded);\r\n        } else {\r\n            downloadedPieces = undefined;\r\n        }\r\n\r\n        const signal = fetchAbort.signal;\r\n\r\n        const fetchRequest = this.fetch(segmentUrl, { headers, signal });\r\n\r\n        void this.setupFetchEvents(fetchRequest, segment, downloadedPieces)\r\n            .catch((err: Error) => {\r\n                /**\r\n                 * Handling all fetch errors here\r\n                 */\r\n\r\n                if (err.name === \"AbortError\") {\r\n                    /**\r\n                     * This may happen on video seeking\r\n                     * or halted video playing. In most\r\n                     * cases it is normal. For more info\r\n                     * look AbortController...\r\n                     */\r\n                    this.debug(\"Segment loading was aborted by user\", segment);\r\n                    return;\r\n                }\r\n\r\n                if (err.message === \"network error\") {\r\n                    this.debug(\"Segment loading is unavailable. No internet\", segment);\r\n\r\n                    const netError = Error(\"NETWORK_ERROR\");\r\n\r\n                    this.segmentFailure(segment, netError, segment.url);\r\n                    return;\r\n                }\r\n\r\n                if (err.message === \"Failed to fetch\") {\r\n                    /**\r\n                     * This error might occur in next cases:\r\n                     *   - Network error\r\n                     *   - Response with erroneous CORS headers\r\n                     *   - Unsupported protocol, e.g. HTTPS\r\n                     *   - Wrong request method\r\n                     */\r\n\r\n                    this.debug(\"Segment fetch failed\", segment);\r\n\r\n                    const fetchError = Error(\"FETCH_FAILED\");\r\n\r\n                    this.segmentFailure(segment, fetchError, segment.url);\r\n                    return;\r\n                }\r\n            });\r\n\r\n        /* if (this.settings.xhrSetup) {\r\n            this.settings.xhrSetup(xhr, segmentUrl);\r\n        } */\r\n\r\n        this.fetchRequests.set(segment.id, { request: fetchRequest, fetchAbort, segment, initialPriority: segment.priority, segmentUrl });\r\n\r\n        return;\r\n    };\r\n\r\n    public updatePriority = (segment: Segment): void => {\r\n        const request = this.fetchRequests.get(segment.id);\r\n\r\n        if (!request) {\r\n            throw new Error(\"Cannot update priority of not downloaded segment \" + segment.id);\r\n        }\r\n\r\n        // Segment is now in high priority\r\n        // If the segment URL changed, retry the request with the new URL\r\n        if (\r\n            segment.priority <= this.settings.requiredSegmentsPriority &&\r\n            request.initialPriority > this.settings.requiredSegmentsPriority &&\r\n            request.segmentUrl !== this.buildSegmentUrl(segment)\r\n        ) {\r\n            this.debug(\"aborting http segment abort because the segment is now in a high priority\", segment.id);\r\n            this.abort(segment)\r\n            this.download(segment)\r\n        }\r\n\r\n    }\r\n\r\n    public abort = (segment: Segment): void => {\r\n        const request = this.fetchRequests.get(segment.id);\r\n\r\n        if (request) {\r\n            request.fetchAbort.abort();\r\n            this.fetchRequests.delete(segment.id);\r\n            this.debug(\"http segment abort\", segment.id);\r\n        }\r\n    };\r\n\r\n    public isDownloading = (segment: Segment): boolean => {\r\n        return this.fetchRequests.has(segment.id);\r\n    };\r\n\r\n    public isFailed = (segment: Segment): boolean => {\r\n        const time = this.failedSegments.get(segment.id);\r\n        return time !== undefined && time > this.now();\r\n    };\r\n\r\n    public getActiveDownloads = (): ReadonlyMap<string, { segment: Segment }> => {\r\n        return this.fetchRequests;\r\n    };\r\n\r\n    public getActiveDownloadsCount = (): number => {\r\n        return this.fetchRequests.size;\r\n    };\r\n\r\n    public destroy = (): void => {\r\n        this.fetchRequests.forEach((request) => request.fetchAbort.abort());\r\n        this.fetchRequests.clear();\r\n    };\r\n\r\n    private setupFetchEvents = async (fetch: Promise<Response>, segment: Segment, downloadedPieces?: ArrayBuffer[]) => {\r\n        const fetchResponse = await fetch as Response & { body: ReadableStream };\r\n\r\n        const dataReader = fetchResponse.body.getReader();\r\n\r\n        const contentLengthStr = fetchResponse.headers.get(\"Content-Length\") as string;\r\n\r\n        const contentLength = Number.parseFloat(contentLengthStr);\r\n\r\n        const dataBytes: Uint8Array = new Uint8Array(contentLength);\r\n\r\n        let nextChunkPos = 0;\r\n\r\n        if (Array.isArray(downloadedPieces) && fetchResponse.status === 206) {\r\n            for (const piece of downloadedPieces) {\r\n                const pieceBytes = new Uint8Array(piece);\r\n\r\n                dataBytes.set(pieceBytes, nextChunkPos);\r\n\r\n                nextChunkPos = piece.byteLength;\r\n            }\r\n        }\r\n\r\n        let read;\r\n\r\n        while (!(read = await dataReader.read()).done) {\r\n            const chunkBytes = read.value;\r\n\r\n            dataBytes.set(chunkBytes, nextChunkPos);\r\n\r\n            nextChunkPos += chunkBytes.length;\r\n\r\n            /** Events emitters */\r\n\r\n            this.emit(\"bytes-downloaded\", segment, chunkBytes.length);\r\n\r\n            if (contentLength) {\r\n                this.emit(\"segment-size\", segment, contentLength);\r\n            }\r\n        }\r\n\r\n        if (fetchResponse.status < 200 || fetchResponse.status >= 300) {\r\n            const err = Error(`Segment failure with HTTP code ${fetchResponse.status}`);\r\n            this.segmentFailure(segment, err, fetchResponse.url);\r\n            return;\r\n        }\r\n\r\n        await this.segmentDownloadFinished(segment, dataBytes.buffer, fetchResponse);\r\n    };\r\n\r\n    private segmentDownloadFinished = async (segment: Segment, data: ArrayBuffer, fetchResponse: Response) => {\r\n        segment.responseUrl = fetchResponse.url;\r\n\r\n        if (this.settings.segmentValidator) {\r\n            try {\r\n                await this.settings.segmentValidator({ ...segment, data: data }, \"http\");\r\n            } catch (error) {\r\n                this.debug(\"segment validator failed\", error);\r\n                this.segmentFailure(segment, error, fetchResponse.url);\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.fetchRequests.delete(segment.id);\r\n        this.emit(\"segment-loaded\", segment, data);\r\n    };\r\n\r\n    private segmentFailure = (segment: Segment, error: Error, responseUrl: string) => {\r\n        segment.responseUrl = responseUrl;\r\n\r\n        this.fetchRequests.delete(segment.id);\r\n        this.failedSegments.set(segment.id, this.now() + this.settings.httpFailedSegmentTimeout);\r\n        this.emit(\"segment-error\", segment, error);\r\n    };\r\n\r\n    private cleanTimedOutFailedSegments = () => {\r\n        const now = this.now();\r\n        const candidates: string[] = [];\r\n\r\n        this.failedSegments.forEach((time, id) => {\r\n            if (time < now) {\r\n                candidates.push(id);\r\n            }\r\n        });\r\n\r\n        candidates.forEach((id) => this.failedSegments.delete(id));\r\n    };\r\n\r\n    private buildSegmentUrl (segment: Segment) {\r\n        if (this.settings.segmentUrlBuilder) {\r\n            return this.settings.segmentUrlBuilder(segment);\r\n        }\r\n\r\n        return segment.url;\r\n    }\r\n\r\n    private now = () => performance.now();\r\n}\r\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nimport Debug from \"debug\";\nimport { Buffer } from \"buffer\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\n\nenum MediaPeerCommands {\n    SegmentData,\n    SegmentAbsent,\n    SegmentsMap,\n    SegmentRequest,\n    CancelSegmentRequest,\n}\n\ntype MediaPeerCommand =\n    | {\n          c:\n              | MediaPeerCommands.SegmentAbsent\n              | MediaPeerCommands.SegmentRequest\n              | MediaPeerCommands.CancelSegmentRequest;\n          i: string;\n      }\n    | {\n          c: MediaPeerCommands.SegmentsMap;\n          m: { [key: string]: [string, number[]] };\n      }\n    | {\n          c: MediaPeerCommands.SegmentData;\n          i: string;\n          s: number;\n      };\n\nexport enum MediaPeerSegmentStatus {\n    Loaded,\n    LoadingByHttp,\n}\n\nclass DownloadingSegment {\n    public bytesDownloaded = 0;\n    public pieces: ArrayBuffer[] = [];\n    constructor(readonly id: string, readonly size: number) {}\n}\n\nexport class MediaPeer extends STEEmitter<\n    | \"connect\"\n    | \"close\"\n    | \"data-updated\"\n    | \"segment-start-load\"\n    | \"segment-request\"\n    | \"segment-absent\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-timeout\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n> {\n    public id: string;\n    public remoteAddress = \"\";\n    private downloadingSegmentId: string | null = null;\n    private downloadingSegment: DownloadingSegment | null = null;\n    private segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n    private debug = Debug(\"p2pml:media-peer\");\n    private timer: ReturnType<typeof setTimeout> | null = null;\n\n    constructor(\n        // eslint-disable-next-line\n        readonly peer: any,\n        readonly settings: {\n            p2pSegmentDownloadTimeout: number;\n            webRtcMaxMessageSize: number;\n        }\n    ) {\n        super();\n\n        this.peer.on(\"connect\", this.onPeerConnect);\n        this.peer.on(\"close\", this.onPeerClose);\n        this.peer.on(\"error\", this.onPeerError);\n        this.peer.on(\"data\", this.onPeerData);\n\n        this.id = peer.id;\n    }\n\n    private onPeerConnect = () => {\n        this.debug(\"peer connect\", this.id, this);\n        this.remoteAddress = this.peer.remoteAddress;\n        this.emit(\"connect\", this);\n    };\n\n    private onPeerClose = () => {\n        this.debug(\"peer close\", this.id, this);\n        this.terminateSegmentRequest();\n        this.emit(\"close\", this);\n    };\n\n    private onPeerError = (error: unknown) => {\n        this.debug(\"peer error\", this.id, error, this);\n    };\n\n    private receiveSegmentPiece = (data: ArrayBuffer): void => {\n        if (!this.downloadingSegment) {\n            // The segment was not requested or canceled\n            this.debug(\"peer segment not requested\", this.id, this);\n            return;\n        }\n\n        this.downloadingSegment.bytesDownloaded += data.byteLength;\n        this.downloadingSegment.pieces.push(data);\n\n        const segmentId = this.downloadingSegment.id;\n        this.emit(\"bytes-downloaded\", this, segmentId, data.byteLength);\n\n        if (this.downloadingSegment.bytesDownloaded === this.downloadingSegment.size) {\n            const segmentData = new Uint8Array(this.downloadingSegment.size);\n            let offset = 0;\n            for (const piece of this.downloadingSegment.pieces) {\n                segmentData.set(new Uint8Array(piece), offset);\n                offset += piece.byteLength;\n            }\n\n            this.debug(\"peer segment download done\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-loaded\", this, segmentId, segmentData.buffer);\n        } else if (this.downloadingSegment.bytesDownloaded > this.downloadingSegment.size) {\n            this.debug(\"peer segment download bytes mismatch\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Too many bytes received for segment\");\n        }\n    };\n\n    private getJsonCommand = (data: ArrayBuffer) => {\n        const bytes = new Uint8Array(data);\n\n        // Serialized JSON string check by first, second and last characters: '{\" .... }'\n        if (bytes[0] === 123 && bytes[1] === 34 && bytes[data.byteLength - 1] === 125) {\n            try {\n                return JSON.parse(new TextDecoder().decode(data)) as Record<string, unknown>;\n            } catch {\n                return null;\n            }\n        }\n\n        return null;\n    };\n\n    private onPeerData = (data: ArrayBuffer) => {\n        const command = this.getJsonCommand(data);\n\n        if (command === null) {\n            this.receiveSegmentPiece(data);\n            return;\n        }\n\n        if (this.downloadingSegment) {\n            this.debug(\"peer segment download is interrupted by a command\", this.id, this);\n\n            const segmentId = this.downloadingSegment.id;\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Segment download is interrupted by a command\");\n            return;\n        }\n\n        this.debug(\"peer receive command\", this.id, command, this);\n\n        switch (command.c) {\n            case MediaPeerCommands.SegmentsMap:\n                this.segmentsMap = this.createSegmentsMap(command.m);\n                this.emit(\"data-updated\");\n                break;\n\n            case MediaPeerCommands.SegmentRequest:\n                this.emit(\"segment-request\", this, command.i);\n                break;\n\n            case MediaPeerCommands.SegmentData:\n                if (\n                    this.downloadingSegmentId &&\n                    this.downloadingSegmentId === command.i &&\n                    typeof command.s === \"number\" &&\n                    command.s >= 0\n                ) {\n                    this.downloadingSegment = new DownloadingSegment(command.i, command.s);\n                    this.emit(\"segment-start-load\", this.downloadingSegment.id)\n                    this.emit(\"segment-size\", this.downloadingSegment.id, this.downloadingSegment.size)\n                    this.cancelResponseTimeoutTimer();\n                }\n                break;\n\n            case MediaPeerCommands.SegmentAbsent:\n                if (this.downloadingSegmentId && this.downloadingSegmentId === command.i) {\n                    this.terminateSegmentRequest();\n                    this.segmentsMap.delete(command.i);\n                    this.emit(\"segment-absent\", this, command.i);\n                }\n                break;\n\n            case MediaPeerCommands.CancelSegmentRequest:\n                // TODO: peer stop sending buffer\n                break;\n\n            default:\n                break;\n        }\n    };\n\n    private createSegmentsMap = (segments: unknown) => {\n        if (!(segments instanceof Object)) {\n            return new Map<string, MediaPeerSegmentStatus>();\n        }\n\n        const segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const streamSwarmId of Object.keys(segments)) {\n            const swarmData = (segments as Record<string, unknown>)[streamSwarmId];\n            if (\n                !(swarmData instanceof Array) ||\n                swarmData.length !== 2 ||\n                typeof swarmData[0] !== \"string\" ||\n                !(swarmData[1] instanceof Array)\n            ) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            const segmentsIds = swarmData[0].split(\"|\");\n            const segmentsStatuses = swarmData[1] as MediaPeerSegmentStatus[];\n\n            if (segmentsIds.length !== segmentsStatuses.length) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            for (let i = 0; i < segmentsIds.length; i++) {\n                const segmentStatus = segmentsStatuses[i];\n                if (typeof segmentStatus !== \"number\" || MediaPeerSegmentStatus[segmentStatus] === undefined) {\n                    return new Map<string, MediaPeerSegmentStatus>();\n                }\n\n                segmentsMap.set(`${streamSwarmId}+${segmentsIds[i]}`, segmentStatus);\n            }\n        }\n\n        return segmentsMap;\n    };\n\n    private sendCommand = (command: MediaPeerCommand): void => {\n        this.debug(\"peer send command\", this.id, command, this);\n        this.peer.write(JSON.stringify(command));\n    };\n\n    public destroy = (): void => {\n        this.debug(\"peer destroy\", this.id, this);\n        this.terminateSegmentRequest();\n        this.peer.destroy();\n    };\n\n    public getDownloadingSegmentId = (): string | null => {\n        return this.downloadingSegmentId;\n    };\n\n    public getSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        return this.segmentsMap;\n    };\n\n    public sendSegmentsMap = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentsMap, m: segmentsMap });\n    };\n\n    public sendSegmentData = (segmentId: string, data: ArrayBuffer): void => {\n        this.sendCommand({\n            c: MediaPeerCommands.SegmentData,\n            i: segmentId,\n            s: data.byteLength,\n        });\n\n        let bytesLeft = data.byteLength;\n        while (bytesLeft > 0) {\n            const bytesToSend =\n                bytesLeft >= this.settings.webRtcMaxMessageSize ? this.settings.webRtcMaxMessageSize : bytesLeft;\n            const buffer = Buffer.from(data, data.byteLength - bytesLeft, bytesToSend);\n\n            this.peer.write(buffer);\n            bytesLeft -= bytesToSend;\n        }\n\n        this.emit(\"bytes-uploaded\", this, segmentId, data.byteLength);\n    };\n\n    public sendSegmentAbsent = (segmentId: string): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentAbsent, i: segmentId });\n    };\n\n    public requestSegment = (segmentId: string): void => {\n        if (this.downloadingSegmentId) {\n            throw new Error(\"A segment is already downloading: \" + this.downloadingSegmentId);\n        }\n\n        this.sendCommand({ c: MediaPeerCommands.SegmentRequest, i: segmentId });\n        this.downloadingSegmentId = segmentId;\n        this.runResponseTimeoutTimer();\n    };\n\n    public cancelSegmentRequest = (): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n\n        if (this.downloadingSegmentId) {\n            const segmentId = this.downloadingSegmentId;\n            downloadingSegment = this.downloadingSegment ? this.downloadingSegment.pieces : undefined;\n            this.terminateSegmentRequest();\n            this.sendCommand({ c: MediaPeerCommands.CancelSegmentRequest, i: segmentId });\n        }\n\n        return downloadingSegment;\n    };\n\n    private runResponseTimeoutTimer = (): void => {\n        this.timer = setTimeout(() => {\n            this.timer = null;\n            if (!this.downloadingSegmentId) {\n                return;\n            }\n            const segmentId = this.downloadingSegmentId;\n            this.cancelSegmentRequest();\n            this.emit(\"segment-timeout\", this, segmentId); // TODO: send peer not responding event\n        }, this.settings.p2pSegmentDownloadTimeout);\n    };\n\n    private cancelResponseTimeoutTimer = (): void => {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n\n    private terminateSegmentRequest = () => {\n        this.downloadingSegmentId = null;\n        this.downloadingSegment = null;\n        this.cancelResponseTimeoutTimer();\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nimport Debug from \"debug\";\nimport Client from \"bittorrent-tracker/client\";\nimport { Buffer } from \"buffer\";\nimport sha1 from \"sha.js/sha1\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\nimport { Segment } from \"./loader-interface\";\nimport { MediaPeer, MediaPeerSegmentStatus } from \"./media-peer\";\nimport { SegmentsStorage, SegmentValidatorCallback } from \"./hybrid-loader\";\n\nconst PEER_PROTOCOL_VERSION = 2;\nconst PEER_ID_VERSION_STRING = '0.6.2'.replace(/\\d*./g, (v) => `0${parseInt(v, 10) % 100}`.slice(-2)).slice(0, 4);\nconst PEER_ID_VERSION_PREFIX = `-WW${PEER_ID_VERSION_STRING}-`; // Using WebTorrent client ID in order to not be banned by websocket trackers\n\nclass PeerSegmentRequest {\n    constructor(readonly peerId: string, readonly segment: Segment) {}\n}\n\nfunction generatePeerId(): ArrayBuffer {\n    const PEER_ID_SYMBOLS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const PEER_ID_LENGTH = 20;\n\n    let peerId = PEER_ID_VERSION_PREFIX;\n\n    for (let i = 0; i < PEER_ID_LENGTH - PEER_ID_VERSION_PREFIX.length; i++) {\n        peerId += PEER_ID_SYMBOLS.charAt(Math.floor(Math.random() * PEER_ID_SYMBOLS.length));\n    }\n\n    return new TextEncoder().encode(peerId).buffer;\n}\n\nexport class P2PMediaManager extends STEEmitter<\n    | \"peer-connected\"\n    | \"peer-closed\"\n    | \"peer-data-updated\"\n    | \"segment-start-load\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n    | \"tracker-update\"\n> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private trackerClient: any = null;\n    private peers = new Map<string, MediaPeer>();\n    private peerCandidates = new Map<string, MediaPeer[]>();\n    private peerSegmentRequests = new Map<string, PeerSegmentRequest>();\n    private streamSwarmId: string | null = null;\n    private readonly peerId: ArrayBuffer;\n    private debug = Debug(\"p2pml:p2p-media-manager\");\n    private pendingTrackerClient: {\n        isDestroyed: boolean;\n    } | null = null;\n    private masterSwarmId?: string;\n\n    public constructor(\n        private segmentsStorage: SegmentsStorage,\n        private settings: {\n            useP2P: boolean;\n            trackerAnnounce: string[];\n            p2pSegmentDownloadTimeout: number;\n            segmentValidator?: SegmentValidatorCallback;\n            webRtcMaxMessageSize: number;\n            rtcConfig?: RTCConfiguration;\n            peerRequestsPerAnnounce: number;\n        }\n    ) {\n        super();\n\n        this.peerId = settings.useP2P ? generatePeerId() : new ArrayBuffer(0);\n\n        if (this.debug.enabled) {\n            this.debug(\"peer ID\", this.getPeerId(), new TextDecoder().decode(this.peerId));\n        }\n    }\n\n    public getPeers = (): Map<string, MediaPeer> => {\n        return this.peers;\n    };\n\n    public getPeerId = (): string => {\n        return Buffer.from(this.peerId).toString(\"hex\");\n    };\n\n    public setStreamSwarmId = (streamSwarmId: string, masterSwarmId: string): void => {\n        if (this.streamSwarmId === streamSwarmId) {\n            return;\n        }\n\n        this.destroy(true);\n\n        this.streamSwarmId = streamSwarmId;\n        this.masterSwarmId = masterSwarmId;\n        this.debug(\"stream swarm ID\", this.streamSwarmId);\n\n        this.pendingTrackerClient = {\n            isDestroyed: false,\n        };\n\n        const pendingTrackerClient = this.pendingTrackerClient;\n\n        // TODO: native browser 'crypto.subtle' implementation doesn't work in Chrome in insecure pages\n        // TODO: Edge doesn't support SHA-1. Change to SHA-256 once Edge support is required.\n        // const infoHash = await crypto.subtle.digest(\"SHA-1\", new TextEncoder().encode(PEER_PROTOCOL_VERSION + this.streamSwarmId));\n\n        const infoHash = new sha1().update(`${PEER_PROTOCOL_VERSION}${this.streamSwarmId}`).digest();\n\n        // destroy may be called while waiting for the hash to be calculated\n        if (!pendingTrackerClient.isDestroyed) {\n            this.pendingTrackerClient = null;\n            this.createClient(infoHash);\n        } else if (this.trackerClient !== null) {\n            this.trackerClient.destroy();\n            this.trackerClient = null;\n        }\n    };\n\n    private createClient = (infoHash: ArrayBuffer): void => {\n        if (!this.settings.useP2P) {\n            return;\n        }\n\n        const clientOptions = {\n            infoHash: Buffer.from(infoHash, 0, 20),\n            peerId: Buffer.from(this.peerId, 0, 20),\n            announce: this.settings.trackerAnnounce,\n            rtcConfig: this.settings.rtcConfig,\n            port: 6881, // a dummy value allows running in Node.js environment\n            getAnnounceOpts: () => {\n                return { numwant: this.settings.peerRequestsPerAnnounce };\n            },\n        };\n\n        let oldTrackerClient = this.trackerClient;\n\n        this.trackerClient = new Client(clientOptions);\n        this.trackerClient.on(\"error\", this.onTrackerError);\n        this.trackerClient.on(\"warning\", this.onTrackerWarning);\n        this.trackerClient.on(\"update\", this.onTrackerUpdate);\n        this.trackerClient.on(\"peer\", this.onTrackerPeer);\n\n        this.trackerClient.start();\n\n        if (oldTrackerClient !== null) {\n            oldTrackerClient.destroy();\n            oldTrackerClient = null;\n        }\n    };\n\n    private onTrackerError = (error: unknown) => {\n        this.debug(\"tracker error\", error);\n    };\n\n    private onTrackerWarning = (warning: unknown) => {\n        this.debug(\"tracker warning\", warning);\n    };\n\n    private onTrackerUpdate = (data: unknown): void => {\n        this.debug(\"tracker update\", data);\n        this.emit(\"tracker-update\", data);\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private onTrackerPeer = (trackerPeer: any): void => {\n        this.debug(\"tracker peer\", trackerPeer.id, trackerPeer);\n\n        if (this.peers.has(trackerPeer.id)) {\n            this.debug(\"tracker peer already connected\", trackerPeer.id, trackerPeer);\n            trackerPeer.destroy();\n            return;\n        }\n\n        const peer = new MediaPeer(trackerPeer, this.settings);\n\n        peer.on(\"connect\", this.onPeerConnect);\n        peer.on(\"close\", this.onPeerClose);\n        peer.on(\"data-updated\", this.onPeerDataUpdated);\n        peer.on(\"segment-request\", this.onSegmentRequest);\n        peer.on(\"segment-loaded\", this.onSegmentLoaded);\n        peer.on(\"segment-absent\", this.onSegmentAbsent);\n        peer.on(\"segment-error\", this.onSegmentError);\n        peer.on(\"segment-size\", this.onSegmentSize);\n        peer.on(\"segment-start-load\", this.onSegmentStartLoad);\n        peer.on(\"segment-timeout\", this.onSegmentTimeout);\n        peer.on(\"bytes-downloaded\", this.onPieceBytesDownloaded);\n        peer.on(\"bytes-uploaded\", this.onPieceBytesUploaded);\n\n        let peerCandidatesById = this.peerCandidates.get(peer.id);\n\n        if (!peerCandidatesById) {\n            peerCandidatesById = [];\n            this.peerCandidates.set(peer.id, peerCandidatesById);\n        }\n\n        peerCandidatesById.push(peer);\n    };\n\n    public download = (segment: Segment): boolean => {\n        if (this.isDownloading(segment)) {\n            return false;\n        }\n\n        const candidates: MediaPeer[] = [];\n\n        for (const peer of this.peers.values()) {\n            if (\n                peer.getDownloadingSegmentId() === null &&\n                peer.getSegmentsMap().get(segment.id) === MediaPeerSegmentStatus.Loaded\n            ) {\n                candidates.push(peer);\n            }\n        }\n\n        if (candidates.length === 0) {\n            return false;\n        }\n\n        const peer = candidates[Math.floor(Math.random() * candidates.length)];\n        peer.requestSegment(segment.id);\n        this.peerSegmentRequests.set(segment.id, new PeerSegmentRequest(peer.id, segment));\n        return true;\n    };\n\n    public abort = (segment: Segment): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n        const peerSegmentRequest = this.peerSegmentRequests.get(segment.id);\n        if (peerSegmentRequest) {\n            const peer = this.peers.get(peerSegmentRequest.peerId);\n            if (peer) {\n                downloadingSegment = peer.cancelSegmentRequest();\n            }\n            this.peerSegmentRequests.delete(segment.id);\n        }\n        return downloadingSegment;\n    };\n\n    public isDownloading = (segment: Segment): boolean => {\n        return this.peerSegmentRequests.has(segment.id);\n    };\n\n    public getActiveDownloadsCount = (): number => {\n        return this.peerSegmentRequests.size;\n    };\n\n    public destroy = (swarmChange = false): void => {\n        this.streamSwarmId = null;\n\n        if (this.trackerClient) {\n            this.trackerClient.stop();\n            if (swarmChange) {\n                // Don't destroy trackerClient to reuse its WebSocket connection to the tracker server\n                this.trackerClient.removeAllListeners(\"error\");\n                this.trackerClient.removeAllListeners(\"warning\");\n                this.trackerClient.removeAllListeners(\"update\");\n                this.trackerClient.removeAllListeners(\"peer\");\n            } else {\n                this.trackerClient.destroy();\n                this.trackerClient = null;\n            }\n        }\n\n        if (this.pendingTrackerClient) {\n            this.pendingTrackerClient.isDestroyed = true;\n            this.pendingTrackerClient = null;\n        }\n\n        this.peers.forEach((peer) => peer.destroy());\n        this.peers.clear();\n\n        this.peerSegmentRequests.clear();\n\n        for (const peerCandidateById of this.peerCandidates.values()) {\n            for (const peerCandidate of peerCandidateById) {\n                peerCandidate.destroy();\n            }\n        }\n        this.peerCandidates.clear();\n    };\n\n    public sendSegmentsMapToAll = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.peers.forEach((peer) => peer.sendSegmentsMap(segmentsMap));\n    };\n\n    public sendSegmentsMap = (peerId: string, segmentsMap: { [key: string]: [string, number[]] }): void => {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.sendSegmentsMap(segmentsMap);\n        }\n    };\n\n    public getOverallSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        const overallSegmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const peer of this.peers.values()) {\n            for (const [segmentId, segmentStatus] of peer.getSegmentsMap()) {\n                if (segmentStatus === MediaPeerSegmentStatus.Loaded) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.Loaded);\n                } else if (!overallSegmentsMap.get(segmentId)) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.LoadingByHttp);\n                }\n            }\n        }\n\n        return overallSegmentsMap;\n    };\n\n    private onPieceBytesDownloaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"bytes-downloaded\", peerSegmentRequest.segment, bytes, peer.id);\n        }\n    };\n\n    private onPieceBytesUploaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        \n        this.emit(\"bytes-uploaded\", peerSegmentRequest ? peerSegmentRequest.segment : null, bytes, peer.id);\n      \n    };\n\n    private onPeerConnect = (peer: MediaPeer) => {\n        const connectedPeer = this.peers.get(peer.id);\n\n        if (connectedPeer) {\n            this.debug(\"tracker peer already connected (in peer connect)\", peer.id, peer);\n            peer.destroy();\n            return;\n        }\n\n        // First peer with the ID connected\n        this.peers.set(peer.id, peer);\n\n        // Destroy all other peer candidates\n        const peerCandidatesById = this.peerCandidates.get(peer.id);\n        if (peerCandidatesById) {\n            for (const peerCandidate of peerCandidatesById) {\n                if (peerCandidate !== peer) {\n                    peerCandidate.destroy();\n                }\n            }\n\n            this.peerCandidates.delete(peer.id);\n        }\n\n        this.emit(\"peer-connected\", { id: peer.id, remoteAddress: peer.remoteAddress });\n    };\n\n    private onPeerClose = (peer: MediaPeer) => {\n        if (this.peers.get(peer.id) !== peer) {\n            // Try to delete the peer candidate\n\n            const peerCandidatesById = this.peerCandidates.get(peer.id);\n            if (!peerCandidatesById) {\n                return;\n            }\n\n            const index = peerCandidatesById.indexOf(peer);\n            if (index !== -1) {\n                peerCandidatesById.splice(index, 1);\n            }\n\n            if (peerCandidatesById.length === 0) {\n                this.peerCandidates.delete(peer.id);\n            }\n\n            return;\n        }\n\n        for (const [key, value] of this.peerSegmentRequests) {\n            if (value.peerId === peer.id) {\n                this.peerSegmentRequests.delete(key);\n            }\n        }\n\n        this.peers.delete(peer.id);\n        this.emit(\"peer-data-updated\");\n        this.emit(\"peer-closed\", peer.id);\n    };\n\n    private onPeerDataUpdated = () => {\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentRequest = async (peer: MediaPeer, segmentId: string) => {\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        const segment = await this.segmentsStorage.getSegment(segmentId, this.masterSwarmId);\n        if (segment && segment.data) {\n            peer.sendSegmentData(segmentId, segment.data);\n        } else {\n            peer.sendSegmentAbsent(segmentId);\n        }\n    };\n\n    private onSegmentLoaded = async (peer: MediaPeer, segmentId: string, data: ArrayBuffer) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (!peerSegmentRequest) {\n            return;\n        }\n\n        const segment = peerSegmentRequest.segment;\n\n        if (this.settings.segmentValidator) {\n            try {\n                await this.settings.segmentValidator({ ...segment, data: data }, \"p2p\", peer.id);\n            } catch (error) {\n                this.debug(\"segment validator failed\", error);\n                this.peerSegmentRequests.delete(segmentId);\n                this.emit(\"segment-error\", segment, error, peer.id);\n                this.onPeerClose(peer);\n                return;\n            }\n        }\n\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"segment-loaded\", segment, data, peer.id);\n    };\n\n    private onSegmentAbsent = (peer: MediaPeer, segmentId: string) => {\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentError = (peer: MediaPeer, segmentId: string, description: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            this.emit(\"segment-error\", peerSegmentRequest.segment, description, peer.id);\n        }\n    };\n\n    private onSegmentSize = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-size\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentStartLoad = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-start-load\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentTimeout = (peer: MediaPeer, segmentId: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            peer.destroy();\n            if (this.peers.delete(peerSegmentRequest.peerId)) {\n                this.emit(\"peer-data-updated\");\n            }\n        }\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\n\nconst debug = Debug(\"p2pml:bandwidth-approximator\");\n\nconst SMOOTH_INTERVAL = 2 * 1000;\nconst MEASURE_INTERVAL = 40 * 1000;\n\nclass NumberWithTime {\n    constructor(readonly value: number, readonly timeStamp: number) {}\n}\n\nexport class BandwidthApproximator {\n    private lastBytes: NumberWithTime[] = [];\n    private currentBytesSum = 0;\n    private lastBandwidth: NumberWithTime[] = [];\n\n    public addBytes = (bytes: number, timeStamp: number): void => {\n        debug(\"Add %d bytes.\", bytes)\n\n        this.lastBytes.push(new NumberWithTime(bytes, timeStamp));\n        this.currentBytesSum += bytes;\n\n        while (timeStamp - this.lastBytes[0].timeStamp > SMOOTH_INTERVAL) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.currentBytesSum -= this.lastBytes.shift()!.value;\n        }\n\n        const interval = Math.min(SMOOTH_INTERVAL, timeStamp);\n        this.lastBandwidth.push(new NumberWithTime(this.currentBytesSum / interval, timeStamp));\n    };\n\n    // in bytes per millisecond\n    public getBandwidth = (timeStamp: number): number => {\n        while (this.lastBandwidth.length !== 0 && timeStamp - this.lastBandwidth[0].timeStamp > MEASURE_INTERVAL) {\n            this.lastBandwidth.shift();\n        }\n\n        let maxBandwidth = 0;\n        for (const bandwidth of this.lastBandwidth) {\n            if (bandwidth.value > maxBandwidth) {\n                maxBandwidth = bandwidth.value;\n            }\n        }\n\n        debug(\"Max bandwidth: %d.\", maxBandwidth)\n\n        return maxBandwidth;\n    };\n\n    public getSmoothInterval = (): number => {\n        return SMOOTH_INTERVAL;\n    };\n\n    public getMeasureInterval = (): number => {\n        return MEASURE_INTERVAL;\n    };\n}\n","/**\n * Copyright 2019 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Segment } from \"./loader-interface\";\nimport { SegmentsStorage } from \"./hybrid-loader\";\n\nexport class SegmentsMemoryStorage implements SegmentsStorage {\n    private cache = new Map<string, { segment: Segment; lastAccessed: number }>();\n\n    constructor(\n        private settings: {\n            cachedSegmentExpiration: number;\n            cachedSegmentsCount: number;\n        }\n    ) {}\n\n    public storeSegment = async (segment: Segment): Promise<void> => {\n        this.cache.set(segment.id, { segment, lastAccessed: performance.now() });\n    };\n\n    public getSegmentsMap = async (): Promise<Map<string, { segment: Segment }>> => {\n        return this.cache;\n    };\n\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\n        const cacheItem = this.cache.get(id);\n\n        if (cacheItem === undefined) {\n            return undefined;\n        }\n\n        cacheItem.lastAccessed = performance.now();\n        return cacheItem.segment;\n    };\n\n    public hasSegment = async (id: string): Promise<boolean> => {\n        return this.cache.has(id);\n    };\n\n    public clean = async (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean): Promise<boolean> => {\n        const segmentsToDelete: string[] = [];\n        const remainingSegments: { segment: Segment; lastAccessed: number }[] = [];\n\n        // Delete old segments\n        const now = performance.now();\n\n        for (const cachedSegment of this.cache.values()) {\n            if (now - cachedSegment.lastAccessed > this.settings.cachedSegmentExpiration) {\n                segmentsToDelete.push(cachedSegment.segment.id);\n            } else {\n                remainingSegments.push(cachedSegment);\n            }\n        }\n\n        // Delete segments over cached count\n        let countOverhead = remainingSegments.length - this.settings.cachedSegmentsCount;\n        if (countOverhead > 0) {\n            remainingSegments.sort((a, b) => a.lastAccessed - b.lastAccessed);\n\n            for (const cachedSegment of remainingSegments) {\n                if (lockedSegmentsFilter === undefined || !lockedSegmentsFilter(cachedSegment.segment.id)) {\n                    segmentsToDelete.push(cachedSegment.segment.id);\n                    countOverhead--;\n                    if (countOverhead === 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        segmentsToDelete.forEach((id) => this.cache.delete(id));\n        return segmentsToDelete.length > 0;\n    };\n\n    public destroy = async (): Promise<void> => {\n        this.cache.clear();\n    };\n}\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport Debug from \"debug\";\r\nimport { EventEmitter } from \"events\";\r\nimport Peer from \"simple-peer\";\r\n\r\nimport { LoaderInterface, Events, Segment } from \"./loader-interface\";\r\nimport { HttpMediaManager } from \"./http-media-manager\";\r\nimport { P2PMediaManager } from \"./p2p-media-manager\";\r\nimport { MediaPeerSegmentStatus } from \"./media-peer\";\r\nimport { BandwidthApproximator } from \"./bandwidth-approximator\";\r\nimport { SegmentsMemoryStorage } from \"./segments-memory-storage\";\r\n/*\r\nconst defaultSettings: HybridLoaderSettings = {\r\n    cachedSegmentExpiration: 5 * 60 * 1000,\r\n    cachedSegmentsCount: 30,\r\n\r\n    useP2P: true,\r\n    consumeOnly: false,\r\n\r\n    requiredSegmentsPriority: 1,\r\n\r\n    simultaneousHttpDownloads: 2,\r\n    httpDownloadProbability: 0.1,\r\n    httpDownloadProbabilityInterval: 1000,\r\n    httpDownloadProbabilitySkipIfNoPeers: false,\r\n    httpFailedSegmentTimeout: 10000,\r\n    httpDownloadMaxPriority: 20,\r\n    httpDownloadInitialTimeout: 0,\r\n    httpDownloadInitialTimeoutPerSegment: 4000,\r\n    httpUseRanges: false,\r\n\r\n    simultaneousP2PDownloads: 3,\r\n    p2pDownloadMaxPriority: 20,\r\n    p2pSegmentDownloadTimeout: 60000,\r\n\r\n    webRtcMaxMessageSize: 64 * 1024 - 1,\r\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\r\n    peerRequestsPerAnnounce: 10,\r\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\r\n};*/\r\n\r\n\r\nconst defaultSettings: HybridLoaderSettings & { localTransport?: typeof fetch } = {\r\n    cachedSegmentExpiration: 10 * 60 * 1000,\r\n    cachedSegmentsCount: 1000,\r\n\r\n    useP2P: true,\r\n    consumeOnly: false,\r\n\r\n    requiredSegmentsPriority: 3,\r\n\r\n    simultaneousHttpDownloads: 2,\r\n    httpDownloadProbability: 0.06,\r\n    httpDownloadProbabilityInterval: 1000,\r\n    httpDownloadProbabilitySkipIfNoPeers: false,\r\n    httpFailedSegmentTimeout: 1500,\r\n    httpDownloadMaxPriority: 20,\r\n    httpDownloadInitialTimeout: 0,\r\n    httpDownloadInitialTimeoutPerSegment: 100, ///segment = 4000\r\n    httpUseRanges: false,\r\n\r\n    simultaneousP2PDownloads: 20,\r\n    p2pDownloadMaxPriority: 50,\r\n    p2pSegmentDownloadTimeout: 60000,\r\n\r\n    webRtcMaxMessageSize: 64 * 1024 - 1,\r\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\r\n    peerRequestsPerAnnounce: 10,\r\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\r\n};\r\n\r\nexport class HybridLoader extends EventEmitter implements LoaderInterface {\r\n    private readonly debug = Debug(\"p2pml:hybrid-loader\");\r\n    private readonly debugSegments = Debug(\"p2pml:hybrid-loader-segments\");\r\n    private readonly httpManager: HttpMediaManager;\r\n    private readonly p2pManager: P2PMediaManager;\r\n    private segmentsStorage: SegmentsStorage;\r\n    private segmentsQueue: Segment[] = [];\r\n    private readonly bandwidthApproximator = new BandwidthApproximator();\r\n    private readonly settings: HybridLoaderSettings & { localTransport?: typeof fetch };\r\n    private httpRandomDownloadInterval: ReturnType<typeof setInterval> | undefined;\r\n    private httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n    private masterSwarmId?: string;\r\n\r\n    public static isSupported = (): boolean => {\r\n        return window.RTCPeerConnection.prototype.createDataChannel !== undefined;\r\n    };\r\n\r\n    public constructor(settings: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }> = {}) {\r\n        super();\r\n\r\n        this.settings = { ...defaultSettings, ...settings };\r\n\r\n        const { bufferedSegmentsCount } = settings as Record<string, unknown>;\r\n\r\n        if (typeof bufferedSegmentsCount === \"number\") {\r\n            if (settings.p2pDownloadMaxPriority === undefined) {\r\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\r\n            }\r\n\r\n            if (settings.httpDownloadMaxPriority === undefined) {\r\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\r\n            }\r\n        }\r\n\r\n        this.segmentsStorage =\r\n            this.settings.segmentsStorage === undefined\r\n                ? new SegmentsMemoryStorage(this.settings)\r\n                : this.settings.segmentsStorage;\r\n\r\n        this.debug(\"loader settings\", this.settings);\r\n\r\n        this.httpManager = this.createHttpManager();\r\n        this.httpManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"http\", segment));\r\n        this.httpManager.on(\"segment-loaded\", this.onSegmentLoaded);\r\n        this.httpManager.on(\"segment-error\", this.onSegmentError);\r\n        this.httpManager.on(\"segment-size\", this.onSegmentSize);\r\n        this.httpManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number) => {\r\n            this.onPieceBytesDownloaded(\"http\", segment, bytes)\r\n        });\r\n\r\n        this.p2pManager = this.createP2PManager();\r\n        this.p2pManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"p2p\", segment));\r\n        this.p2pManager.on(\"segment-loaded\", this.onSegmentLoaded);\r\n        this.p2pManager.on(\"segment-error\", this.onSegmentError);\r\n        this.p2pManager.on(\"segment-size\", this.onSegmentSize);\r\n        this.p2pManager.on(\"peer-data-updated\", async () => {\r\n            if (this.masterSwarmId === undefined) {\r\n                return;\r\n            }\r\n\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        });\r\n        this.p2pManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number, peerId: string) =>\r\n            this.onPieceBytesDownloaded(\"p2p\", segment, bytes, peerId)\r\n        );\r\n        this.p2pManager.on(\"bytes-uploaded\", (segment: Segment, bytes: number, peerId: string) =>\r\n            this.onPieceBytesUploaded(\"p2p\", segment, bytes, peerId)\r\n        );\r\n        this.p2pManager.on(\"peer-connected\", this.onPeerConnect);\r\n        this.p2pManager.on(\"peer-closed\", this.onPeerClose);\r\n        this.p2pManager.on(\"tracker-update\", this.onTrackerUpdate);\r\n    }\r\n\r\n    private createHttpManager = () => {\r\n        return new HttpMediaManager(this.settings);\r\n    };\r\n\r\n    private createP2PManager = () => {\r\n        return new P2PMediaManager(this.segmentsStorage, this.settings);\r\n    };\r\n\r\n    public load = async (segments: Segment[], streamSwarmId: string): Promise<void> => {\r\n        if (this.httpRandomDownloadInterval === undefined) {\r\n            // Do once on first call\r\n            this.httpRandomDownloadInterval = setInterval(\r\n                this.downloadRandomSegmentOverHttp,\r\n                this.settings.httpDownloadProbabilityInterval\r\n            );\r\n\r\n            if (\r\n                this.settings.httpDownloadInitialTimeout > 0 &&\r\n                this.settings.httpDownloadInitialTimeoutPerSegment > 0\r\n            ) {\r\n                // Initialize initial HTTP download timeout (i.e. download initial segments over P2P)\r\n                this.debugSegments(\r\n                    \"enable initial HTTP download timeout\",\r\n                    this.settings.httpDownloadInitialTimeout,\r\n                    \"per segment\",\r\n                    this.settings.httpDownloadInitialTimeoutPerSegment\r\n                );\r\n                this.httpDownloadInitialTimeoutTimestamp = this.now();\r\n                setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment + 100);\r\n            }\r\n        }\r\n\r\n        if (segments.length > 0) {\r\n            this.masterSwarmId = segments[0].masterSwarmId;\r\n        }\r\n\r\n        if (this.masterSwarmId !== undefined) {\r\n            this.p2pManager.setStreamSwarmId(streamSwarmId, this.masterSwarmId);\r\n        }\r\n\r\n        this.debug(\"load segments\");\r\n\r\n        let updateSegmentsMap = false;\r\n\r\n        // stop all http requests and p2p downloads for segments that are not in the new load\r\n        for (const segment of this.segmentsQueue) {\r\n            if (!segments.find((f) => f.url === segment.url)) {\r\n                this.debug(\"remove segment\", segment.url);\r\n                if (this.httpManager.isDownloading(segment)) {\r\n                    updateSegmentsMap = true;\r\n                    this.httpManager.abort(segment);\r\n                } else {\r\n                    this.p2pManager.abort(segment);\r\n                }\r\n                this.emit(Events.SegmentAbort, segment);\r\n            }\r\n        }\r\n\r\n        if (this.debug.enabled) {\r\n            for (const segment of segments) {\r\n                if (!this.segmentsQueue.find((f) => f.url === segment.url)) {\r\n                    this.debug(\"add segment\", segment.url);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.segmentsQueue = segments;\r\n\r\n        if (this.masterSwarmId === undefined) {\r\n            return;\r\n        }\r\n\r\n        let storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n        updateSegmentsMap = this.processSegmentsQueue(storageSegments) || updateSegmentsMap;\r\n\r\n        if (await this.cleanSegmentsStorage()) {\r\n            storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            updateSegmentsMap = true;\r\n        }\r\n\r\n        if (updateSegmentsMap && !this.settings.consumeOnly) {\r\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n        }\r\n    };\r\n\r\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\r\n        return this.masterSwarmId === undefined ? undefined : this.segmentsStorage.getSegment(id, this.masterSwarmId);\r\n    };\r\n\r\n    public getSettings = (): HybridLoaderSettings => {\r\n        return this.settings;\r\n    };\r\n\r\n    public getDetails = (): { peerId: string } => {\r\n        return {\r\n            peerId: this.p2pManager.getPeerId(),\r\n        };\r\n    };\r\n\r\n    public getBandwidthEstimate = (): number => {\r\n        return this.bandwidthApproximator.getBandwidth(this.now());\r\n    };\r\n\r\n    public destroy = async (): Promise<void> => {\r\n        if (this.httpRandomDownloadInterval !== undefined) {\r\n            clearInterval(this.httpRandomDownloadInterval);\r\n            this.httpRandomDownloadInterval = undefined;\r\n        }\r\n\r\n        this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n\r\n        this.segmentsQueue = [];\r\n        this.httpManager.destroy();\r\n        this.p2pManager.destroy();\r\n        this.masterSwarmId = undefined;\r\n        await this.segmentsStorage.destroy();\r\n    };\r\n\r\n    private processInitialSegmentTimeout = async () => {\r\n        if (this.httpRandomDownloadInterval === undefined) {\r\n            return; // Instance destroyed\r\n        }\r\n\r\n        if (this.masterSwarmId !== undefined) {\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        }\r\n\r\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\r\n            // Set one more timeout for a next segment\r\n            setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment);\r\n        }\r\n    };\r\n\r\n    private processSegmentsQueue = (storageSegments: Map<string, { segment: Segment }>) => {\r\n        this.debugSegments(\r\n            \"process segments queue. priority\",\r\n            this.segmentsQueue.length > 0 ? this.segmentsQueue[0].priority : 0\r\n        );\r\n\r\n        if (this.masterSwarmId === undefined || this.segmentsQueue.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        let updateSegmentsMap = false;\r\n        let segmentsMap: Map<string, MediaPeerSegmentStatus> | undefined;\r\n\r\n        let httpAllowed = true;\r\n\r\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\r\n            let firstNotDownloadePriority: number | undefined;\r\n\r\n            for (const segment of this.segmentsQueue) {\r\n                if (!storageSegments.has(segment.id)) {\r\n                    firstNotDownloadePriority = segment.priority;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            const httpTimeout = this.now() - this.httpDownloadInitialTimeoutTimestamp;\r\n            httpAllowed =\r\n                httpTimeout >= this.settings.httpDownloadInitialTimeout ||\r\n                (firstNotDownloadePriority !== undefined &&\r\n                    httpTimeout > this.settings.httpDownloadInitialTimeoutPerSegment &&\r\n                    firstNotDownloadePriority <= 0);\r\n\r\n            if (httpAllowed) {\r\n                this.debugSegments(\"cancel initial HTTP download timeout - timed out\");\r\n                this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this.segmentsQueue.length; index++) {\r\n            const segment = this.segmentsQueue[index];\r\n\r\n            if (storageSegments.has(segment.id)) {\r\n                continue;\r\n            }\r\n\r\n            // Segment priority changed, notify http manager\r\n            if (this.httpManager.isDownloading(segment)) {\r\n                this.httpManager.updatePriority(segment);\r\n                continue;\r\n            }\r\n\r\n            if (\r\n                segment.priority <= this.settings.requiredSegmentsPriority &&\r\n                httpAllowed &&\r\n                !this.httpManager.isFailed(segment)\r\n            ) {\r\n                // Download required segments over HTTP\r\n                if (this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads) {\r\n                    // Not enough HTTP download resources. Abort one of the HTTP downloads.\r\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\r\n                        const segmentToAbort = this.segmentsQueue[i];\r\n                        if (this.httpManager.isDownloading(segmentToAbort)) {\r\n                            this.debugSegments(\"cancel HTTP download\", segmentToAbort.priority, segmentToAbort.url);\r\n                            this.httpManager.abort(segmentToAbort);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.httpManager.getActiveDownloadsCount() < this.settings.simultaneousHttpDownloads) {\r\n                    // Abort P2P download of the required segment if any and force HTTP download\r\n                    const downloadedPieces = this.p2pManager.abort(segment);\r\n                    this.httpManager.download(segment, downloadedPieces);\r\n                    this.debugSegments(\"HTTP download (priority)\", segment.priority, segment.url);\r\n                    updateSegmentsMap = true;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (this.p2pManager.isDownloading(segment)) {\r\n                continue;\r\n            }\r\n\r\n            if (segment.priority <= this.settings.requiredSegmentsPriority) {\r\n                // Download required segments over P2P\r\n                segmentsMap = segmentsMap ? segmentsMap : this.p2pManager.getOverallSegmentsMap();\r\n\r\n                if (segmentsMap.get(segment.id) !== MediaPeerSegmentStatus.Loaded) {\r\n                    continue;\r\n                }\r\n\r\n                if (this.p2pManager.getActiveDownloadsCount() >= this.settings.simultaneousP2PDownloads) {\r\n                    // Not enough P2P download resources. Abort one of the P2P downloads.\r\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\r\n                        const segmentToAbort = this.segmentsQueue[i];\r\n                        if (this.p2pManager.isDownloading(segmentToAbort)) {\r\n                            this.debugSegments(\"cancel P2P download\", segmentToAbort.priority, segmentToAbort.url);\r\n                            this.p2pManager.abort(segmentToAbort);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads) {\r\n                    if (this.p2pManager.download(segment)) {\r\n                        this.debugSegments(\"P2P download (priority)\", segment.priority, segment.url);\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (\r\n                this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads &&\r\n                segment.priority <= this.settings.p2pDownloadMaxPriority\r\n            ) {\r\n                if (this.p2pManager.download(segment)) {\r\n                    this.debugSegments(\"P2P download\", segment.priority, segment.url);\r\n                }\r\n            }\r\n        }\r\n\r\n        return updateSegmentsMap;\r\n    };\r\n\r\n    private downloadRandomSegmentOverHttp = async () => {\r\n        if (\r\n            this.masterSwarmId === undefined ||\r\n            this.httpRandomDownloadInterval === undefined ||\r\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity ||\r\n            this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads ||\r\n            (this.settings.httpDownloadProbabilitySkipIfNoPeers && this.p2pManager.getPeers().size === 0) ||\r\n            this.settings.consumeOnly\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n        const segmentsMap = this.p2pManager.getOverallSegmentsMap();\r\n\r\n        const pendingQueue = this.segmentsQueue.filter(\r\n            (s) =>\r\n                !this.p2pManager.isDownloading(s) &&\r\n                !this.httpManager.isDownloading(s) &&\r\n                !segmentsMap.has(s.id) &&\r\n                !this.httpManager.isFailed(s) &&\r\n                s.priority <= this.settings.httpDownloadMaxPriority &&\r\n                !storageSegments.has(s.id)\r\n        );\r\n\r\n        if (pendingQueue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (Math.random() > this.settings.httpDownloadProbability * pendingQueue.length) {\r\n            return;\r\n        }\r\n\r\n        const segment = pendingQueue[Math.floor(Math.random() * pendingQueue.length)];\r\n        this.debugSegments(\"HTTP download (random)\", segment.priority, segment.url);\r\n        this.httpManager.download(segment);\r\n        this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n    };\r\n\r\n    private onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\r\n        this.emit(Events.SegmentStartLoad, method, segment);\r\n    };\r\n\r\n    private onPieceBytesDownloaded = (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\r\n        this.bandwidthApproximator.addBytes(bytes, this.now());\r\n        this.emit(Events.PieceBytesDownloaded, method, segment, bytes, peerId);\r\n\r\n    };\r\n\r\n    private onPieceBytesUploaded = (method: \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\r\n        this.emit(Events.PieceBytesUploaded, method, segment, bytes, peerId);\r\n    };\r\n\r\n    private onSegmentLoaded = async (segment: Segment, data: ArrayBuffer, peerId?: string) => {\r\n        this.debugSegments(\"segment loaded\", segment.id, segment.url);\r\n\r\n        if (this.masterSwarmId === undefined) {\r\n            return;\r\n        }\r\n\r\n        segment.data = data;\r\n        segment.downloadBandwidth = this.bandwidthApproximator.getBandwidth(this.now());\r\n\r\n        await this.segmentsStorage.storeSegment(segment);\r\n        this.emit(Events.SegmentLoaded, segment, peerId);\r\n\r\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n        this.processSegmentsQueue(storageSegments);\r\n        if (!this.settings.consumeOnly) {\r\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n        }\r\n    };\r\n\r\n    private onSegmentError = async (segment: Segment, details: unknown, peerId?: string) => {\r\n        this.debugSegments(\"segment error\", segment.id, segment.url, peerId, details);\r\n        this.emit(Events.SegmentError, segment, details, peerId);\r\n        if (this.masterSwarmId !== undefined) {\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        }\r\n    };\r\n\r\n    private onSegmentSize = async (segment: Segment, size: number) => {\r\n        this.debugSegments(\"segment size\", segment.id, size);\r\n        this.emit(Events.SegmentSize, segment, size);\r\n    };\r\n\r\n    private getStreamSwarmId = (segment: Segment) => {\r\n        return segment.streamId === undefined ? segment.masterSwarmId : `${segment.masterSwarmId}+${segment.streamId}`;\r\n    };\r\n\r\n    private createSegmentsMap = (storageSegments: Map<string, { segment: Segment }>) => {\r\n        const segmentsMap: { [key: string]: [string, number[]] } = {};\r\n\r\n        const addSegmentToMap = (segment: Segment, status: MediaPeerSegmentStatus) => {\r\n            const streamSwarmId = this.getStreamSwarmId(segment);\r\n            const segmentId = segment.sequence;\r\n\r\n            let segmentsIdsAndStatuses = segmentsMap[streamSwarmId];\r\n            if (segmentsIdsAndStatuses === undefined) {\r\n                segmentsIdsAndStatuses = [\"\", []];\r\n                segmentsMap[streamSwarmId] = segmentsIdsAndStatuses;\r\n            }\r\n            const segmentsStatuses = segmentsIdsAndStatuses[1];\r\n            segmentsIdsAndStatuses[0] += segmentsStatuses.length === 0 ? segmentId : `|${segmentId}`;\r\n            segmentsStatuses.push(status);\r\n        };\r\n\r\n        for (const storageSegment of storageSegments.values()) {\r\n            addSegmentToMap(storageSegment.segment, MediaPeerSegmentStatus.Loaded);\r\n        }\r\n\r\n        for (const download of this.httpManager.getActiveDownloads().values()) {\r\n            addSegmentToMap(download.segment, MediaPeerSegmentStatus.LoadingByHttp);\r\n        }\r\n\r\n        return segmentsMap;\r\n    };\r\n\r\n    private onPeerConnect = async (peer: { id: string }) => {\r\n        this.emit(Events.PeerConnect, peer);\r\n        if (!this.settings.consumeOnly && this.masterSwarmId !== undefined) {\r\n            this.p2pManager.sendSegmentsMap(\r\n                peer.id,\r\n                this.createSegmentsMap(await this.segmentsStorage.getSegmentsMap(this.masterSwarmId))\r\n            );\r\n        }\r\n    };\r\n\r\n    private onPeerClose = (peerId: string) => {\r\n        this.emit(Events.PeerClose, peerId);\r\n    };\r\n\r\n    private onTrackerUpdate = async (data: { incomplete?: number }) => {\r\n        if (\r\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity &&\r\n            data.incomplete !== undefined &&\r\n            data.incomplete <= 1\r\n        ) {\r\n            this.debugSegments(\"cancel initial HTTP download timeout - no peers\");\r\n\r\n            this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n\r\n            if (this.masterSwarmId !== undefined) {\r\n                const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n                if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                    this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    private cleanSegmentsStorage = async (): Promise<boolean> => {\r\n        if (this.masterSwarmId === undefined) {\r\n            return false;\r\n        }\r\n\r\n        return this.segmentsStorage.clean(\r\n            this.masterSwarmId,\r\n            (id: string) => this.segmentsQueue.find((queueSegment) => queueSegment.id === id) !== undefined\r\n        );\r\n    };\r\n\r\n    private now = () => {\r\n        return performance.now();\r\n    };\r\n}\r\n\r\nexport interface SegmentsStorage {\r\n    storeSegment: (segment: Segment) => Promise<void>;\r\n    getSegmentsMap: (masterSwarmId: string) => Promise<Map<string, { segment: Segment }>>;\r\n    getSegment: (id: string, masterSwarmId: string) => Promise<Segment | undefined>;\r\n    clean: (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean) => Promise<boolean>;\r\n    destroy: () => Promise<void>;\r\n}\r\n\r\nexport type SegmentValidatorCallback = (segment: Segment, method: \"http\" | \"p2p\", peerId?: string) => Promise<void>;\r\n/* export type XhrSetupCallback = (xhr: XMLHttpRequest, url: string) => void; */\r\nexport type SegmentUrlBuilder = (segment: Segment) => string;\r\n\r\nexport type HybridLoaderSettings = {\r\n    /**\r\n     * Segment lifetime in cache. The segment is deleted from the cache if the last access time is greater than this value (in milliseconds).\r\n     */\r\n    cachedSegmentExpiration: number;\r\n\r\n    /**\r\n     * Max number of segments that can be stored in the cache.\r\n     */\r\n    cachedSegmentsCount: number;\r\n\r\n    /**\r\n     * Enable/Disable peers interaction.\r\n     */\r\n    useP2P: boolean;\r\n\r\n    /**\r\n     * The peer will not upload segments data to the P2P network but still download from others.\r\n     */\r\n    consumeOnly: boolean;\r\n\r\n    /**\r\n     * The maximum priority of the segments to be downloaded (if not available) as quickly as possible (i.e. via HTTP method).\r\n     */\r\n    requiredSegmentsPriority: number;\r\n\r\n    /**\r\n     * Max number of simultaneous downloads from HTTP source.\r\n     */\r\n    simultaneousHttpDownloads: number;\r\n\r\n    /**\r\n     * Probability of downloading remaining not downloaded segment in the segments queue via HTTP.\r\n     */\r\n    httpDownloadProbability: number;\r\n\r\n    /**\r\n     * Interval of the httpDownloadProbability check (in milliseconds).\r\n     */\r\n    httpDownloadProbabilityInterval: number;\r\n\r\n    /**\r\n     * Don't download segments over HTTP randomly when there is no peers.\r\n     */\r\n    httpDownloadProbabilitySkipIfNoPeers: boolean;\r\n\r\n    /**\r\n     * Timeout before trying to load segment again via HTTP after failed attempt (in milliseconds).\r\n     */\r\n    httpFailedSegmentTimeout: number;\r\n\r\n    /**\r\n     * Segments with higher priority will not be downloaded over HTTP.\r\n     */\r\n    httpDownloadMaxPriority: number;\r\n\r\n    /**\r\n     * Try to download initial segments over P2P if the value is > 0.\r\n     * But HTTP download will be forcibly enabled if there is no peers on tracker or\r\n     * single sequential segment P2P download is timed out (see httpDownloadInitialTimeoutPerSegment).\r\n     */\r\n    httpDownloadInitialTimeout: number;\r\n\r\n    /**\r\n     * Use HTTP ranges requests where it is possible.\r\n     * Allows to continue (and not start over) aborted P2P downloads over HTTP.\r\n     */\r\n    httpUseRanges: boolean;\r\n\r\n    /**\r\n     * If initial HTTP download timeout is enabled (see httpDownloadInitialTimeout)\r\n     * this parameter sets additional timeout for a single sequential segment download\r\n     * over P2P. It will cancel initial HTTP download timeout mode if a segment download is timed out.\r\n     */\r\n    httpDownloadInitialTimeoutPerSegment: number;\r\n\r\n    /**\r\n     * Max number of simultaneous downloads from peers.\r\n     */\r\n    simultaneousP2PDownloads: number;\r\n\r\n    /**\r\n     * Segments with higher priority will not be downloaded over P2P.\r\n     */\r\n    p2pDownloadMaxPriority: number;\r\n\r\n    /**\r\n     * Timeout to download a segment from a peer. If exceeded the peer is dropped.\r\n     */\r\n    p2pSegmentDownloadTimeout: number;\r\n\r\n    /**\r\n     * Max WebRTC message size. 64KiB - 1B should work with most of recent browsers. Set it to 16KiB for older browsers support.\r\n     */\r\n    webRtcMaxMessageSize: number;\r\n\r\n    /**\r\n     * Torrent trackers (announcers) to use.\r\n     */\r\n    trackerAnnounce: string[];\r\n\r\n    /**\r\n     * Number of requested peers in each announce for each tracker. Maximum is 10.\r\n     */\r\n    peerRequestsPerAnnounce: number;\r\n\r\n    /**\r\n     * An RTCConfiguration dictionary providing options to configure WebRTC connections.\r\n     */\r\n    rtcConfig: RTCConfiguration;\r\n\r\n    /**\r\n     * Segment validation callback - validates the data after it has been downloaded.\r\n     */\r\n    segmentValidator?: SegmentValidatorCallback;\r\n\r\n    /**\r\n     * XMLHttpRequest setup callback. Handle it when you need additional setup for requests made by the library.\r\n     */\r\n    /* xhrSetup?: unknown; */\r\n\r\n    /**\r\n     * Allow to modify the segment URL before HTTP request.\r\n     */\r\n    segmentUrlBuilder?: SegmentUrlBuilder;\r\n\r\n    /**\r\n     * A storage for the downloaded segments.\r\n     * By default the segments are stored in JavaScript memory.\r\n     */\r\n    segmentsStorage?: SegmentsStorage;\r\n};\r\n","import { LoaderContext } from \"hls.js\"\r\n\r\nexport type ByteRange = { length: number; offset: number } | undefined;\r\n\r\nexport function getByteRange(context: LoaderContext): { offset: number, length: number } | undefined {\r\n  return context.rangeEnd && context.rangeStart !== undefined\r\n      ? { offset: context.rangeStart, length: context.rangeEnd - context.rangeStart }\r\n      : undefined;\r\n}\r\n\r\nexport function compareByteRanges(b1: ByteRange, b2: ByteRange): boolean {\r\n  return b1 === undefined ? b2 === undefined : b2 !== undefined && b1.length === b2.length && b1.offset === b2.offset;\r\n}\r\n\r\nexport function byteRangeToString(byteRange: ByteRange): string | undefined {\r\n  if (byteRange === undefined) {\r\n      return undefined;\r\n  }\r\n\r\n  const end = byteRange.offset + byteRange.length - 1;\r\n\r\n  return `bytes=${byteRange.offset}-${end}`;\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { Events, Segment, LoaderInterface } from \"../../p2p-media-loader-core/lib\";\r\nimport { Manifest, Parser } from \"m3u8-parser\";\r\nimport { ByteRange, byteRangeToString, compareByteRanges } from \"./byte-range\"\r\nimport { AssetsStorage, HlsJsEngineSettings } from \"./engine\";\r\n\r\nconst defaultSettings: SegmentManagerSettings = {\r\n    forwardSegmentCount: 20,\r\n    swarmId: undefined,\r\n    assetsStorage: undefined,\r\n};\r\n\r\nexport class SegmentManager {\r\n    public readonly loader: LoaderInterface;\r\n    private masterPlaylist: Playlist | null = null;\r\n    private readonly variantPlaylists = new Map<string, Playlist>();\r\n    private segmentRequest: SegmentRequest | null = null;\r\n    private readonly fetch: typeof fetch = (...args) => fetch(...args);\r\n    private playQueue: {\r\n        segmentSequence: number;\r\n        segmentUrl: string;\r\n        segmentByteRange: ByteRange;\r\n        playPosition?: {\r\n            start: number;\r\n            duration: number;\r\n        };\r\n    }[] = [];\r\n    private readonly settings: SegmentManagerSettings;\r\n\r\n    public constructor(loader: LoaderInterface, settings: Partial<HlsJsEngineSettings> = {}) {\r\n        this.settings = { ...defaultSettings, ...settings.segments };\r\n\r\n        this.loader = loader;\r\n        this.loader.on(Events.SegmentLoaded, this.onSegmentLoaded);\r\n        this.loader.on(Events.SegmentError, this.onSegmentError);\r\n        this.loader.on(Events.SegmentAbort, this.onSegmentAbort);\r\n\r\n        if (settings.loader && settings.loader.localTransport) {\r\n            this.fetch = settings.loader.localTransport;\r\n        }\r\n    }\r\n\r\n    public getSettings(): SegmentManagerSettings {\r\n        return this.settings;\r\n    }\r\n\r\n    public processPlaylist(requestUrl: string, content: string, responseUrl: string): void {\r\n        const parser = new Parser();\r\n        parser.push(content);\r\n        parser.end();\r\n\r\n        const playlist = new Playlist(requestUrl, responseUrl, parser.manifest);\r\n\r\n        if (playlist.manifest.playlists) {\r\n            this.masterPlaylist = playlist;\r\n\r\n            for (const [key, variantPlaylist] of this.variantPlaylists) {\r\n                const { streamSwarmId, found, index } = this.getStreamSwarmId(variantPlaylist.requestUrl);\r\n                if (!found) {\r\n                    this.variantPlaylists.delete(key);\r\n                } else {\r\n                    variantPlaylist.streamSwarmId = streamSwarmId;\r\n                    variantPlaylist.streamId = \"V\" + index.toString();\r\n                }\r\n            }\r\n        } else {\r\n            const { streamSwarmId, found, index } = this.getStreamSwarmId(requestUrl);\r\n\r\n            if (found || this.masterPlaylist === null) {\r\n                // do not add audio and subtitles to variants\r\n                playlist.streamSwarmId = streamSwarmId;\r\n                playlist.streamId = this.masterPlaylist === null ? undefined : \"V\" + index.toString();\r\n                this.variantPlaylists.set(requestUrl, playlist);\r\n                this.updateSegments();\r\n            }\r\n        }\r\n    }\r\n\r\n    public async loadPlaylist(url: string): Promise<{ response: string; responseURL: string }> {\r\n        const assetsStorage = this.settings.assetsStorage;\r\n        let res: { response: string; responseURL: string } | undefined;\r\n\r\n        if (assetsStorage !== undefined) {\r\n            let masterSwarmId: string | undefined;\r\n            masterSwarmId = this.getMasterSwarmId();\r\n            if (masterSwarmId === undefined) {\r\n                masterSwarmId = url.split(\"?\")[0];\r\n            }\r\n            const asset = await assetsStorage.getAsset(url, undefined, masterSwarmId);\r\n\r\n            if (asset !== undefined) {\r\n                res = {\r\n                    responseURL: asset.responseUri,\r\n                    response: asset.data as string,\r\n                };\r\n            } else {\r\n                const fetch = await this.loadContent(url);\r\n\r\n                res = {\r\n                    responseURL: fetch.url,\r\n                    response: await fetch.text(),\r\n                };\r\n\r\n                void assetsStorage.storeAsset({\r\n                    masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : url,\r\n                    masterSwarmId: masterSwarmId,\r\n                    requestUri: url,\r\n                    responseUri: res.responseURL,\r\n                    data: await res.response,\r\n                });\r\n            }\r\n        } else {\r\n            const fetch = await this.loadContent(url);\r\n\r\n            res = {\r\n                responseURL: fetch.url,\r\n                response: await fetch.text(),\r\n            };\r\n        }\r\n\r\n        this.processPlaylist(url, res.response, res.responseURL);\r\n        return res;\r\n    }\r\n\r\n    \r\n\r\n    public async loadSegment(\r\n        url: string,\r\n        byteRange: ByteRange\r\n    ): Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }> {\r\n        const segmentLocation = this.getSegmentLocation(url, byteRange);\r\n        const byteRangeString = byteRangeToString(byteRange);\r\n\r\n        if (!segmentLocation) {\r\n            let content: ArrayBuffer | undefined;\r\n\r\n            // Not a segment from variants; usually can be: init, audio or subtitles segment, encryption key etc.\r\n            const assetsStorage = this.settings.assetsStorage;\r\n            if (assetsStorage !== undefined) {\r\n                let masterManifestUri = this.masterPlaylist?.requestUrl;\r\n\r\n                let masterSwarmId: string | undefined;\r\n                masterSwarmId = this.getMasterSwarmId();\r\n\r\n                if (masterSwarmId === undefined && this.variantPlaylists.size === 1) {\r\n                    const result = this.variantPlaylists.values().next();\r\n                    if (!result.done) {\r\n                        // always true\r\n                        masterSwarmId = result.value.requestUrl.split(\"?\")[0];\r\n                    }\r\n                }\r\n\r\n                if (masterManifestUri === undefined && this.variantPlaylists.size === 1) {\r\n                    const result = this.variantPlaylists.values().next();\r\n                    if (!result.done) {\r\n                        // always true\r\n                        masterManifestUri = result.value.requestUrl;\r\n                    }\r\n                }\r\n\r\n                if (masterSwarmId !== undefined && masterManifestUri !== undefined) {\r\n                    const asset = await assetsStorage.getAsset(url, byteRangeString, masterSwarmId);\r\n                    if (asset !== undefined) {\r\n                        content = asset.data as ArrayBuffer;\r\n                    } else {\r\n                        const fetch = await this.loadContent(url, byteRangeString);\r\n                        content = await fetch.arrayBuffer();\r\n                        void assetsStorage.storeAsset({\r\n                            masterManifestUri: masterManifestUri,\r\n                            masterSwarmId: masterSwarmId,\r\n                            requestUri: url,\r\n                            requestRange: byteRangeString,\r\n                            responseUri: fetch.url,\r\n                            data: content,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (content === undefined) {\r\n                const fetch = await this.loadContent(url, byteRangeString);\r\n                content = await fetch.arrayBuffer();\r\n            }\r\n\r\n            return { content, downloadBandwidth: 0 };\r\n        }\r\n\r\n        const segmentSequence =\r\n            (segmentLocation.playlist.manifest.mediaSequence ? segmentLocation.playlist.manifest.mediaSequence : 0) +\r\n            segmentLocation.segmentIndex;\r\n\r\n        if (this.playQueue.length > 0) {\r\n            const previousSegment = this.playQueue[this.playQueue.length - 1];\r\n            if (previousSegment.segmentSequence !== segmentSequence - 1) {\r\n                // Reset play queue in case of segment loading out of sequence\r\n                this.playQueue = [];\r\n            }\r\n        }\r\n\r\n        if (this.segmentRequest) {\r\n            this.segmentRequest.onError(\"Cancel segment request: simultaneous segment requests are not supported\");\r\n        }\r\n\r\n        const promise = new Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }>(\r\n            (resolve, reject) => {\r\n\r\n                this.segmentRequest = new SegmentRequest(\r\n                    url,\r\n                    byteRange,\r\n                    segmentSequence,\r\n                    segmentLocation.playlist.requestUrl,\r\n                    (content: ArrayBuffer | undefined, downloadBandwidth?: number) =>\r\n                        resolve({ content, downloadBandwidth }),\r\n                    (error) => reject(error)\r\n                );\r\n                \r\n            }\r\n        );\r\n\r\n        this.playQueue.push({ segmentUrl: url, segmentByteRange: byteRange, segmentSequence: segmentSequence });\r\n        void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, true);\r\n\r\n        return promise;\r\n    }\r\n\r\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\r\n        const urlIndex = this.playQueue.findIndex(\r\n            (segment) => segment.segmentUrl === url && compareByteRanges(segment.segmentByteRange, byteRange)\r\n        );\r\n\r\n        if (urlIndex >= 0) {\r\n            this.playQueue = this.playQueue.slice(urlIndex);\r\n            this.playQueue[0].playPosition = { start, duration };\r\n            this.updateSegments();\r\n        }\r\n    }\r\n\r\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\r\n        if (this.playQueue.length === 0 || !this.playQueue[0].playPosition) {\r\n            return;\r\n        }\r\n\r\n        const currentSegmentPosition = this.playQueue[0].playPosition;\r\n        const segmentEndTime = currentSegmentPosition.start + currentSegmentPosition.duration;\r\n\r\n        if (segmentEndTime - playheadPosition < 0.2) {\r\n            // means that current segment is (almost) finished playing\r\n            // remove it from queue\r\n\r\n            this.playQueue = this.playQueue.slice(1);\r\n            this.updateSegments();\r\n        }\r\n    }\r\n\r\n    public abortSegment(url: string, byteRange: ByteRange): void {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === url &&\r\n            compareByteRanges(this.segmentRequest.segmentByteRange, byteRange)\r\n        ) {\r\n            this.segmentRequest.onSuccess(undefined, 0);\r\n            this.segmentRequest = null;\r\n        }\r\n    }\r\n\r\n    public async destroy(): Promise<void> {\r\n        if (this.segmentRequest) {\r\n            this.segmentRequest.onError(\"Loading aborted: object destroyed\");\r\n            this.segmentRequest = null;\r\n        }\r\n\r\n        this.masterPlaylist = null;\r\n        this.variantPlaylists.clear();\r\n        this.playQueue = [];\r\n\r\n        if (this.settings.assetsStorage !== undefined) {\r\n            await this.settings.assetsStorage.destroy();\r\n        }\r\n\r\n        await this.loader.destroy();\r\n    }\r\n\r\n    private updateSegments(): void {\r\n        if (!this.segmentRequest) {\r\n            return;\r\n        }\r\n\r\n        const segmentLocation = this.getSegmentLocation(\r\n            this.segmentRequest.segmentUrl,\r\n            this.segmentRequest.segmentByteRange\r\n        );\r\n        if (segmentLocation) {\r\n            void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, false);\r\n        }\r\n    }\r\n\r\n    private onSegmentLoaded = (segment: Segment) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            this.segmentRequest.onSuccess(segment.data!.slice(0), segment.downloadBandwidth);\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private onSegmentError = (segment: Segment, error: unknown) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            this.segmentRequest.onError(error);\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private onSegmentAbort = (segment: Segment) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            this.segmentRequest.onError(\"Loading aborted: internal abort\");\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private getSegmentLocation(\r\n        url: string,\r\n        byteRange: ByteRange\r\n    ): { playlist: Playlist; segmentIndex: number } | undefined {\r\n        for (const playlist of this.variantPlaylists.values()) {\r\n            const segmentIndex = playlist.getSegmentIndex(url, byteRange);\r\n            if (segmentIndex >= 0) {\r\n                return { playlist: playlist, segmentIndex: segmentIndex };\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    private async loadSegments(playlist: Playlist, segmentIndex: number, requestFirstSegment: boolean) {\r\n        const segments: Segment[] = [];\r\n        const playlistSegments = playlist.manifest.segments;\r\n        const initialSequence = playlist.manifest.mediaSequence ?? 0;\r\n        let loadSegmentId: string | null = null;\r\n\r\n        let priority = Math.max(0, this.playQueue.length - 1);\r\n\r\n        const masterSwarmId = this.getMasterSwarmId();\r\n\r\n        for (\r\n            let i = segmentIndex;\r\n            i < playlistSegments.length && segments.length < this.settings.forwardSegmentCount;\r\n            ++i\r\n        ) {\r\n            const segment = playlist.manifest.segments[i];\r\n\r\n            const url = playlist.getSegmentAbsoluteUrl(segment.uri);\r\n            const byteRange: ByteRange = segment.byterange;\r\n            const id = this.getSegmentId(playlist, initialSequence + i);\r\n\r\n            segments.push({\r\n                id: id,\r\n                url: url,\r\n                masterSwarmId: masterSwarmId !== undefined ? masterSwarmId : playlist.streamSwarmId,\r\n                masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : playlist.requestUrl,\r\n                streamId: playlist.streamId,\r\n                sequence: (initialSequence + i).toString(),\r\n                range: byteRangeToString(byteRange),\r\n                priority: priority++,\r\n            });\r\n            if (requestFirstSegment && !loadSegmentId) {\r\n                loadSegmentId = id;\r\n            }\r\n        }\r\n\r\n        this.loader.load(segments, playlist.streamSwarmId);\r\n\r\n        if (loadSegmentId) {\r\n            const segment = await this.loader.getSegment(loadSegmentId);\r\n\r\n\r\n\r\n            if (segment) {\r\n                // Segment already loaded by loader\r\n                this.onSegmentLoaded(segment);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getSegmentId(playlist: Playlist, segmentSequence: number): string {\r\n        return `${playlist.streamSwarmId}+${segmentSequence}`;\r\n    }\r\n\r\n    private getMasterSwarmId() {\r\n        const settingsSwarmId =\r\n            this.settings.swarmId && this.settings.swarmId.length !== 0 ? this.settings.swarmId : undefined;\r\n        if (settingsSwarmId !== undefined) {\r\n            return settingsSwarmId;\r\n        }\r\n\r\n        return this.masterPlaylist !== null ? this.masterPlaylist.requestUrl.split(\"?\")[0] : undefined;\r\n    }\r\n\r\n    private getStreamSwarmId(playlistUrl: string): { streamSwarmId: string; found: boolean; index: number } {\r\n        const masterSwarmId = this.getMasterSwarmId();\r\n\r\n        if (this.masterPlaylist && this.masterPlaylist.manifest.playlists && masterSwarmId) {\r\n            for (let i = 0; i < this.masterPlaylist.manifest.playlists.length; ++i) {\r\n                const url = new URL(\r\n                    this.masterPlaylist.manifest.playlists[i].uri,\r\n                    this.masterPlaylist.responseUrl\r\n                ).toString();\r\n                if (url === playlistUrl) {\r\n                    return { streamSwarmId: `${masterSwarmId}+V${i}`, found: true, index: i };\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            streamSwarmId: masterSwarmId ?? playlistUrl.split(\"?\")[0],\r\n            found: false,\r\n            index: -1,\r\n        };\r\n    }\r\n\r\n    private async loadContent(\r\n        url: string,\r\n        range?: string\r\n    ): Promise<Response> {\r\n        const headers = new Headers();\r\n\r\n        if (range) {\r\n            headers.append('Range', range);\r\n        }\r\n\r\n        const fetchPromise = this.fetch(url, { headers });\r\n\r\n        fetchPromise.catch((err) => {\r\n            /**\r\n             * Handling all fetch errors here\r\n             */\r\n\r\n            // console.log(\"SegmentManager fetch error\", { err });\r\n        });\r\n\r\n        return fetchPromise;\r\n    }\r\n}\r\n\r\nclass Playlist {\r\n    public streamSwarmId = \"\";\r\n    public streamId?: string;\r\n\r\n    public constructor(readonly requestUrl: string, readonly responseUrl: string, readonly manifest: Manifest) {}\r\n\r\n    public getSegmentIndex(url: string, byteRange: ByteRange): number {\r\n        for (let i = 0; i < this.manifest.segments.length; ++i) {\r\n            const segment = this.manifest.segments[i];\r\n            const segmentUrl = this.getSegmentAbsoluteUrl(segment.uri);\r\n\r\n            if (url === segmentUrl && compareByteRanges(segment.byterange, byteRange)) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    public getSegmentAbsoluteUrl(segmentUrl: string): string {\r\n        return new URL(segmentUrl, this.responseUrl).toString();\r\n    }\r\n}\r\n\r\nclass SegmentRequest {\r\n    public constructor(\r\n        readonly segmentUrl: string,\r\n        readonly segmentByteRange: ByteRange,\r\n        readonly segmentSequence: number,\r\n        readonly playlistRequestUrl: string,\r\n        readonly onSuccess: (content: ArrayBuffer | undefined, downloadBandwidth: number | undefined) => void,\r\n        readonly onError: (error: unknown) => void\r\n    ) {}\r\n}\r\n\r\nexport interface SegmentManagerSettings {\r\n    /**\r\n     * Number of segments for building up predicted forward segments sequence; used to predownload and share via P2P\r\n     */\r\n    forwardSegmentCount: number;\r\n\r\n    /**\r\n     * Override default swarm ID that is used to identify unique media stream with trackers (manifest URL without\r\n     * query parameters is used as the swarm ID if the parameter is not specified)\r\n     */\r\n    swarmId?: string;\r\n\r\n    /**\r\n     * A storage for the downloaded assets: manifests, subtitles, init segments, DRM assets etc. By default the assets are not stored.\r\n     */\r\n    assetsStorage?: AssetsStorage;\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { SegmentManager } from \"./segment-manager\";\r\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\r\nimport { Events, Segment } from \"../../p2p-media-loader-core/lib\";\r\nimport { byteRangeToString, getByteRange } from \"./byte-range\"\r\n\r\nexport class HlsJsLoader {\r\n    private isLoaded = false;\r\n    private segmentManager: SegmentManager;\r\n    public stats: LoaderStats = {\r\n        loaded: 0,\r\n        total: 0,\r\n        aborted: false,\r\n        retry: 0,\r\n        chunkCount: 0,\r\n        bwEstimate: 0,\r\n        loading: {\r\n            start: 0,\r\n            end: 0,\r\n            first: 0,\r\n        },\r\n        parsing: {\r\n            start: 0,\r\n            end: 0,\r\n        },\r\n        buffering: {\r\n            start: 0,\r\n            end: 0,\r\n            first: 0,\r\n        },\r\n    };\r\n\r\n    public constructor(segmentManager: SegmentManager) {\r\n        this.segmentManager = segmentManager;\r\n    }\r\n\r\n    public async load(\r\n        context: LoaderContext,\r\n        _config: LoaderConfiguration,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): Promise<void> {\r\n        HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n\r\n        if (((context as unknown) as { type: unknown }).type) {\r\n            try {\r\n                const result = await this.segmentManager.loadPlaylist(context.url);\r\n                this.isLoaded = true;\r\n                this.successPlaylist(result, context, callbacks);\r\n            } catch (e : any) {\r\n                this.error(e, context, callbacks);\r\n            }\r\n        } else if (((context as unknown) as { frag: unknown }).frag) {\r\n            const { loader } = this.segmentManager;\r\n            const byteRange = getByteRange(context)\r\n\r\n            const isSegment = (segment: Segment) => {\r\n                return segment.url === context.url && segment.range === byteRangeToString(byteRange)\r\n            }\r\n\r\n            // We may be downloading the segment by P2P, so we don't care about the stats sent to HLS ABR\r\n            let updateStart: any = setInterval(() => {\r\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n            }, 200)\r\n\r\n            const onUpdateSegmentSize = (segment: Segment, size: number) => {\r\n                if (!isSegment(segment)) return\r\n\r\n                this.stats.total = size\r\n            };\r\n            loader.on(Events.SegmentSize, onUpdateSegmentSize)\r\n\r\n            const onUpdateLoaded = (_type: unknown, segment: Segment, bytes: number) => {\r\n                if (!isSegment(segment)) return\r\n\r\n                this.stats.loaded += bytes\r\n            };\r\n\r\n            const onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\r\n                if (!updateStart || method !== \"http\" || !isSegment(segment)) return\r\n\r\n                clearInterval(updateStart)\r\n                updateStart = undefined\r\n\r\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n\r\n                loader.on(Events.PieceBytesDownloaded, onUpdateLoaded)\r\n            };\r\n\r\n            loader.on(Events.SegmentStartLoad, onSegmentStartLoad)\r\n\r\n\r\n            try {\r\n                const result = await this.segmentManager.loadSegment(context.url, byteRange);\r\n                const { content } = result;\r\n                if (content) {\r\n                    this.isLoaded = true;\r\n                    setTimeout(() => this.successSegment(content, context, callbacks), 0);\r\n                }\r\n\r\n            } catch (e : any) {\r\n                setTimeout(() => this.error(e, context, callbacks), 0);\r\n            } finally {\r\n\r\n                clearInterval(updateStart)\r\n                loader.off(Events.SegmentStartLoad, onSegmentStartLoad)\r\n                loader.off(Events.SegmentSize, onUpdateSegmentSize)\r\n                loader.off(Events.PieceBytesDownloaded, onUpdateLoaded)\r\n            }\r\n\r\n\r\n\r\n\r\n        } else {\r\n            console.warn(\"Unknown load request\", context);\r\n        }\r\n    }\r\n\r\n    public abort(context: LoaderContext, callbacks?: LoaderCallbacks<LoaderContext>): void {\r\n        if (this.isLoaded) return;\r\n\r\n        this.segmentManager.abortSegment(context.url, getByteRange(context));\r\n        this.stats.aborted = true;\r\n\r\n        const onAbort = callbacks?.onAbort;\r\n        if (onAbort) {\r\n            onAbort(this.stats, context, undefined);\r\n        }\r\n    }\r\n\r\n    private successPlaylist(\r\n        xhr: { response: string; responseURL: string },\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        const now = performance.now();\r\n\r\n        this.stats.loading.end = now;\r\n        this.stats.loaded = xhr.response.length;\r\n        this.stats.total = xhr.response.length;\r\n\r\n        callbacks.onSuccess(\r\n            {\r\n                url: xhr.responseURL,\r\n                data: xhr.response,\r\n            },\r\n            this.stats,\r\n            context,\r\n            undefined\r\n        );\r\n    }\r\n\r\n    private successSegment(\r\n        content: ArrayBuffer,\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        const now = performance.now();\r\n\r\n        this.stats.loading.end = now;\r\n        this.stats.loaded = content.byteLength;\r\n        this.stats.total = content.byteLength;\r\n\r\n        if (callbacks.onProgress) {\r\n            callbacks.onProgress(this.stats, context, content, undefined);\r\n        }\r\n\r\n        callbacks.onSuccess(\r\n            {\r\n                url: context.url,\r\n                data: content,\r\n            },\r\n            this.stats,\r\n            context,\r\n            undefined\r\n        );\r\n    }\r\n\r\n    private error(\r\n        error: { code: number; text: string },\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        callbacks.onError(error, context, undefined);\r\n    }\r\n\r\n    private static updateStatsToStartLoading (stats: LoaderStats) {\r\n        const start = performance.now();\r\n        stats.loading.start = start;\r\n        stats.loading.first = start;\r\n    }\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { EventEmitter } from \"events\";\r\nimport { Events, LoaderInterface, HybridLoader, HybridLoaderSettings } from \"../../p2p-media-loader-core/lib\";\r\nimport { SegmentManager, SegmentManagerSettings } from \"./segment-manager\";\r\nimport { HlsJsLoader } from \"./hlsjs-loader\";\r\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\r\nimport { ByteRange } from \"./byte-range\"\r\n\r\nexport interface HlsJsEngineSettings {\r\n    loader: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }>;\r\n    segments: Partial<SegmentManagerSettings>;\r\n}\r\n\r\nexport class Engine extends EventEmitter {\r\n    public static isSupported(): boolean {\r\n        return HybridLoader.isSupported();\r\n    }\r\n\r\n    private readonly loader: LoaderInterface;\r\n    private readonly segmentManager: SegmentManager;\r\n\r\n    public constructor(settings: Partial<HlsJsEngineSettings> = {}) {\r\n        super();\r\n\r\n        this.loader = new HybridLoader(settings.loader);\r\n        this.segmentManager = new SegmentManager(this.loader, settings);\r\n\r\n        Object.keys(Events)\r\n            .map((eventKey) => Events[eventKey as keyof typeof Events])\r\n            .forEach((event) => this.loader.on(event, (...args: any[]) => this.emit(event, ...args)));\r\n    }\r\n\r\n    public createLoaderClass(): new () => unknown {\r\n        const engine = this; // eslint-disable-line @typescript-eslint/no-this-alias\r\n        return class {\r\n            private impl: HlsJsLoader;\r\n            private context?: LoaderContext;\r\n            private callbacks?: LoaderCallbacks<LoaderContext>;\r\n            public stats: LoaderStats;\r\n\r\n            constructor() {\r\n                this.impl = new HlsJsLoader(engine.segmentManager);\r\n                this.stats = this.impl.stats;\r\n            }\r\n\r\n            load = async (\r\n                context: LoaderContext,\r\n                config: LoaderConfiguration,\r\n                callbacks: LoaderCallbacks<LoaderContext>\r\n            ) => {\r\n                this.context = context;\r\n                this.callbacks = callbacks;\r\n                this.impl.load(context, config, callbacks);\r\n\r\n            };\r\n\r\n            abort = () => {\r\n                if (this.context) {\r\n                    this.impl.abort(this.context, this.callbacks);\r\n                }\r\n            };\r\n\r\n            destroy = () => {\r\n                if (this.context) {\r\n                    this.impl.abort(this.context);\r\n                }\r\n            };\r\n\r\n            getResponseHeader = () => undefined;\r\n\r\n            static getEngine = () => {\r\n                return engine;\r\n            };\r\n        };\r\n    }\r\n\r\n    public async destroy(): Promise<void> {\r\n        await this.segmentManager.destroy();\r\n    }\r\n\r\n    public getSettings(): {\r\n        segments: SegmentManagerSettings;\r\n        loader: unknown;\r\n    } {\r\n        return {\r\n            segments: this.segmentManager.getSettings(),\r\n            loader: this.loader.getSettings(),\r\n        };\r\n    }\r\n\r\n    public getDetails(): unknown {\r\n        return {\r\n            loader: this.loader.getDetails(),\r\n        };\r\n    }\r\n\r\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\r\n        this.segmentManager.setPlayingSegment(url, byteRange, start, duration);\r\n    }\r\n\r\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\r\n        this.segmentManager.setPlayingSegmentByCurrentTime(playheadPosition);\r\n    }\r\n\r\n}\r\n\r\nexport interface Asset {\r\n    masterSwarmId: string;\r\n    masterManifestUri: string;\r\n    requestUri: string;\r\n    requestRange?: string;\r\n    responseUri: string;\r\n    data: ArrayBuffer | string;\r\n}\r\n\r\nexport interface AssetsStorage {\r\n    storeAsset(asset: Asset): Promise<void>;\r\n    getAsset(requestUri: string, requestRange: string | undefined, masterSwarmId: string): Promise<Asset | undefined>;\r\n    destroy(): Promise<void>;\r\n}\r\n","/**\r\n * @license Apache-2.0\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/* eslint-disable */\r\n\r\nexport const version = \"0.6.2\";\r\nexport * from \"./engine\";\r\nexport * from \"./segment-manager\";\r\n\r\nimport { Engine } from \"./engine\";\r\n\r\ndeclare const videojs: any;\r\n\r\ndeclare global {\r\n    interface Window {\r\n        p2pml: Record<string, unknown>;\r\n    }\r\n}\r\n\r\nexport function initHlsJsPlayer(player: any): void {\r\n    if (player && player.config && player.config.loader && typeof player.config.loader.getEngine === \"function\") {\r\n        initHlsJsEvents(player, player.config.loader.getEngine());\r\n    }\r\n}\r\n\r\nexport function initClapprPlayer(player: any): void {\r\n    player.on(\"play\", () => {\r\n        const playback = player.core.getCurrentPlayback();\r\n        if (playback._hls && !playback._hls._p2pm_linitialized) {\r\n            playback._hls._p2pm_linitialized = true;\r\n            initHlsJsPlayer(player.core.getCurrentPlayback()._hls);\r\n        }\r\n    });\r\n}\r\n\r\nexport function initFlowplayerHlsJsPlayer(player: any): void {\r\n    player.on(\"ready\", () => initHlsJsPlayer(player.engine.hlsjs ?? player.engine.hls));\r\n}\r\n\r\nexport function initVideoJsContribHlsJsPlayer(player: any): void {\r\n    player.ready(() => {\r\n        const options = player.tech_.options_;\r\n        if (\r\n            options &&\r\n            options.hlsjsConfig &&\r\n            options.hlsjsConfig.loader &&\r\n            typeof options.hlsjsConfig.loader.getEngine === \"function\"\r\n        ) {\r\n            initHlsJsEvents(player.tech_, options.hlsjsConfig.loader.getEngine());\r\n        }\r\n    });\r\n}\r\n\r\nexport function initVideoJsHlsJsPlugin(): void {\r\n    if (videojs == undefined || videojs.Html5Hlsjs == undefined) {\r\n        return;\r\n    }\r\n\r\n    videojs.Html5Hlsjs.addHook(\"beforeinitialize\", (videojsPlayer: any, hlsjs: any) => {\r\n        if (hlsjs.config && hlsjs.config.loader && typeof hlsjs.config.loader.getEngine === \"function\") {\r\n            initHlsJsEvents(hlsjs, hlsjs.config.loader.getEngine());\r\n        }\r\n    });\r\n}\r\n\r\nexport function initMediaElementJsPlayer(mediaElement: any): void {\r\n\r\n\r\n    mediaElement.addEventListener(\"hlsFragChanged\", (event: any) => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            const engine: Engine = hls.config.loader.getEngine();\r\n\r\n            if (event.data && event.data.length > 1) {\r\n                const frag = event.data[1].frag;\r\n                const byteRange =\r\n                    frag.byteRange.length !== 2\r\n                        ? undefined\r\n                        : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\r\n                engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\r\n            }\r\n        }\r\n    });\r\n    mediaElement.addEventListener(\"hlsDestroying\", async () => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            const engine: Engine = hls.config.loader.getEngine();\r\n            await engine.destroy();\r\n        }\r\n    });\r\n    mediaElement.addEventListener(\"hlsError\", (event: any) => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            if (event.data !== undefined && event.data.details === \"bufferStalledError\") {\r\n                const engine: Engine = hls.config.loader.getEngine();\r\n                engine.setPlayingSegmentByCurrentTime(hls.media.currentTime);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function initJwPlayer(player: any, hlsjsConfig: any): void {\r\n    const iid = setInterval(() => {\r\n        if (player.hls && player.hls.config) {\r\n            clearInterval(iid);\r\n            Object.assign(player.hls.config, hlsjsConfig);\r\n            initHlsJsPlayer(player.hls);\r\n        }\r\n    }, 200);\r\n}\r\n\r\nfunction initHlsJsEvents(player: any, engine: Engine): void {\r\n    player.on(\"hlsFragChanged\", (_event: string, data: any) => {\r\n        const frag = data.frag;\r\n        const byteRange =\r\n            frag.byteRange.length !== 2\r\n                ? undefined\r\n                : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\r\n        engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\r\n    });\r\n    player.on(\"hlsDestroying\", async () => {\r\n        await engine.destroy();\r\n    });\r\n    player.on(\"hlsError\", (_event: string, errorData: { details: string }) => {\r\n        if (errorData.details === \"bufferStalledError\") {\r\n            const htmlMediaElement = (player.media === undefined\r\n                ? player.el_ // videojs-contrib-hlsjs\r\n                : player.media) as HTMLMediaElement | undefined; // all others\r\n            if (htmlMediaElement) {\r\n                engine.setPlayingSegmentByCurrentTime(htmlMediaElement.currentTime);\r\n            }\r\n        }\r\n    });\r\n}\r\n"],"names":["Events","STEEmitter","on","event","listener","emit","args","EventEmitter","HttpMediaManager","settings","fetchRequests","Map","failedSegments","debug","Debug","fetch","download","segment","downloadedPieces","isDownloading","cleanTimedOutFailedSegments","segmentUrl","buildSegmentUrl","fetchAbort","AbortController","set","id","initialPriority","priority","requestUrl","headers","Headers","range","append","undefined","httpUseRanges","bytesDownloaded","piece","byteLength","signal","fetchRequest","setupFetchEvents","catch","err","name","message","fetchError","Error","segmentFailure","url","netError","request","updatePriority","get","requiredSegmentsPriority","abort","delete","has","isFailed","time","now","getActiveDownloads","getActiveDownloadsCount","size","destroy","forEach","clear","__awaiter","fetchResponse","dataReader","body","getReader","contentLengthStr","contentLength","Number","parseFloat","dataBytes","Uint8Array","read","nextChunkPos","Array","isArray","status","pieceBytes","done","chunkBytes","value","length","this","segmentDownloadFinished","buffer","data","responseUrl","segmentValidator","Object","error","httpFailedSegmentTimeout","candidates","push","performance","localTransport","segmentUrlBuilder","FilteredEmitter","MediaPeerCommands","MediaPeerSegmentStatus","DownloadingSegment","pieces","MediaPeer","peer","remoteAddress","downloadingSegmentId","downloadingSegment","segmentsMap","timer","onPeerConnect","onPeerClose","terminateSegmentRequest","onPeerError","receiveSegmentPiece","segmentId","segmentData","offset","getJsonCommand","bytes","JSON","parse","TextDecoder","decode","onPeerData","command","c","SegmentsMap","createSegmentsMap","m","SegmentRequest","i","SegmentData","s","cancelResponseTimeoutTimer","SegmentAbsent","CancelSegmentRequest","segments","streamSwarmId","keys","swarmData","segmentsIds","split","segmentsStatuses","segmentStatus","sendCommand","write","stringify","getDownloadingSegmentId","getSegmentsMap","sendSegmentsMap","sendSegmentData","bytesLeft","bytesToSend","webRtcMaxMessageSize","Buffer","sendSegmentAbsent","requestSegment","runResponseTimeoutTimer","cancelSegmentRequest","setTimeout","p2pSegmentDownloadTimeout","clearTimeout","PEER_ID_VERSION_PREFIX","replace","v","parseInt","slice","PeerSegmentRequest","peerId","P2PMediaManager","segmentsStorage","trackerClient","peers","peerCandidates","peerSegmentRequests","pendingTrackerClient","getPeers","getPeerId","toString","setStreamSwarmId","masterSwarmId","isDestroyed","infoHash","sha1","update","digest","createClient","useP2P","clientOptions","announce","trackerAnnounce","rtcConfig","port","getAnnounceOpts","numwant","peerRequestsPerAnnounce","oldTrackerClient","Client","onTrackerError","onTrackerWarning","onTrackerUpdate","onTrackerPeer","start","warning","trackerPeer","onPeerDataUpdated","onSegmentRequest","onSegmentLoaded","onSegmentAbsent","onSegmentError","onSegmentSize","onSegmentStartLoad","onSegmentTimeout","onPieceBytesDownloaded","onPieceBytesUploaded","peerCandidatesById","values","Loaded","Math","floor","random","peerSegmentRequest","swarmChange","stop","removeAllListeners","peerCandidateById","peerCandidate","sendSegmentsMapToAll","getOverallSegmentsMap","overallSegmentsMap","LoadingByHttp","index","indexOf","splice","key","getSegment","description","PEER_ID_SYMBOLS","charAt","TextEncoder","encode","generatePeerId","ArrayBuffer","enabled","SMOOTH_INTERVAL","NumberWithTime","timeStamp","BandwidthApproximator","lastBytes","currentBytesSum","lastBandwidth","addBytes","shift","interval","min","getBandwidth","maxBandwidth","bandwidth","getSmoothInterval","getMeasureInterval","SegmentsMemoryStorage","cache","storeSegment","lastAccessed","cacheItem","hasSegment","clean","lockedSegmentsFilter","segmentsToDelete","remainingSegments","cachedSegment","cachedSegmentExpiration","countOverhead","cachedSegmentsCount","sort","a","b","defaultSettings","consumeOnly","simultaneousHttpDownloads","httpDownloadProbability","httpDownloadProbabilityInterval","httpDownloadProbabilitySkipIfNoPeers","httpDownloadMaxPriority","httpDownloadInitialTimeout","httpDownloadInitialTimeoutPerSegment","simultaneousP2PDownloads","p2pDownloadMaxPriority","Peer","HybridLoader","debugSegments","segmentsQueue","bandwidthApproximator","httpDownloadInitialTimeoutTimestamp","Infinity","createHttpManager","createP2PManager","load","httpRandomDownloadInterval","setInterval","downloadRandomSegmentOverHttp","processInitialSegmentTimeout","p2pManager","updateSegmentsMap","find","f","httpManager","SegmentAbort","storageSegments","processSegmentsQueue","cleanSegmentsStorage","getSettings","getDetails","getBandwidthEstimate","clearInterval","httpAllowed","firstNotDownloadePriority","httpTimeout","segmentToAbort","pendingQueue","filter","method","SegmentStartLoad","PieceBytesDownloaded","PieceBytesUploaded","downloadBandwidth","SegmentLoaded","details","SegmentError","SegmentSize","getStreamSwarmId","streamId","addSegmentToMap","sequence","segmentsIdsAndStatuses","storageSegment","PeerConnect","PeerClose","incomplete","queueSegment","bufferedSegmentsCount","window","RTCPeerConnection","prototype","createDataChannel","getByteRange","context","rangeEnd","rangeStart","compareByteRanges","b1","b2","byteRangeToString","byteRange","end","forwardSegmentCount","swarmId","assetsStorage","SegmentManager","loader","masterPlaylist","variantPlaylists","segmentRequest","playQueue","segmentByteRange","onSuccess","onError","onSegmentAbort","content","parser","Parser","playlist","Playlist","manifest","playlists","variantPlaylist","found","updateSegments","res","getMasterSwarmId","asset","getAsset","responseURL","responseUri","response","loadContent","text","storeAsset","masterManifestUri","requestUri","processPlaylist","segmentLocation","getSegmentLocation","byteRangeString","_a","result","next","arrayBuffer","requestRange","segmentSequence","mediaSequence","segmentIndex","promise","Promise","resolve","reject","loadSegments","duration","urlIndex","findIndex","playPosition","playheadPosition","currentSegmentPosition","getSegmentIndex","requestFirstSegment","playlistSegments","initialSequence","loadSegmentId","max","getSegmentAbsoluteUrl","uri","byterange","getSegmentId","settingsSwarmId","playlistUrl","URL","fetchPromise","playlistRequestUrl","HlsJsLoader","segmentManager","isLoaded","stats","loaded","total","aborted","retry","chunkCount","bwEstimate","loading","first","parsing","buffering","_config","callbacks","updateStatsToStartLoading","type","loadPlaylist","successPlaylist","e","frag","isSegment","updateStart","onUpdateSegmentSize","onUpdateLoaded","_type","loadSegment","successSegment","off","console","warn","abortSegment","onAbort","xhr","onProgress","Engine","map","eventKey","engine","config","impl","getResponseHeader","setPlayingSegment","setPlayingSegmentByCurrentTime","version","initHlsJsPlayer","player","getEngine","initHlsJsEvents","initClapprPlayer","playback","core","getCurrentPlayback","_hls","_p2pm_linitialized","initFlowplayerHlsJsPlayer","hlsjs","hls","initVideoJsContribHlsJsPlayer","ready","options","tech_","options_","hlsjsConfig","initVideoJsHlsJsPlugin","videojs","Html5Hlsjs","addHook","videojsPlayer","initMediaElementJsPlayer","mediaElement","addEventListener","hlsPlayer","media","currentTime","initJwPlayer","iid","assign","_event","errorData","htmlMediaElement","el_"],"sourceRoot":""}