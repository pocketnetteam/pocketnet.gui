{"version":3,"file":"555.chunk.js?v=1878","mappings":"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","sources":["webpack://peertube-client/./src/assets/player/shared/webtorrent/peertube-chunk-store.ts","webpack://peertube-client/./src/assets/player/shared/webtorrent/video-renderer.ts","webpack://peertube-client/./src/assets/player/shared/webtorrent/webtorrent-plugin.ts","webpack://peertube-client/./src/shims/http.ts","webpack://peertube-client/./src/shims/https.ts","webpack://peertube-client/./src/shims/noop.ts","webpack://peertube-client/./src/shims/stream.ts"],"sourcesContent":["// From https://github.com/MinEduTDF/idb-chunk-store\r\n// We use temporary IndexDB (all data are removed on destroy) to avoid RAM issues\r\n// Thanks @santiagogil and @Feross\r\n\r\nimport Dexie from 'dexie'\r\nimport { EventEmitter } from 'events'\r\nimport { logger } from '@root-helpers/logger'\r\n\r\nclass ChunkDatabase extends Dexie {\r\n  chunks: Dexie.Table<{ id: number, buf: Buffer }, number>\r\n\r\n  constructor (dbname: string) {\r\n    super(dbname)\r\n\r\n    this.version(1).stores({\r\n      chunks: 'id'\r\n    })\r\n  }\r\n}\r\n\r\nclass ExpirationDatabase extends Dexie {\r\n  databases: Dexie.Table<{ name: string, expiration: number }, number>\r\n\r\n  constructor () {\r\n    super('webtorrent-expiration')\r\n\r\n    this.version(1).stores({\r\n      databases: 'name,expiration'\r\n    })\r\n  }\r\n}\r\n\r\nexport class PeertubeChunkStore extends EventEmitter {\r\n  private static readonly BUFFERING_PUT_MS = 1000\r\n  private static readonly CLEANER_INTERVAL_MS = 1000 * 60 // 1 minute\r\n  private static readonly CLEANER_EXPIRATION_MS = 1000 * 60 * 5 // 5 minutes\r\n\r\n  chunkLength: number\r\n\r\n  private pendingPut: { id: number, buf: Buffer, cb: (err?: Error) => void }[] = []\r\n  // If the store is full\r\n  private memoryChunks: { [ id: number ]: Buffer | true } = {}\r\n  private databaseName: string\r\n  private putBulkTimeout: any\r\n  private cleanerInterval: any\r\n  private db: ChunkDatabase\r\n  private expirationDB: ExpirationDatabase\r\n  private readonly length: number\r\n  private readonly lastChunkLength: number\r\n  private readonly lastChunkIndex: number\r\n\r\n  constructor (chunkLength: number, opts: any) {\r\n    super()\r\n\r\n    this.databaseName = 'webtorrent-chunks-'\r\n\r\n    if (!opts) opts = {}\r\n    if (opts.torrent?.infoHash) this.databaseName += opts.torrent.infoHash\r\n    else this.databaseName += '-default'\r\n\r\n    this.setMaxListeners(100)\r\n\r\n    this.chunkLength = Number(chunkLength)\r\n    if (!this.chunkLength) throw new Error('First argument must be a chunk length')\r\n\r\n    this.length = Number(opts.length) || Infinity\r\n\r\n    if (this.length !== Infinity) {\r\n      this.lastChunkLength = (this.length % this.chunkLength) || this.chunkLength\r\n      this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1\r\n    }\r\n\r\n    this.db = new ChunkDatabase(this.databaseName)\r\n    // Track databases that expired\r\n    this.expirationDB = new ExpirationDatabase()\r\n\r\n    this.runCleaner()\r\n  }\r\n\r\n  put (index: number, buf: Buffer, cb: (err?: Error) => void) {\r\n    const isLastChunk = (index === this.lastChunkIndex)\r\n    if (isLastChunk && buf.length !== this.lastChunkLength) {\r\n      return this.nextTick(cb, new Error('Last chunk length must be ' + this.lastChunkLength))\r\n    }\r\n    if (!isLastChunk && buf.length !== this.chunkLength) {\r\n      return this.nextTick(cb, new Error('Chunk length must be ' + this.chunkLength))\r\n    }\r\n\r\n    // Specify we have this chunk\r\n    this.memoryChunks[index] = true\r\n\r\n    // Add it to the pending put\r\n    this.pendingPut.push({ id: index, buf, cb })\r\n    // If it's already planned, return\r\n    if (this.putBulkTimeout) return\r\n\r\n    // Plan a future bulk insert\r\n    this.putBulkTimeout = setTimeout(async () => {\r\n      const processing = this.pendingPut\r\n      this.pendingPut = []\r\n      this.putBulkTimeout = undefined\r\n\r\n      try {\r\n        await this.db.transaction('rw', this.db.chunks, () => {\r\n          return this.db.chunks.bulkPut(processing.map(p => ({ id: p.id, buf: p.buf })))\r\n        })\r\n      } catch (err) {\r\n        logger.info('Cannot bulk insert chunks. Store them in memory.', err)\r\n\r\n        processing.forEach(p => {\r\n          this.memoryChunks[p.id] = p.buf\r\n        })\r\n      } finally {\r\n        processing.forEach(p => p.cb())\r\n      }\r\n    }, PeertubeChunkStore.BUFFERING_PUT_MS)\r\n  }\r\n\r\n  get (index: number, opts: any, cb: (err?: Error, buf?: Buffer) => void): void {\r\n    if (typeof opts === 'function') return this.get(index, null, opts)\r\n\r\n    // IndexDB could be slow, use our memory index first\r\n    const memoryChunk = this.memoryChunks[index]\r\n    if (memoryChunk === undefined) {\r\n      const err = new Error('Chunk not found') as any\r\n      err['notFound'] = true\r\n\r\n      return process.nextTick(() => cb(err))\r\n    }\r\n\r\n    // Chunk in memory\r\n    if (memoryChunk !== true) return cb(null, memoryChunk)\r\n\r\n    // Chunk in store\r\n    this.db.transaction('r', this.db.chunks, async () => {\r\n      const result = await this.db.chunks.get({ id: index })\r\n      if (result === undefined) return cb(null, Buffer.alloc(0))\r\n\r\n      const buf = result.buf\r\n      if (!opts) return this.nextTick(cb, null, buf)\r\n\r\n      const offset = opts.offset || 0\r\n      const len = opts.length || (buf.length - offset)\r\n      return cb(null, buf.slice(offset, len + offset))\r\n    })\r\n    .catch(err => {\r\n      logger.error(err)\r\n      return cb(err)\r\n    })\r\n  }\r\n\r\n  close (cb: (err?: Error) => void) {\r\n    return this.destroy(cb)\r\n  }\r\n\r\n  async destroy (cb: (err?: Error) => void) {\r\n    try {\r\n      if (this.pendingPut) {\r\n        clearTimeout(this.putBulkTimeout)\r\n        this.pendingPut = null\r\n      }\r\n      if (this.cleanerInterval) {\r\n        clearInterval(this.cleanerInterval)\r\n        this.cleanerInterval = null\r\n      }\r\n\r\n      if (this.db) {\r\n        this.db.close()\r\n\r\n        await this.dropDatabase(this.databaseName)\r\n      }\r\n\r\n      if (this.expirationDB) {\r\n        this.expirationDB.close()\r\n        this.expirationDB = null\r\n      }\r\n\r\n      return cb()\r\n    } catch (err) {\r\n      logger.error('Cannot destroy peertube chunk store.', err)\r\n      return cb(err)\r\n    }\r\n  }\r\n\r\n  private runCleaner () {\r\n    this.checkExpiration()\r\n\r\n    this.cleanerInterval = setInterval(() => {\r\n      this.checkExpiration()\r\n    }, PeertubeChunkStore.CLEANER_INTERVAL_MS)\r\n  }\r\n\r\n  private async checkExpiration () {\r\n    let databasesToDeleteInfo: { name: string }[] = []\r\n\r\n    try {\r\n      await this.expirationDB.transaction('rw', this.expirationDB.databases, async () => {\r\n        // Update our database expiration since we are alive\r\n        await this.expirationDB.databases.put({\r\n          name: this.databaseName,\r\n          expiration: new Date().getTime() + PeertubeChunkStore.CLEANER_EXPIRATION_MS\r\n        })\r\n\r\n        const now = new Date().getTime()\r\n        databasesToDeleteInfo = await this.expirationDB.databases.where('expiration').below(now).toArray()\r\n      })\r\n    } catch (err) {\r\n      logger.error('Cannot update expiration of fetch expired databases.', err)\r\n    }\r\n\r\n    for (const databaseToDeleteInfo of databasesToDeleteInfo) {\r\n      await this.dropDatabase(databaseToDeleteInfo.name)\r\n    }\r\n  }\r\n\r\n  private async dropDatabase (databaseName: string) {\r\n    const dbToDelete = new ChunkDatabase(databaseName)\r\n    logger.info(`Destroying IndexDB database ${databaseName}`)\r\n\r\n    try {\r\n      await dbToDelete.delete()\r\n\r\n      await this.expirationDB.transaction('rw', this.expirationDB.databases, () => {\r\n        return this.expirationDB.databases.where({ name: databaseName }).delete()\r\n      })\r\n    } catch (err) {\r\n      logger.error(`Cannot delete ${databaseName}.`, err)\r\n    }\r\n  }\r\n\r\n  private nextTick <T> (cb: (err?: Error, val?: T) => void, err: Error, val?: T) {\r\n    process.nextTick(() => cb(err, val), undefined)\r\n  }\r\n}\r\n","// Thanks: https://github.com/feross/render-media\r\n\r\nconst MediaElementWrapper = require('mediasource')\r\nimport { logger } from '@root-helpers/logger'\r\nimport { extname } from 'path'\r\nconst Videostream = require('videostream')\r\n\r\nconst VIDEOSTREAM_EXTS = [\r\n  '.m4a',\r\n  '.m4v',\r\n  '.mp4'\r\n]\r\n\r\ntype RenderMediaOptions = {\r\n  controls: boolean\r\n  autoplay: boolean\r\n}\r\n\r\nfunction renderVideo (\r\n  file: any,\r\n  elem: HTMLVideoElement,\r\n  opts: RenderMediaOptions,\r\n  callback: (err: Error, renderer: any) => void\r\n) {\r\n  validateFile(file)\r\n\r\n  return renderMedia(file, elem, opts, callback)\r\n}\r\n\r\nfunction renderMedia (file: any, elem: HTMLVideoElement, opts: RenderMediaOptions, callback: (err: Error, renderer?: any) => void) {\r\n  const extension = extname(file.name).toLowerCase()\r\n  let preparedElem: any\r\n  let currentTime = 0\r\n  let renderer: any\r\n\r\n  try {\r\n    if (VIDEOSTREAM_EXTS.includes(extension)) {\r\n      renderer = useVideostream()\r\n    } else {\r\n      renderer = useMediaSource()\r\n    }\r\n  } catch (err) {\r\n    return callback(err)\r\n  }\r\n\r\n  function useVideostream () {\r\n    prepareElem()\r\n    preparedElem.addEventListener('error', function onError (err: Error) {\r\n      preparedElem.removeEventListener('error', onError)\r\n\r\n      return callback(err)\r\n    })\r\n    preparedElem.addEventListener('loadstart', onLoadStart)\r\n    return new Videostream(file, preparedElem)\r\n  }\r\n\r\n  function useMediaSource (useVP9 = false) {\r\n    const codecs = getCodec(file.name, useVP9)\r\n\r\n    prepareElem()\r\n    preparedElem.addEventListener('error', function onError (err: Error) {\r\n      preparedElem.removeEventListener('error', onError)\r\n\r\n      // Try with vp9 before returning an error\r\n      if (codecs.includes('vp8')) return fallbackToMediaSource(true)\r\n\r\n      return callback(err)\r\n    })\r\n    preparedElem.addEventListener('loadstart', onLoadStart)\r\n\r\n    const wrapper = new MediaElementWrapper(preparedElem)\r\n    const writable = wrapper.createWriteStream(codecs)\r\n    file.createReadStream().pipe(writable)\r\n\r\n    if (currentTime) preparedElem.currentTime = currentTime\r\n\r\n    return wrapper\r\n  }\r\n\r\n  function fallbackToMediaSource (useVP9 = false) {\r\n    if (useVP9 === true) logger.info('Falling back to media source with VP9 enabled.')\r\n    else logger.info('Falling back to media source..')\r\n\r\n    useMediaSource(useVP9)\r\n  }\r\n\r\n  function prepareElem () {\r\n    if (preparedElem === undefined) {\r\n      preparedElem = elem\r\n\r\n      preparedElem.addEventListener('progress', function () {\r\n        currentTime = elem.currentTime\r\n      })\r\n    }\r\n  }\r\n\r\n  function onLoadStart () {\r\n    preparedElem.removeEventListener('loadstart', onLoadStart)\r\n    if (opts.autoplay) preparedElem.play()\r\n\r\n    callback(null, renderer)\r\n  }\r\n}\r\n\r\nfunction validateFile (file: any) {\r\n  if (file == null) {\r\n    throw new Error('file cannot be null or undefined')\r\n  }\r\n  if (typeof file.name !== 'string') {\r\n    throw new Error('missing or invalid file.name property')\r\n  }\r\n  if (typeof file.createReadStream !== 'function') {\r\n    throw new Error('missing or invalid file.createReadStream property')\r\n  }\r\n}\r\n\r\nfunction getCodec (name: string, useVP9 = false) {\r\n  const ext = extname(name).toLowerCase()\r\n  if (ext === '.mp4') {\r\n    return 'video/mp4; codecs=\"avc1.640029, mp4a.40.5\"'\r\n  }\r\n\r\n  if (ext === '.webm') {\r\n    if (useVP9 === true) return 'video/webm; codecs=\"vp9, opus\"'\r\n\r\n    return 'video/webm; codecs=\"vp8, vorbis\"'\r\n  }\r\n\r\n  return undefined\r\n}\r\n\r\nexport {\r\n  renderVideo\r\n}\r\n","import videojs from 'video.js'\r\nimport * as WebTorrent from 'webtorrent'\r\nimport { logger } from '@root-helpers/logger'\r\nimport { isIOS } from '@root-helpers/web-browser'\r\nimport { timeToInt } from '@shared/core-utils'\r\nimport { VideoFile } from '@shared/models'\r\nimport { getAverageBandwidthInStore, getStoredMute, getStoredVolume, saveAverageBandwidth } from '../../peertube-player-local-storage'\r\nimport { PeerTubeResolution, PlayerNetworkInfo, WebtorrentPluginOptions } from '../../types'\r\nimport { getRtcConfig, videoFileMaxByResolution, videoFileMinByResolution } from '../common'\r\nimport { PeertubeChunkStore } from './peertube-chunk-store'\r\nimport { renderVideo } from './video-renderer'\r\n\r\nconst CacheChunkStore = require('cache-chunk-store')\r\n\r\ntype PlayOptions = {\r\n  forcePlay?: boolean\r\n  seek?: number\r\n  delay?: number\r\n}\r\n\r\nconst Plugin = videojs.getPlugin('plugin')\r\n\r\nclass WebTorrentPlugin extends Plugin {\r\n  readonly videoFiles: VideoFile[]\r\n\r\n  private readonly playerElement: HTMLVideoElement\r\n\r\n  private readonly autoplay: boolean = false\r\n  private readonly startTime: number = 0\r\n  private readonly savePlayerSrcFunction: videojs.Player['src']\r\n  private readonly videoDuration: number\r\n  private readonly CONSTANTS = {\r\n    INFO_SCHEDULER: 1000, // Don't change this\r\n    AUTO_QUALITY_SCHEDULER: 3000, // Check quality every 3 seconds\r\n    AUTO_QUALITY_THRESHOLD_PERCENT: 30, // Bandwidth should be 30% more important than a resolution bitrate to change to it\r\n    AUTO_QUALITY_OBSERVATION_TIME: 10000, // Wait 10 seconds after having change the resolution before another check\r\n    AUTO_QUALITY_HIGHER_RESOLUTION_DELAY: 5000, // Buffering higher resolution during 5 seconds\r\n    BANDWIDTH_AVERAGE_NUMBER_OF_VALUES: 5 // Last 5 seconds to build average bandwidth\r\n  }\r\n\r\n  private readonly webtorrent = new WebTorrent({\r\n    tracker: {\r\n      rtcConfig: getRtcConfig()\r\n    },\r\n    dht: false\r\n  })\r\n\r\n  private currentVideoFile: VideoFile\r\n  private torrent: WebTorrent.Torrent\r\n\r\n  private renderer: any\r\n  private fakeRenderer: any\r\n  private destroyingFakeRenderer = false\r\n\r\n  private autoResolution = true\r\n  private autoResolutionPossible = true\r\n  private isAutoResolutionObservation = false\r\n  private playerRefusedP2P = false\r\n\r\n  private torrentInfoInterval: any\r\n  private autoQualityInterval: any\r\n  private addTorrentDelay: any\r\n  private qualityObservationTimer: any\r\n  private runAutoQualitySchedulerTimer: any\r\n\r\n  private downloadSpeeds: number[] = []\r\n\r\n  constructor (player: videojs.Player, options?: WebtorrentPluginOptions) {\r\n    super(player)\r\n\r\n    this.startTime = timeToInt(options.startTime)\r\n\r\n    // Custom autoplay handled by webtorrent because we lazy play the video\r\n    this.autoplay = options.autoplay\r\n\r\n    this.playerRefusedP2P = options.playerRefusedP2P\r\n\r\n    this.videoFiles = options.videoFiles\r\n    this.videoDuration = options.videoDuration\r\n\r\n    this.savePlayerSrcFunction = this.player.src\r\n    this.playerElement = options.playerElement\r\n\r\n    this.player.ready(() => {\r\n      const playerOptions = this.player.options_\r\n\r\n      const volume = getStoredVolume()\r\n      if (volume !== undefined) this.player.volume(volume)\r\n\r\n      const muted = playerOptions.muted !== undefined ? playerOptions.muted : getStoredMute()\r\n      if (muted !== undefined) this.player.muted(muted)\r\n\r\n      this.player.duration(options.videoDuration)\r\n\r\n      this.initializePlayer()\r\n      this.runTorrentInfoScheduler()\r\n\r\n      this.player.one('play', () => {\r\n        // Don't run immediately scheduler, wait some seconds the TCP connections are made\r\n        this.runAutoQualitySchedulerTimer = setTimeout(() => this.runAutoQualityScheduler(), this.CONSTANTS.AUTO_QUALITY_SCHEDULER)\r\n      })\r\n    })\r\n  }\r\n\r\n  dispose () {\r\n    clearTimeout(this.addTorrentDelay)\r\n    clearTimeout(this.qualityObservationTimer)\r\n    clearTimeout(this.runAutoQualitySchedulerTimer)\r\n\r\n    clearInterval(this.torrentInfoInterval)\r\n    clearInterval(this.autoQualityInterval)\r\n\r\n    // Don't need to destroy renderer, video player will be destroyed\r\n    this.flushVideoFile(this.currentVideoFile, false)\r\n\r\n    this.destroyFakeRenderer()\r\n  }\r\n\r\n  getCurrentResolutionId () {\r\n    return this.currentVideoFile ? this.currentVideoFile.resolution.id : -1\r\n  }\r\n\r\n  updateVideoFile (\r\n    videoFile?: VideoFile,\r\n    options: {\r\n      forcePlay?: boolean\r\n      seek?: number\r\n      delay?: number\r\n    } = {},\r\n    done: () => void = () => { /* empty */ }\r\n  ) {\r\n    // Automatically choose the adapted video file\r\n    if (!videoFile) {\r\n      const savedAverageBandwidth = getAverageBandwidthInStore()\r\n      videoFile = savedAverageBandwidth\r\n        ? this.getAppropriateFile(savedAverageBandwidth)\r\n        : this.pickAverageVideoFile()\r\n    }\r\n\r\n    if (!videoFile) {\r\n      throw Error(`Can't update video file since videoFile is undefined.`)\r\n    }\r\n\r\n    // Don't add the same video file once again\r\n    if (this.currentVideoFile !== undefined && this.currentVideoFile.magnetUri === videoFile.magnetUri) {\r\n      return\r\n    }\r\n\r\n    // Do not display error to user because we will have multiple fallback\r\n    this.player.peertube().hideFatalError();\r\n\r\n    // Hack to \"simulate\" src link in video.js >= 6\r\n    // Without this, we can't play the video after pausing it\r\n    // https://github.com/videojs/video.js/blob/master/src/js/player.js#L1633\r\n    (this.player as any).src = () => true\r\n    const oldPlaybackRate = this.player.playbackRate()\r\n\r\n    const previousVideoFile = this.currentVideoFile\r\n    this.currentVideoFile = videoFile\r\n\r\n    // Don't try on iOS that does not support MediaSource\r\n    // Or don't use P2P if webtorrent is disabled\r\n    if (isIOS() || this.playerRefusedP2P) {\r\n      return this.fallbackToHttp(options, () => {\r\n        this.player.playbackRate(oldPlaybackRate)\r\n        return done()\r\n      })\r\n    }\r\n\r\n    this.addTorrent(this.currentVideoFile.magnetUri, previousVideoFile, options, () => {\r\n      this.player.playbackRate(oldPlaybackRate)\r\n      return done()\r\n    })\r\n\r\n    this.selectAppropriateResolution(true)\r\n  }\r\n\r\n  updateEngineResolution (resolutionId: number, delay = 0) {\r\n    // Remember player state\r\n    const currentTime = this.player.currentTime()\r\n    const isPaused = this.player.paused()\r\n\r\n    // Hide bigPlayButton\r\n    if (!isPaused) {\r\n      this.player.bigPlayButton.hide()\r\n    }\r\n\r\n    // Audio-only (resolutionId === 0) gets special treatment\r\n    if (resolutionId === 0) {\r\n      // Audio-only: show poster, do not auto-hide controls\r\n      this.player.addClass('vjs-playing-audio-only-content')\r\n      this.player.posterImage.show()\r\n    } else {\r\n      // Hide poster to have black background\r\n      this.player.removeClass('vjs-playing-audio-only-content')\r\n      this.player.posterImage.hide()\r\n    }\r\n\r\n    const newVideoFile = this.videoFiles.find(f => f.resolution.id === resolutionId)\r\n    const options = {\r\n      forcePlay: false,\r\n      delay,\r\n      seek: currentTime + (delay / 1000)\r\n    }\r\n\r\n    this.updateVideoFile(newVideoFile, options)\r\n  }\r\n\r\n  flushVideoFile (videoFile: VideoFile, destroyRenderer = true) {\r\n    if (videoFile !== undefined && this.webtorrent.get(videoFile.magnetUri)) {\r\n      if (destroyRenderer === true && this.renderer && this.renderer.destroy) this.renderer.destroy()\r\n\r\n      this.webtorrent.remove(videoFile.magnetUri)\r\n      logger.info(`Removed ${videoFile.magnetUri}`)\r\n    }\r\n  }\r\n\r\n  disableAutoResolution () {\r\n    this.autoResolution = false\r\n    this.autoResolutionPossible = false\r\n    this.player.peertubeResolutions().disableAutoResolution()\r\n  }\r\n\r\n  isAutoResolutionPossible () {\r\n    return this.autoResolutionPossible\r\n  }\r\n\r\n  getTorrent () {\r\n    return this.torrent\r\n  }\r\n\r\n  getCurrentVideoFile () {\r\n    return this.currentVideoFile\r\n  }\r\n\r\n  changeQuality (id: number) {\r\n    if (id === -1) {\r\n      if (this.autoResolutionPossible === true) {\r\n        this.autoResolution = true\r\n\r\n        this.selectAppropriateResolution(false)\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    this.autoResolution = false\r\n    this.updateEngineResolution(id)\r\n    this.selectAppropriateResolution(false)\r\n  }\r\n\r\n  private addTorrent (\r\n    magnetOrTorrentUrl: string,\r\n    previousVideoFile: VideoFile,\r\n    options: PlayOptions,\r\n    done: (err?: Error) => void\r\n  ) {\r\n    if (!magnetOrTorrentUrl) return this.fallbackToHttp(options, done)\r\n\r\n    logger.info(`Adding ${magnetOrTorrentUrl}.`)\r\n\r\n    const oldTorrent = this.torrent\r\n    const torrentOptions = {\r\n      // Don't use arrow function: it breaks webtorrent (that uses `new` keyword)\r\n      store: function (chunkLength: number, storeOpts: any) {\r\n        return new CacheChunkStore(new PeertubeChunkStore(chunkLength, storeOpts), {\r\n          max: 100\r\n        })\r\n      }\r\n    }\r\n\r\n    this.torrent = this.webtorrent.add(magnetOrTorrentUrl, torrentOptions, torrent => {\r\n      logger.info(`Added ${magnetOrTorrentUrl}.`)\r\n\r\n      if (oldTorrent) {\r\n        // Pause the old torrent\r\n        this.stopTorrent(oldTorrent)\r\n\r\n        // We use a fake renderer so we download correct pieces of the next file\r\n        if (options.delay) this.renderFileInFakeElement(torrent.files[0], options.delay)\r\n      }\r\n\r\n      // Render the video in a few seconds? (on resolution change for example, we wait some seconds of the new video resolution)\r\n      this.addTorrentDelay = setTimeout(() => {\r\n        // We don't need the fake renderer anymore\r\n        this.destroyFakeRenderer()\r\n\r\n        const paused = this.player.paused()\r\n\r\n        this.flushVideoFile(previousVideoFile)\r\n\r\n        // Update progress bar (just for the UI), do not wait rendering\r\n        if (options.seek) this.player.currentTime(options.seek)\r\n\r\n        const renderVideoOptions = { autoplay: false, controls: true }\r\n        renderVideo(torrent.files[0], this.playerElement, renderVideoOptions, (err, renderer) => {\r\n          this.renderer = renderer\r\n\r\n          if (err) return this.fallbackToHttp(options, done)\r\n\r\n          return this.tryToPlay(err => {\r\n            if (err) return done(err)\r\n\r\n            if (options.seek) this.seek(options.seek)\r\n            if (options.forcePlay === false && paused === true) this.player.pause()\r\n\r\n            return done()\r\n          })\r\n        })\r\n      }, options.delay || 0)\r\n    })\r\n\r\n    this.torrent.on('error', (err: any) => logger.error(err))\r\n\r\n    this.torrent.on('warning', (err: any) => {\r\n      // We don't support HTTP tracker but we don't care -> we use the web socket tracker\r\n      if (err.message.indexOf('Unsupported tracker protocol') !== -1) return\r\n\r\n      // Users don't care about issues with WebRTC, but developers do so log it in the console\r\n      if (err.message.indexOf('Ice connection failed') !== -1) {\r\n        logger.info(err)\r\n        return\r\n      }\r\n\r\n      // Magnet hash is not up to date with the torrent file, add directly the torrent file\r\n      if (err.message.indexOf('incorrect info hash') !== -1) {\r\n        logger.error('Incorrect info hash detected, falling back to torrent file.')\r\n        const newOptions = { forcePlay: true, seek: options.seek }\r\n        return this.addTorrent(this.torrent['xs'], previousVideoFile, newOptions, done)\r\n      }\r\n\r\n      // Remote instance is down\r\n      if (err.message.indexOf('from xs param') !== -1) {\r\n        this.handleError(err)\r\n      }\r\n\r\n      logger.warn(err)\r\n    })\r\n  }\r\n\r\n  private tryToPlay (done?: (err?: Error) => void) {\r\n    if (!done) done = function () { /* empty */ }\r\n\r\n    const playPromise = this.player.play()\r\n    if (playPromise !== undefined) {\r\n      return playPromise.then(() => done())\r\n                        .catch((err: Error) => {\r\n                          if (err.message.includes('The play() request was interrupted by a call to pause()')) {\r\n                            return\r\n                          }\r\n\r\n                          logger.warn(err)\r\n                          this.player.pause()\r\n                          this.player.posterImage.show()\r\n                          this.player.removeClass('vjs-has-autoplay')\r\n                          this.player.removeClass('vjs-has-big-play-button-clicked')\r\n                          this.player.removeClass('vjs-playing-audio-only-content')\r\n\r\n                          return done()\r\n                        })\r\n    }\r\n\r\n    return done()\r\n  }\r\n\r\n  private seek (time: number) {\r\n    this.player.currentTime(time)\r\n    this.player.handleTechSeeked_()\r\n  }\r\n\r\n  private getAppropriateFile (averageDownloadSpeed?: number): VideoFile {\r\n    if (this.videoFiles === undefined) return undefined\r\n    if (this.videoFiles.length === 1) return this.videoFiles[0]\r\n\r\n    const files = this.videoFiles.filter(f => f.resolution.id !== 0)\r\n    if (files.length === 0) return undefined\r\n\r\n    // Don't change the torrent if the player ended\r\n    if (this.torrent && this.torrent.progress === 1 && this.player.ended()) return this.currentVideoFile\r\n\r\n    if (!averageDownloadSpeed) averageDownloadSpeed = this.getAndSaveActualDownloadSpeed()\r\n\r\n    // Limit resolution according to player height\r\n    const playerHeight = this.playerElement.offsetHeight\r\n\r\n    // We take the first resolution just above the player height\r\n    // Example: player height is 530px, we want the 720p file instead of 480p\r\n    let maxResolution = files[0].resolution.id\r\n    for (let i = files.length - 1; i >= 0; i--) {\r\n      const resolutionId = files[i].resolution.id\r\n      if (resolutionId !== 0 && resolutionId >= playerHeight) {\r\n        maxResolution = resolutionId\r\n        break\r\n      }\r\n    }\r\n\r\n    // Filter videos we can play according to our screen resolution and bandwidth\r\n    const filteredFiles = files.filter(f => f.resolution.id <= maxResolution)\r\n                               .filter(f => {\r\n                                 const fileBitrate = (f.size / this.videoDuration)\r\n                                 let threshold = fileBitrate\r\n\r\n                                 // If this is for a higher resolution or an initial load: add a margin\r\n                                 if (!this.currentVideoFile || f.resolution.id > this.currentVideoFile.resolution.id) {\r\n                                   threshold += ((fileBitrate * this.CONSTANTS.AUTO_QUALITY_THRESHOLD_PERCENT) / 100)\r\n                                 }\r\n\r\n                                 return averageDownloadSpeed > threshold\r\n                               })\r\n\r\n    // If the download speed is too bad, return the lowest resolution we have\r\n    if (filteredFiles.length === 0) return videoFileMinByResolution(files)\r\n\r\n    return videoFileMaxByResolution(filteredFiles)\r\n  }\r\n\r\n  private getAndSaveActualDownloadSpeed () {\r\n    const start = Math.max(this.downloadSpeeds.length - this.CONSTANTS.BANDWIDTH_AVERAGE_NUMBER_OF_VALUES, 0)\r\n    const lastDownloadSpeeds = this.downloadSpeeds.slice(start, this.downloadSpeeds.length)\r\n    if (lastDownloadSpeeds.length === 0) return -1\r\n\r\n    const sum = lastDownloadSpeeds.reduce((a, b) => a + b)\r\n    const averageBandwidth = Math.round(sum / lastDownloadSpeeds.length)\r\n\r\n    // Save the average bandwidth for future use\r\n    saveAverageBandwidth(averageBandwidth)\r\n\r\n    return averageBandwidth\r\n  }\r\n\r\n  private initializePlayer () {\r\n    this.buildQualities()\r\n\r\n    if (this.videoFiles.length === 0) {\r\n      this.player.addClass('disabled')\r\n      return\r\n    }\r\n\r\n    if (this.autoplay) {\r\n      this.player.posterImage.hide()\r\n\r\n      return this.updateVideoFile(undefined, { forcePlay: true, seek: this.startTime })\r\n    }\r\n\r\n    // Proxy first play\r\n    const oldPlay = this.player.play.bind(this.player);\r\n    (this.player as any).play = () => {\r\n      this.player.addClass('vjs-has-big-play-button-clicked')\r\n      this.player.play = oldPlay\r\n\r\n      this.updateVideoFile(undefined, { forcePlay: true, seek: this.startTime })\r\n    }\r\n  }\r\n\r\n  private runAutoQualityScheduler () {\r\n    this.autoQualityInterval = setInterval(() => {\r\n\r\n      // Not initialized or in HTTP fallback\r\n      if (this.torrent === undefined || this.torrent === null) return\r\n      if (this.autoResolution === false) return\r\n      if (this.isAutoResolutionObservation === true) return\r\n\r\n      const file = this.getAppropriateFile()\r\n      let changeResolution = false\r\n      let changeResolutionDelay = 0\r\n\r\n      // Lower resolution\r\n      if (this.isPlayerWaiting() && file.resolution.id < this.currentVideoFile.resolution.id) {\r\n        logger.info(`Downgrading automatically the resolution to: ${file.resolution.label}`)\r\n        changeResolution = true\r\n      } else if (file.resolution.id > this.currentVideoFile.resolution.id) { // Higher resolution\r\n        logger.info(`Upgrading automatically the resolution to: ${file.resolution.label}`)\r\n        changeResolution = true\r\n        changeResolutionDelay = this.CONSTANTS.AUTO_QUALITY_HIGHER_RESOLUTION_DELAY\r\n      }\r\n\r\n      if (changeResolution === true) {\r\n        this.updateEngineResolution(file.resolution.id, changeResolutionDelay)\r\n\r\n        // Wait some seconds in observation of our new resolution\r\n        this.isAutoResolutionObservation = true\r\n\r\n        this.qualityObservationTimer = setTimeout(() => {\r\n          this.isAutoResolutionObservation = false\r\n        }, this.CONSTANTS.AUTO_QUALITY_OBSERVATION_TIME)\r\n      }\r\n    }, this.CONSTANTS.AUTO_QUALITY_SCHEDULER)\r\n  }\r\n\r\n  private isPlayerWaiting () {\r\n    return this.player?.hasClass('vjs-waiting')\r\n  }\r\n\r\n  private runTorrentInfoScheduler () {\r\n    this.torrentInfoInterval = setInterval(() => {\r\n      // Not initialized yet\r\n      if (this.torrent === undefined) return\r\n\r\n      // Http fallback\r\n      if (this.torrent === null) return this.player.trigger('p2pInfo', false)\r\n\r\n      // this.webtorrent.downloadSpeed because we need to take into account the potential old torrent too\r\n      if (this.webtorrent.downloadSpeed !== 0) this.downloadSpeeds.push(this.webtorrent.downloadSpeed)\r\n\r\n      return this.player.trigger('p2pInfo', {\r\n        source: 'webtorrent',\r\n        http: {\r\n          downloadSpeed: 0,\r\n          uploadSpeed: 0,\r\n          downloaded: 0,\r\n          uploaded: 0\r\n        },\r\n        p2p: {\r\n          downloadSpeed: this.torrent.downloadSpeed,\r\n          numPeers: this.torrent.numPeers,\r\n          uploadSpeed: this.torrent.uploadSpeed,\r\n          downloaded: this.torrent.downloaded,\r\n          uploaded: this.torrent.uploaded\r\n        },\r\n        bandwidthEstimate: this.webtorrent.downloadSpeed\r\n      } as PlayerNetworkInfo)\r\n    }, this.CONSTANTS.INFO_SCHEDULER)\r\n  }\r\n\r\n  private fallbackToHttp (options: PlayOptions, done?: (err?: Error) => void) {\r\n    const paused = this.player.paused()\r\n\r\n    this.disableAutoResolution()\r\n\r\n    this.flushVideoFile(this.currentVideoFile, true)\r\n    this.torrent = null\r\n\r\n    // Enable error display now this is our last fallback\r\n    this.player.one('error', () => this.player.peertube().displayFatalError())\r\n\r\n    const httpUrl = this.currentVideoFile.fileUrl\r\n    this.player.src = this.savePlayerSrcFunction\r\n    this.player.src(httpUrl)\r\n\r\n    this.selectAppropriateResolution(true)\r\n\r\n    // We changed the source, so reinit captions\r\n    this.player.trigger('sourcechange')\r\n\r\n    return this.tryToPlay(err => {\r\n      if (err && done) return done(err)\r\n\r\n      if (options.seek) this.seek(options.seek)\r\n      if (options.forcePlay === false && paused === true) this.player.pause()\r\n\r\n      if (done) return done()\r\n    })\r\n  }\r\n\r\n  private handleError (err: Error | string) {\r\n    return this.player.trigger('customError', { err })\r\n  }\r\n\r\n  private pickAverageVideoFile () {\r\n    if (this.videoFiles.length === 1) return this.videoFiles[0]\r\n\r\n    const files = this.videoFiles.filter(f => f.resolution.id !== 0)\r\n    return files[Math.floor(files.length / 2)]\r\n  }\r\n\r\n  private stopTorrent (torrent: WebTorrent.Torrent) {\r\n    torrent.pause()\r\n    // Pause does not remove actual peers (in particular the webseed peer)\r\n    torrent.removePeer(torrent['ws'])\r\n  }\r\n\r\n  private renderFileInFakeElement (file: WebTorrent.TorrentFile, delay: number) {\r\n    this.destroyingFakeRenderer = false\r\n\r\n    const fakeVideoElem = document.createElement('video')\r\n    renderVideo(file, fakeVideoElem, { autoplay: false, controls: false }, (err, renderer) => {\r\n      this.fakeRenderer = renderer\r\n\r\n      // The renderer returns an error when we destroy it, so skip them\r\n      if (this.destroyingFakeRenderer === false && err) {\r\n        logger.error('Cannot render new torrent in fake video element.', err)\r\n      }\r\n\r\n      // Load the future file at the correct time (in delay MS - 2 seconds)\r\n      fakeVideoElem.currentTime = this.player.currentTime() + (delay - 2000)\r\n    })\r\n  }\r\n\r\n  private destroyFakeRenderer () {\r\n    if (this.fakeRenderer) {\r\n      this.destroyingFakeRenderer = true\r\n\r\n      if (this.fakeRenderer.destroy) {\r\n        try {\r\n          this.fakeRenderer.destroy()\r\n        } catch (err) {\r\n          logger.info('Cannot destroy correctly fake renderer.', err)\r\n        }\r\n      }\r\n      this.fakeRenderer = undefined\r\n    }\r\n  }\r\n\r\n  private buildQualities () {\r\n    const resolutions: PeerTubeResolution[] = this.videoFiles.map(file => ({\r\n      id: file.resolution.id,\r\n      label: this.buildQualityLabel(file),\r\n      height: file.resolution.id,\r\n      selected: false,\r\n      selectCallback: () => this.changeQuality(file.resolution.id)\r\n    }))\r\n\r\n    resolutions.push({\r\n      id: -1,\r\n      label: this.player.localize('Auto'),\r\n      selected: true,\r\n      selectCallback: () => this.changeQuality(-1)\r\n    })\r\n\r\n    this.player.peertubeResolutions().add(resolutions)\r\n  }\r\n\r\n  private buildQualityLabel (file: VideoFile) {\r\n    let label = file.resolution.label\r\n\r\n    if (file.fps && file.fps >= 50) {\r\n      label += file.fps\r\n    }\r\n\r\n    return label\r\n  }\r\n\r\n  private selectAppropriateResolution (byEngine: boolean) {\r\n    const resolution = this.autoResolution\r\n      ? -1\r\n      : this.getCurrentResolutionId()\r\n\r\n    const autoResolutionChosen = this.autoResolution\r\n      ? this.getCurrentResolutionId()\r\n      : undefined\r\n\r\n    this.player.peertubeResolutions().select({ id: resolution, autoResolutionChosenId: autoResolutionChosen, byEngine })\r\n  }\r\n}\r\n\r\nvideojs.registerPlugin('webtorrent', WebTorrentPlugin)\r\nexport { WebTorrentPlugin }\r\n","module.exports = require('stream-http')\r\n","module.exports = require('https-browserify')\r\n","// Does nothing. Used to shim out node.js modules\r\n// which are no-ops in the browser.\r\nexport const NOOP = 0\r\n","module.exports = require('stream-browserify')\r\n"],"names":["ChunkDatabase","dbname","version","stores","chunks","Dexie","ExpirationDatabase","databases","PeertubeChunkStore","chunkLength","opts","pendingPut","memoryChunks","databaseName","torrent","_a","infoHash","setMaxListeners","Number","Error","length","Infinity","lastChunkLength","lastChunkIndex","Math","ceil","db","expirationDB","runCleaner","index","buf","cb","isLastChunk","this","nextTick","push","id","putBulkTimeout","setTimeout","processing","undefined","transaction","bulkPut","map","p","err","logger","forEach","BUFFERING_PUT_MS","get","memoryChunk","process","result","Buffer","alloc","offset","slice","catch","destroy","clearTimeout","cleanerInterval","clearInterval","close","dropDatabase","checkExpiration","setInterval","CLEANER_INTERVAL_MS","databasesToDeleteInfo","put","name","expiration","Date","getTime","CLEANER_EXPIRATION_MS","now","where","below","toArray","databaseToDeleteInfo","dbToDelete","delete","val","EventEmitter","MediaElementWrapper","require","Videostream","VIDEOSTREAM_EXTS","renderVideo","file","elem","callback","createReadStream","validateFile","preparedElem","renderer","extension","extname","toLowerCase","currentTime","includes","prepareElem","addEventListener","onError","removeEventListener","onLoadStart","useMediaSource","codecs","getCodec","fallbackToMediaSource","wrapper","writable","createWriteStream","pipe","useVP9","autoplay","play","renderMedia","ext","CacheChunkStore","WebTorrentPlugin","player","options","startTime","CONSTANTS","INFO_SCHEDULER","AUTO_QUALITY_SCHEDULER","AUTO_QUALITY_THRESHOLD_PERCENT","AUTO_QUALITY_OBSERVATION_TIME","AUTO_QUALITY_HIGHER_RESOLUTION_DELAY","BANDWIDTH_AVERAGE_NUMBER_OF_VALUES","webtorrent","WebTorrent","tracker","rtcConfig","getRtcConfig","dht","destroyingFakeRenderer","autoResolution","autoResolutionPossible","isAutoResolutionObservation","playerRefusedP2P","downloadSpeeds","timeToInt","videoFiles","videoDuration","savePlayerSrcFunction","src","playerElement","ready","playerOptions","options_","volume","getStoredVolume","muted","getStoredMute","duration","initializePlayer","runTorrentInfoScheduler","one","runAutoQualitySchedulerTimer","runAutoQualityScheduler","addTorrentDelay","qualityObservationTimer","torrentInfoInterval","autoQualityInterval","flushVideoFile","currentVideoFile","destroyFakeRenderer","resolution","videoFile","done","savedAverageBandwidth","getAverageBandwidthInStore","getAppropriateFile","pickAverageVideoFile","magnetUri","peertube","hideFatalError","oldPlaybackRate","playbackRate","previousVideoFile","isIOS","fallbackToHttp","addTorrent","selectAppropriateResolution","resolutionId","delay","isPaused","paused","bigPlayButton","hide","addClass","posterImage","show","removeClass","newVideoFile","find","f","forcePlay","seek","updateVideoFile","destroyRenderer","remove","peertubeResolutions","disableAutoResolution","updateEngineResolution","magnetOrTorrentUrl","oldTorrent","add","store","storeOpts","max","stopTorrent","renderFileInFakeElement","files","controls","tryToPlay","pause","on","message","indexOf","handleError","playPromise","then","time","handleTechSeeked_","averageDownloadSpeed","filter","progress","ended","getAndSaveActualDownloadSpeed","playerHeight","offsetHeight","maxResolution","i","filteredFiles","fileBitrate","size","threshold","videoFileMinByResolution","videoFileMaxByResolution","start","lastDownloadSpeeds","sum","reduce","a","b","averageBandwidth","round","saveAverageBandwidth","buildQualities","oldPlay","bind","changeResolution","changeResolutionDelay","isPlayerWaiting","label","hasClass","trigger","downloadSpeed","source","http","uploadSpeed","downloaded","uploaded","p2p","numPeers","bandwidthEstimate","displayFatalError","httpUrl","fileUrl","floor","removePeer","fakeVideoElem","document","createElement","fakeRenderer","resolutions","buildQualityLabel","height","selected","selectCallback","changeQuality","localize","fps","byEngine","getCurrentResolutionId","autoResolutionChosen","select","autoResolutionChosenId","videojs","module","exports","NOOP"],"sourceRoot":""}