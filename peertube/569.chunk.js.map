{"version":3,"file":"569.chunk.js?v=1517","mappings":"qSAQA,MAAMA,UAAsB,KAG1BC,YAAaC,GACXC,MAAMD,GAENE,KAAKC,QAAQ,GAAGC,OAAO,CACrBC,OAAQ,MAEZ,EAGF,MAAMC,UAA2B,KAG/BP,cACEE,MAAM,yBAENC,KAAKC,QAAQ,GAAGC,OAAO,CACrBG,UAAW,mBAEf,EAGK,MAAMC,UAA2B,EAAAC,aAmBtCV,YAAaW,EAAqBC,G,MAYhC,GAXAV,QAbM,KAAAW,WAAuE,GAEvE,KAAAC,aAAkD,CAAC,EAazDX,KAAKY,aAAe,qBAEfH,IAAMA,EAAO,CAAC,IACH,QAAZ,EAAAA,EAAKI,eAAO,eAAEC,UAAUd,KAAKY,cAAgBH,EAAKI,QAAQC,SACzDd,KAAKY,cAAgB,WAE1BZ,KAAKe,gBAAgB,KAErBf,KAAKQ,YAAcQ,OAAOR,IACrBR,KAAKQ,YAAa,MAAM,IAAIS,MAAM,yCAEvCjB,KAAKkB,OAASF,OAAOP,EAAKS,SAAWC,IAEjCnB,KAAKkB,SAAWC,MAClBnB,KAAKoB,gBAAmBpB,KAAKkB,OAASlB,KAAKQ,aAAgBR,KAAKQ,YAChER,KAAKqB,eAAiBC,KAAKC,KAAKvB,KAAKkB,OAASlB,KAAKQ,aAAe,GAGpER,KAAKwB,GAAK,IAAI5B,EAAcI,KAAKY,cAEjCZ,KAAKyB,aAAe,IAAIrB,EAExBJ,KAAK0B,YACP,CAEAC,IAAKC,EAAeC,EAAaC,GAC/B,MAAMC,EAAeH,IAAU5B,KAAKqB,eACpC,OAAIU,GAAeF,EAAIX,SAAWlB,KAAKoB,gBAC9BpB,KAAKgC,SAASF,EAAI,IAAIb,MAAM,6BAA+BjB,KAAKoB,kBAEpEW,GAAeF,EAAIX,SAAWlB,KAAKQ,aAKxCR,KAAKW,aAAaiB,IAAS,EAG3B5B,KAAKU,WAAWuB,KAAK,CAAEC,GAAIN,EAAOC,MAAKC,YAEnC9B,KAAKmC,iBAGTnC,KAAKmC,eAAiBC,YAAWC,UAC/B,MAAMC,EAAatC,KAAKU,WACxBV,KAAKU,WAAa,GAClBV,KAAKmC,oBAAiBI,EAEtB,UACQvC,KAAKwB,GAAGgB,YAAY,KAAMxC,KAAKwB,GAAGrB,QAAQ,IACvCH,KAAKwB,GAAGrB,OAAOsC,QAAQH,EAAWI,KAAIC,IAAK,CAAGT,GAAIS,EAAET,GAAIL,IAAKc,EAAEd,U,CAExE,MAAOe,GACPC,EAAA,OAAY,mDAAoDD,GAEhEN,EAAWQ,SAAQH,IACjB3C,KAAKW,aAAagC,EAAET,IAAMS,EAAEd,GAAG,G,SAGjCS,EAAWQ,SAAQH,GAAKA,EAAEb,M,IAE3BxB,EAAmByC,qBA9Bb/C,KAAKgC,SAASF,EAAI,IAAIb,MAAM,wBAA0BjB,KAAKQ,aA+BtE,CAEAwC,IAAKpB,EAAenB,EAAWqB,GAC7B,GAAoB,mBAATrB,EAAqB,OAAOT,KAAKgD,IAAIpB,EAAO,KAAMnB,GAG7D,MAAMwC,EAAcjD,KAAKW,aAAaiB,GACtC,QAAoBW,IAAhBU,EAA2B,CAC7B,MAAML,EAAM,IAAI3B,MAAM,mBAGtB,OAFA2B,EAAc,UAAI,EAEXM,EAAQlB,UAAS,IAAMF,EAAGc,I,CAInC,IAAoB,IAAhBK,EAAsB,OAAOnB,EAAG,KAAMmB,GAG1CjD,KAAKwB,GAAGgB,YAAY,IAAKxC,KAAKwB,GAAGrB,QAAQkC,UACvC,MAAMc,QAAenD,KAAKwB,GAAGrB,OAAO6C,IAAI,CAAEd,GAAIN,IAC9C,QAAeW,IAAXY,EAAsB,OAAOrB,EAAG,KAAMsB,EAAOC,MAAM,IAEvD,MAAMxB,EAAMsB,EAAOtB,IACnB,IAAKpB,EAAM,OAAOT,KAAKgC,SAASF,EAAI,KAAMD,GAE1C,MAAMyB,EAAS7C,EAAK6C,QAAU,EAE9B,OAAOxB,EAAG,KAAMD,EAAI0B,MAAMD,GADd7C,EAAKS,QAAWW,EAAIX,OAASoC,GACDA,GAAQ,IAEjDE,OAAMZ,IACLC,EAAA,QAAaD,GACNd,EAAGc,KAEd,CAEAa,MAAO3B,GACL,OAAO9B,KAAK0D,QAAQ5B,EACtB,CAEAO,cAAeP,GACb,IAqBE,OApBI9B,KAAKU,aACPiD,aAAa3D,KAAKmC,gBAClBnC,KAAKU,WAAa,MAEhBV,KAAK4D,kBACPC,cAAc7D,KAAK4D,iBACnB5D,KAAK4D,gBAAkB,MAGrB5D,KAAKwB,KACPxB,KAAKwB,GAAGiC,cAEFzD,KAAK8D,aAAa9D,KAAKY,eAG3BZ,KAAKyB,eACPzB,KAAKyB,aAAagC,QAClBzD,KAAKyB,aAAe,MAGfK,G,CACP,MAAOc,GAEP,OADAC,EAAA,QAAa,uCAAwCD,GAC9Cd,EAAGc,E,CAEd,CAEQlB,aACN1B,KAAK+D,kBAEL/D,KAAK4D,gBAAkBI,aAAY,KACjChE,KAAK+D,iBAAiB,GACrBzD,EAAmB2D,oBACxB,CAEQ5B,wBACN,IAAI6B,EAA4C,GAEhD,UACQlE,KAAKyB,aAAae,YAAY,KAAMxC,KAAKyB,aAAapB,WAAWgC,gBAE/DrC,KAAKyB,aAAapB,UAAUsB,IAAI,CACpCwC,KAAMnE,KAAKY,aACXwD,YAAY,IAAIC,MAAOC,UAAYhE,EAAmBiE,wBAGxD,MAAMC,GAAM,IAAIH,MAAOC,UACvBJ,QAA8BlE,KAAKyB,aAAapB,UAAUoE,MAAM,cAAcC,MAAMF,GAAKG,SAAS,G,CAEpG,MAAO/B,GACPC,EAAA,QAAa,uDAAwDD,E,CAGvE,IAAK,MAAMgC,KAAwBV,QAC3BlE,KAAK8D,aAAac,EAAqBT,KAEjD,CAEQ9B,mBAAoBzB,GAC1B,MAAMiE,EAAa,IAAIjF,EAAcgB,GACrCiC,EAAA,OAAY,+BAA+BjC,KAE3C,UACQiE,EAAWC,eAEX9E,KAAKyB,aAAae,YAAY,KAAMxC,KAAKyB,aAAapB,WAAW,IAC9DL,KAAKyB,aAAapB,UAAUoE,MAAM,CAAEN,KAAMvD,IAAgBkE,U,CAEnE,MAAOlC,GACPC,EAAA,QAAa,iBAAiBjC,KAAiBgC,E,CAEnD,CAEQZ,SAAcF,EAAoCc,EAAYmC,GACpE7B,EAAQlB,UAAS,IAAMF,EAAGc,EAAKmC,SAAMxC,EACvC,EAvMwB,EAAAQ,iBAAmB,IACnB,EAAAkB,oBAAsB,IACtB,EAAAM,sBAAwB,I,cCjClD,MAAMS,EAAsB,EAAQ,MAG9BC,EAAc,EAAQ,MAEtBC,EAAmB,CACvB,OACA,OACA,QAQF,SAASC,EACPC,EACAC,EACA5E,EACA6E,GAIA,OA8EF,SAAuBF,GACrB,GAAY,MAARA,EACF,MAAM,IAAInE,MAAM,oCAElB,GAAyB,iBAAdmE,EAAKjB,KACd,MAAM,IAAIlD,MAAM,yCAElB,GAAqC,mBAA1BmE,EAAKG,iBACd,MAAM,IAAItE,MAAM,oDAEpB,CA1FEuE,CAAaJ,GAKf,SAAsBA,EAAWC,EAAwB5E,EAA0B6E,GACjF,MAAMG,GAAY,IAAAC,SAAQN,EAAKjB,MAAMwB,cACrC,IAAIC,EAEAC,EADAC,EAAc,EAGlB,IAEID,EADEX,EAAiBa,SAASN,IAU9BO,IACAJ,EAAaK,iBAAiB,SAAS,SAASC,EAAStD,GAGvD,OAFAgD,EAAaO,oBAAoB,QAASD,GAEnCZ,EAAS1C,EAClB,IACAgD,EAAaK,iBAAiB,YAAaG,GACpC,IAAInB,EAAYG,EAAMQ,IAG/B,SAASS,EAAgBC,GAAS,GAChC,MAAMC,EA2DV,SAAmBpC,EAAcmC,GAAS,GACxC,MAAME,GAAM,IAAAd,SAAQvB,GAAMwB,cAC1B,MAAY,SAARa,EACK,6CAGG,UAARA,GACa,IAAXF,EAAwB,iCAErB,wCAHT,CAOF,CAxEmBG,CAASrB,EAAKjB,KAAMmC,GAEnCN,IACAJ,EAAaK,iBAAiB,SAAS,SAASC,EAAStD,GAIvD,OAHAgD,EAAaO,oBAAoB,QAASD,GAGtCK,EAAOR,SAAS,OAexB,SAAgCO,GAAS,GAClBzD,EAAA,QAAN,IAAXyD,EAA6B,iDAChB,kCAEjBD,EAAeC,EACjB,CApBuCI,EAAsB,GAElDpB,EAAS1C,EAClB,IACAgD,EAAaK,iBAAiB,YAAaG,GAE3C,MAAMO,EAAU,IAAI3B,EAAoBY,GAClCgB,EAAWD,EAAQE,kBAAkBN,GAK3C,OAJAnB,EAAKG,mBAAmBuB,KAAKF,GAEzBd,IAAaF,EAAaE,YAAcA,GAErCa,CACT,CAtCeN,E,CAEb,MAAOzD,GACP,OAAO0C,EAAS1C,E,CA4ClB,SAASoD,SACczD,IAAjBqD,IACFA,EAAeP,EAEfO,EAAaK,iBAAiB,YAAY,WACxCH,EAAcT,EAAKS,WACrB,IAEJ,CAEA,SAASM,IACPR,EAAaO,oBAAoB,YAAaC,GAC1C3F,EAAKsG,UAAUnB,EAAaoB,OAEhC1B,EAAS,KAAMO,EACjB,CACF,CA5ESoB,CAAY7B,EAAMC,EAAM5E,EAAM6E,EACvC,CCfA,MAAM4B,EAAkB,EAAQ,MAQ1BC,EAAS,cAAkB,UAEjC,MAAMC,UAAyBD,EA6C7BtH,YAAawH,EAAwBC,GACnCvH,MAAMsH,GAzCS,KAAAN,UAAoB,EACpB,KAAAQ,UAAoB,EAGpB,KAAAC,UAAY,CAC3BC,eAAgB,IAChBC,uBAAwB,IACxBC,+BAAgC,GAChCC,8BAA+B,IAC/BC,qCAAsC,IACtCC,mCAAoC,GAGrB,KAAAC,WAAa,IAAI,EAAW,CAC3CC,QAAS,CACPC,WAAW,WAEbC,KAAK,IAQC,KAAAC,wBAAyB,EAEzB,KAAAC,gBAAiB,EACjB,KAAAC,wBAAyB,EACzB,KAAAC,6BAA8B,EAC9B,KAAAC,kBAAmB,EAQnB,KAAAC,eAA2B,GAKjCxI,KAAKuH,WAAY,QAAUD,EAAQC,WAGnCvH,KAAK+G,SAAWO,EAAQP,SAExB/G,KAAKuI,iBAAmBjB,EAAQiB,iBAEhCvI,KAAKyI,WAAanB,EAAQmB,WAC1BzI,KAAK0I,cAAgBpB,EAAQoB,cAE7B1I,KAAK2I,sBAAwB3I,KAAKqH,OAAOuB,IACzC5I,KAAK6I,cAAgBvB,EAAQuB,cAE7B7I,KAAKqH,OAAOyB,OAAM,KAChB,MAAMC,EAAgB/I,KAAKqH,OAAO2B,SAE5BC,GAAS,eACA1G,IAAX0G,GAAsBjJ,KAAKqH,OAAO4B,OAAOA,GAE7C,MAAMC,OAAgC3G,IAAxBwG,EAAcG,MAAsBH,EAAcG,OAAQ,eAC1D3G,IAAV2G,GAAqBlJ,KAAKqH,OAAO6B,MAAMA,GAE3ClJ,KAAKqH,OAAO8B,SAAS7B,EAAQoB,eAE7B1I,KAAKoJ,mBACLpJ,KAAKqJ,0BAELrJ,KAAKqH,OAAOiC,IAAI,QAAQ,KAEtBtJ,KAAKuJ,6BAA+BnH,YAAW,IAAMpC,KAAKwJ,2BAA2BxJ,KAAKwH,UAAUE,uBAAuB,GAC3H,GAEN,CAEA+B,UACE9F,aAAa3D,KAAK0J,iBAClB/F,aAAa3D,KAAK2J,yBAClBhG,aAAa3D,KAAKuJ,8BAElB1F,cAAc7D,KAAK4J,qBACnB/F,cAAc7D,KAAK6J,qBAGnB7J,KAAK8J,eAAe9J,KAAK+J,kBAAkB,GAE3C/J,KAAKgK,qBACP,CAEAC,yBACE,OAAOjK,KAAK+J,iBAAmB/J,KAAK+J,iBAAiBG,WAAWhI,IAAM,CACxE,CAEAiI,gBACEC,EACA9C,EAII,CAAC,EACL+C,EAAmB,UAGnB,IAAKD,EAAW,CACd,MAAME,GAAwB,UAC9BF,EAAYE,EACRtK,KAAKuK,mBAAmBD,GACxBtK,KAAKwK,sB,CAGX,IAAKJ,EACH,MAAMnJ,MAAM,yDAId,QAA8BsB,IAA1BvC,KAAK+J,kBAAkC/J,KAAK+J,iBAAiBU,YAAcL,EAAUK,UACvF,OAIFzK,KAAKqH,OAAOqD,WAAWC,iBAKtB3K,KAAKqH,OAAeuB,IAAM,KAAM,EACjC,MAAMgC,EAAkB5K,KAAKqH,OAAOwD,eAE9BC,EAAoB9K,KAAK+J,iBAK/B,GAJA/J,KAAK+J,iBAAmBK,GAIpB,WAAWpK,KAAKuI,iBAClB,OAAOvI,KAAK+K,eAAezD,GAAS,KAClCtH,KAAKqH,OAAOwD,aAAaD,GAClBP,OAIXrK,KAAKgL,WAAWhL,KAAK+J,iBAAiBU,UAAWK,EAAmBxD,GAAS,KAC3EtH,KAAKqH,OAAOwD,aAAaD,GAClBP,OAGTrK,KAAKiL,6BAA4B,EACnC,CAEAC,uBAAwBC,EAAsBC,EAAQ,GAEpD,MAAMtF,EAAc9F,KAAKqH,OAAOvB,cACf9F,KAAKqH,OAAOgE,UAI3BrL,KAAKqH,OAAOiE,cAAcC,OAIP,IAAjBJ,GAEFnL,KAAKqH,OAAOmE,SAAS,kCACrBxL,KAAKqH,OAAOoE,YAAYC,SAGxB1L,KAAKqH,OAAOsE,YAAY,kCACxB3L,KAAKqH,OAAOoE,YAAYF,QAG1B,MAAMK,EAAe5L,KAAKyI,WAAWoD,MAAKC,GAAKA,EAAE5B,WAAWhI,KAAOiJ,IAOnEnL,KAAKmK,gBAAgByB,EANL,CACdG,WAAW,EACXX,QACAY,KAAMlG,EAAesF,EAAQ,KAIjC,CAEAtB,eAAgBM,EAAsB6B,GAAkB,QACpC1J,IAAd6H,GAA2BpK,KAAK+H,WAAW/E,IAAIoH,EAAUK,cACnC,IAApBwB,GAA4BjM,KAAK6F,UAAY7F,KAAK6F,SAASnC,SAAS1D,KAAK6F,SAASnC,UAEtF1D,KAAK+H,WAAWmE,OAAO9B,EAAUK,WACjC5H,EAAA,OAAY,WAAWuH,EAAUK,aAErC,CAEA0B,wBACEnM,KAAKoI,gBAAiB,EACtBpI,KAAKqI,wBAAyB,EAC9BrI,KAAKqH,OAAO+E,sBAAsBD,uBACpC,CAEAE,2BACE,OAAOrM,KAAKqI,sBACd,CAEAiE,aACE,OAAOtM,KAAKa,OACd,CAEA0L,sBACE,OAAOvM,KAAK+J,gBACd,CAEAyC,cAAetK,IACD,IAARA,GAUJlC,KAAKoI,gBAAiB,EACtBpI,KAAKkL,uBAAuBhJ,GAC5BlC,KAAKiL,6BAA4B,KAXK,IAAhCjL,KAAKqI,yBACPrI,KAAKoI,gBAAiB,EAEtBpI,KAAKiL,6BAA4B,GASvC,CAEQD,WACNyB,EACA3B,EACAxD,EACA+C,GAEA,IAAKoC,EAAoB,OAAOzM,KAAK+K,eAAezD,EAAS+C,GAE7DxH,EAAA,OAAY,UAAU4J,MAEtB,MAAMC,EAAa1M,KAAKa,QAUxBb,KAAKa,QAAUb,KAAK+H,WAAW4E,IAAIF,EATZ,CAErBG,MAAO,SAAUpM,EAAqBqM,GACpC,OAAO,IAAI3F,EAAgB,IAAI5G,EAAmBE,EAAaqM,GAAY,CACzEC,IAAK,KAET,IAGqEjM,IACrEgC,EAAA,OAAY,SAAS4J,MAEjBC,IAEF1M,KAAK+M,YAAYL,GAGbpF,EAAQ8D,OAAOpL,KAAKgN,wBAAwBnM,EAAQoM,MAAM,GAAI3F,EAAQ8D,QAI5EpL,KAAK0J,gBAAkBtH,YAAW,KAEhCpC,KAAKgK,sBAEL,MAAMqB,EAASrL,KAAKqH,OAAOgE,SAE3BrL,KAAK8J,eAAegB,GAGhBxD,EAAQ0E,MAAMhM,KAAKqH,OAAOvB,YAAYwB,EAAQ0E,MAGlD7G,EAAYtE,EAAQoM,MAAM,GAAIjN,KAAK6I,cADR,CAAE9B,UAAU,EAAOmG,UAAU,IACc,CAACtK,EAAKiD,KAC1E7F,KAAK6F,SAAWA,EAEZjD,EAAY5C,KAAK+K,eAAezD,EAAS+C,GAEtCrK,KAAKmN,WAAUvK,GAChBA,EAAYyH,EAAKzH,IAEjB0E,EAAQ0E,MAAMhM,KAAKgM,KAAK1E,EAAQ0E,OACV,IAAtB1E,EAAQyE,YAAkC,IAAXV,GAAiBrL,KAAKqH,OAAO+F,QAEzD/C,SAET,GACD/C,EAAQ8D,OAAS,EAAE,IAGxBpL,KAAKa,QAAQwM,GAAG,SAAUzK,GAAaC,EAAA,QAAaD,KAEpD5C,KAAKa,QAAQwM,GAAG,WAAYzK,IAE1B,IAA6D,IAAzDA,EAAI0K,QAAQC,QAAQ,gCAGxB,IAAsD,IAAlD3K,EAAI0K,QAAQC,QAAQ,yBAAxB,CAMA,IAAoD,IAAhD3K,EAAI0K,QAAQC,QAAQ,uBAGtB,OAFA1K,EAAA,QAAa,+DAEN7C,KAAKgL,WAAWhL,KAAKa,QAAY,GAAGiK,EADxB,CAAEiB,WAAW,EAAMC,KAAM1E,EAAQ0E,MACsB3B,IAI9B,IAA1CzH,EAAI0K,QAAQC,QAAQ,kBACtBvN,KAAKwN,YAAY5K,GAGnBC,EAAA,OAAYD,E,MAhBVC,EAAA,OAAYD,EAgBE,GAEpB,CAEQuK,UAAW9C,GACZA,IAAMA,EAAO,WAA0B,GAE5C,MAAMoD,EAAczN,KAAKqH,OAAOL,OAChC,YAAoBzE,IAAhBkL,EACKA,EAAYC,MAAK,IAAMrD,MACX7G,OAAOZ,IACN,IAAIA,EAAI0K,QAAQvH,SAAS,2DAWzB,OAPAlD,EAAA,OAAYD,GACZ5C,KAAKqH,OAAO+F,QACZpN,KAAKqH,OAAOoE,YAAYC,OACxB1L,KAAKqH,OAAOsE,YAAY,oBACxB3L,KAAKqH,OAAOsE,YAAY,mCACxB3L,KAAKqH,OAAOsE,YAAY,kCAEjBtB,GAAM,IAI5BA,GACT,CAEQ2B,KAAM2B,GACZ3N,KAAKqH,OAAOvB,YAAY6H,GACxB3N,KAAKqH,OAAOuG,mBACd,CAEQrD,mBAAoBsD,GAC1B,QAAwBtL,IAApBvC,KAAKyI,WAA0B,OACnC,GAA+B,IAA3BzI,KAAKyI,WAAWvH,OAAc,OAAOlB,KAAKyI,WAAW,GAEzD,MAAMwE,EAAQjN,KAAKyI,WAAWqF,QAAOhC,GAAyB,IAApBA,EAAE5B,WAAWhI,KACvD,GAAqB,IAAjB+K,EAAM/L,OAAc,OAGxB,GAAIlB,KAAKa,SAAqC,IAA1Bb,KAAKa,QAAQkN,UAAkB/N,KAAKqH,OAAO2G,QAAS,OAAOhO,KAAK+J,iBAE/E8D,IAAsBA,EAAuB7N,KAAKiO,iCAGvD,MAAMC,EAAelO,KAAK6I,cAAcsF,aAIxC,IAAIC,EAAgBnB,EAAM,GAAG/C,WAAWhI,GACxC,IAAK,IAAImM,EAAIpB,EAAM/L,OAAS,EAAGmN,GAAK,EAAGA,IAAK,CAC1C,MAAMlD,EAAe8B,EAAMoB,GAAGnE,WAAWhI,GACzC,GAAqB,IAAjBiJ,GAAsBA,GAAgB+C,EAAc,CACtDE,EAAgBjD,EAChB,K,EAKJ,MAAMmD,EAAgBrB,EAAMa,QAAOhC,GAAKA,EAAE5B,WAAWhI,IAAMkM,IAC/BN,QAAOhC,IACN,MAAMyC,EAAezC,EAAE0C,KAAOxO,KAAK0I,cACnC,IAAI+F,EAAYF,EAOhB,QAJKvO,KAAK+J,kBAAoB+B,EAAE5B,WAAWhI,GAAKlC,KAAK+J,iBAAiBG,WAAWhI,MAC/EuM,GAAeF,EAAcvO,KAAKwH,UAAUG,+BAAkC,KAGzEkG,EAAuBY,CAAS,IAIpE,OAA6B,IAAzBH,EAAcpN,QAAqB,QAAyB+L,IAEzD,QAAyBqB,EAClC,CAEQL,gCACN,MAAMS,EAAQpN,KAAKwL,IAAI9M,KAAKwI,eAAetH,OAASlB,KAAKwH,UAAUM,mCAAoC,GACjG6G,EAAqB3O,KAAKwI,eAAejF,MAAMmL,EAAO1O,KAAKwI,eAAetH,QAChF,GAAkC,IAA9ByN,EAAmBzN,OAAc,OAAQ,EAE7C,MAAM0N,EAAMD,EAAmBE,QAAO,CAACC,EAAGC,IAAMD,EAAIC,IAC9CC,EAAmB1N,KAAK2N,MAAML,EAAMD,EAAmBzN,QAK7D,OAFA,QAAqB8N,GAEdA,CACT,CAEQ5F,mBAGN,GAFApJ,KAAKkP,iBAE0B,IAA3BlP,KAAKyI,WAAWvH,OAElB,YADAlB,KAAKqH,OAAOmE,SAAS,YAIvB,GAAIxL,KAAK+G,SAGP,OAFA/G,KAAKqH,OAAOoE,YAAYF,OAEjBvL,KAAKmK,qBAAgB5H,EAAW,CAAEwJ,WAAW,EAAMC,KAAMhM,KAAKuH,YAIvE,MAAM4H,EAAUnP,KAAKqH,OAAOL,KAAKoI,KAAKpP,KAAKqH,QAC1CrH,KAAKqH,OAAeL,KAAO,KAC1BhH,KAAKqH,OAAOmE,SAAS,mCACrBxL,KAAKqH,OAAOL,KAAOmI,EAEnBnP,KAAKmK,qBAAgB5H,EAAW,CAAEwJ,WAAW,EAAMC,KAAMhM,KAAKuH,WAAY,CAE9E,CAEQiC,0BACNxJ,KAAK6J,oBAAsB7F,aAAY,KAGrC,GAAIhE,WAAKa,QAAgD,OACzD,IAA4B,IAAxBb,KAAKoI,eAA0B,OACnC,IAAyC,IAArCpI,KAAKsI,4BAAsC,OAE/C,MAAMlD,EAAOpF,KAAKuK,qBAClB,IAAI8E,GAAmB,EACnBC,EAAwB,EAGxBtP,KAAKuP,mBAAqBnK,EAAK8E,WAAWhI,GAAKlC,KAAK+J,iBAAiBG,WAAWhI,IAClFW,EAAA,OAAY,gDAAgDuC,EAAK8E,WAAWsF,SAC5EH,GAAmB,GACVjK,EAAK8E,WAAWhI,GAAKlC,KAAK+J,iBAAiBG,WAAWhI,KAC/DW,EAAA,OAAY,8CAA8CuC,EAAK8E,WAAWsF,SAC1EH,GAAmB,EACnBC,EAAwBtP,KAAKwH,UAAUK,uCAGhB,IAArBwH,IACFrP,KAAKkL,uBAAuB9F,EAAK8E,WAAWhI,GAAIoN,GAGhDtP,KAAKsI,6BAA8B,EAEnCtI,KAAK2J,wBAA0BvH,YAAW,KACxCpC,KAAKsI,6BAA8B,CAAK,GACvCtI,KAAKwH,UAAUI,+B,GAEnB5H,KAAKwH,UAAUE,uBACpB,CAEQ6H,kB,MACN,OAAkB,QAAX,EAAAvP,KAAKqH,cAAM,eAAEoI,SAAS,cAC/B,CAEQpG,0BACNrJ,KAAK4J,oBAAsB5F,aAAY,KAErC,QAAqBzB,IAAjBvC,KAAKa,QAGT,OAAqB,OAAjBb,KAAKa,QAAyBb,KAAKqH,OAAOqI,QAAQ,WAAW,IAG3B,IAAlC1P,KAAK+H,WAAW4H,eAAqB3P,KAAKwI,eAAevG,KAAKjC,KAAK+H,WAAW4H,eAE3E3P,KAAKqH,OAAOqI,QAAQ,UAAW,CACpCE,OAAQ,aACRC,KAAM,CACJF,cAAe,EACfG,YAAa,EACbC,WAAY,EACZC,SAAU,GAEZC,IAAK,CACHN,cAAe3P,KAAKa,QAAQ8O,cAC5BO,SAAUlQ,KAAKa,QAAQqP,SACvBJ,YAAa9P,KAAKa,QAAQiP,YAC1BC,WAAY/P,KAAKa,QAAQkP,WACzBC,SAAUhQ,KAAKa,QAAQmP,UAEzBG,kBAAmBnQ,KAAK+H,WAAW4H,gBACd,GACtB3P,KAAKwH,UAAUC,eACpB,CAEQsD,eAAgBzD,EAAsB+C,GAC5C,MAAMgB,EAASrL,KAAKqH,OAAOgE,SAE3BrL,KAAKmM,wBAELnM,KAAK8J,eAAe9J,KAAK+J,kBAAkB,GAC3C/J,KAAKa,QAAU,KAGfb,KAAKqH,OAAOiC,IAAI,SAAS,IAAMtJ,KAAKqH,OAAOqD,WAAW0F,sBAEtD,MAAMC,EAAUrQ,KAAK+J,iBAAiBuG,QAStC,OARAtQ,KAAKqH,OAAOuB,IAAM5I,KAAK2I,sBACvB3I,KAAKqH,OAAOuB,IAAIyH,GAEhBrQ,KAAKiL,6BAA4B,GAGjCjL,KAAKqH,OAAOqI,QAAQ,gBAEb1P,KAAKmN,WAAUvK,GAChBA,GAAOyH,EAAaA,EAAKzH,IAEzB0E,EAAQ0E,MAAMhM,KAAKgM,KAAK1E,EAAQ0E,OACV,IAAtB1E,EAAQyE,YAAkC,IAAXV,GAAiBrL,KAAKqH,OAAO+F,QAE5D/C,EAAaA,SAAjB,IAEJ,CAEQmD,YAAa5K,GACnB,OAAO5C,KAAKqH,OAAOqI,QAAQ,cAAe,CAAE9M,OAC9C,CAEQ4H,uBACN,GAA+B,IAA3BxK,KAAKyI,WAAWvH,OAAc,OAAOlB,KAAKyI,WAAW,GAEzD,MAAMwE,EAAQjN,KAAKyI,WAAWqF,QAAOhC,GAAyB,IAApBA,EAAE5B,WAAWhI,KACvD,OAAO+K,EAAM3L,KAAKiP,MAAMtD,EAAM/L,OAAS,GACzC,CAEQ6L,YAAalM,GACnBA,EAAQuM,QAERvM,EAAQ2P,WAAW3P,EAAY,GACjC,CAEQmM,wBAAyB5H,EAA8BgG,GAC7DpL,KAAKmI,wBAAyB,EAE9B,MAAMsI,EAAgBC,SAASC,cAAc,SAC7CxL,EAAYC,EAAMqL,EAAe,CAAE1J,UAAU,EAAOmG,UAAU,IAAS,CAACtK,EAAKiD,KAC3E7F,KAAK4Q,aAAe/K,GAGgB,IAAhC7F,KAAKmI,wBAAoCvF,GAC3CC,EAAA,QAAa,mDAAoDD,GAInE6N,EAAc3K,YAAc9F,KAAKqH,OAAOvB,eAAiBsF,EAAQ,IAAK,GAE1E,CAEQpB,sBACN,GAAIhK,KAAK4Q,aAAc,CAGrB,GAFA5Q,KAAKmI,wBAAyB,EAE1BnI,KAAK4Q,aAAalN,QACpB,IACE1D,KAAK4Q,aAAalN,S,CAClB,MAAOd,GACPC,EAAA,OAAY,0CAA2CD,E,CAG3D5C,KAAK4Q,kBAAerO,C,CAExB,CAEQ2M,iBACN,MAAM2B,EAAoC7Q,KAAKyI,WAAW/F,KAAI0C,IAAQ,CACpElD,GAAIkD,EAAK8E,WAAWhI,GACpBsN,MAAOxP,KAAK8Q,kBAAkB1L,GAC9B2L,OAAQ3L,EAAK8E,WAAWhI,GACxB8O,UAAU,EACVC,eAAgB,IAAMjR,KAAKwM,cAAcpH,EAAK8E,WAAWhI,QAG3D2O,EAAY5O,KAAK,CACfC,IAAK,EACLsN,MAAOxP,KAAKqH,OAAO6J,SAAS,QAC5BF,UAAU,EACVC,eAAgB,IAAMjR,KAAKwM,eAAe,KAG5CxM,KAAKqH,OAAO+E,sBAAsBO,IAAIkE,EACxC,CAEQC,kBAAmB1L,GACzB,IAAIoK,EAAQpK,EAAK8E,WAAWsF,MAM5B,OAJIpK,EAAK+L,KAAO/L,EAAK+L,KAAO,KAC1B3B,GAASpK,EAAK+L,KAGT3B,CACT,CAEQvE,4BAA6BmG,GACnC,MAAMlH,EAAalK,KAAKoI,gBACnB,EACDpI,KAAKiK,yBAEHoH,EAAuBrR,KAAKoI,eAC9BpI,KAAKiK,8BACL1H,EAEJvC,KAAKqH,OAAO+E,sBAAsBkF,OAAO,CAAEpP,GAAIgI,EAAYqH,uBAAwBF,EAAsBD,YAC3G,EAGF,mBAAuB,aAAchK,E,8BCroBrCoK,EAAOC,QAAU,EAAjB,K,8BCAAD,EAAOC,QAAU,EAAjB,K,yDCEO,MAAMC,EAAO,C,8BCFpBF,EAAOC,QAAU,EAAjB,K","sources":["webpack://peertube-client/./src/assets/player/shared/webtorrent/peertube-chunk-store.ts","webpack://peertube-client/./src/assets/player/shared/webtorrent/video-renderer.ts","webpack://peertube-client/./src/assets/player/shared/webtorrent/webtorrent-plugin.ts","webpack://peertube-client/./src/shims/http.ts","webpack://peertube-client/./src/shims/https.ts","webpack://peertube-client/./src/shims/noop.ts","webpack://peertube-client/./src/shims/stream.ts"],"sourcesContent":["// From https://github.com/MinEduTDF/idb-chunk-store\r\n// We use temporary IndexDB (all data are removed on destroy) to avoid RAM issues\r\n// Thanks @santiagogil and @Feross\r\n\r\nimport Dexie from 'dexie'\r\nimport { EventEmitter } from 'events'\r\nimport { logger } from '@root-helpers/logger'\r\n\r\nclass ChunkDatabase extends Dexie {\r\n  chunks: Dexie.Table<{ id: number, buf: Buffer }, number>\r\n\r\n  constructor (dbname: string) {\r\n    super(dbname)\r\n\r\n    this.version(1).stores({\r\n      chunks: 'id'\r\n    })\r\n  }\r\n}\r\n\r\nclass ExpirationDatabase extends Dexie {\r\n  databases: Dexie.Table<{ name: string, expiration: number }, number>\r\n\r\n  constructor () {\r\n    super('webtorrent-expiration')\r\n\r\n    this.version(1).stores({\r\n      databases: 'name,expiration'\r\n    })\r\n  }\r\n}\r\n\r\nexport class PeertubeChunkStore extends EventEmitter {\r\n  private static readonly BUFFERING_PUT_MS = 1000\r\n  private static readonly CLEANER_INTERVAL_MS = 1000 * 60 // 1 minute\r\n  private static readonly CLEANER_EXPIRATION_MS = 1000 * 60 * 5 // 5 minutes\r\n\r\n  chunkLength: number\r\n\r\n  private pendingPut: { id: number, buf: Buffer, cb: (err?: Error) => void }[] = []\r\n  // If the store is full\r\n  private memoryChunks: { [ id: number ]: Buffer | true } = {}\r\n  private databaseName: string\r\n  private putBulkTimeout: any\r\n  private cleanerInterval: any\r\n  private db: ChunkDatabase\r\n  private expirationDB: ExpirationDatabase\r\n  private readonly length: number\r\n  private readonly lastChunkLength: number\r\n  private readonly lastChunkIndex: number\r\n\r\n  constructor (chunkLength: number, opts: any) {\r\n    super()\r\n\r\n    this.databaseName = 'webtorrent-chunks-'\r\n\r\n    if (!opts) opts = {}\r\n    if (opts.torrent?.infoHash) this.databaseName += opts.torrent.infoHash\r\n    else this.databaseName += '-default'\r\n\r\n    this.setMaxListeners(100)\r\n\r\n    this.chunkLength = Number(chunkLength)\r\n    if (!this.chunkLength) throw new Error('First argument must be a chunk length')\r\n\r\n    this.length = Number(opts.length) || Infinity\r\n\r\n    if (this.length !== Infinity) {\r\n      this.lastChunkLength = (this.length % this.chunkLength) || this.chunkLength\r\n      this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1\r\n    }\r\n\r\n    this.db = new ChunkDatabase(this.databaseName)\r\n    // Track databases that expired\r\n    this.expirationDB = new ExpirationDatabase()\r\n\r\n    this.runCleaner()\r\n  }\r\n\r\n  put (index: number, buf: Buffer, cb: (err?: Error) => void) {\r\n    const isLastChunk = (index === this.lastChunkIndex)\r\n    if (isLastChunk && buf.length !== this.lastChunkLength) {\r\n      return this.nextTick(cb, new Error('Last chunk length must be ' + this.lastChunkLength))\r\n    }\r\n    if (!isLastChunk && buf.length !== this.chunkLength) {\r\n      return this.nextTick(cb, new Error('Chunk length must be ' + this.chunkLength))\r\n    }\r\n\r\n    // Specify we have this chunk\r\n    this.memoryChunks[index] = true\r\n\r\n    // Add it to the pending put\r\n    this.pendingPut.push({ id: index, buf, cb })\r\n    // If it's already planned, return\r\n    if (this.putBulkTimeout) return\r\n\r\n    // Plan a future bulk insert\r\n    this.putBulkTimeout = setTimeout(async () => {\r\n      const processing = this.pendingPut\r\n      this.pendingPut = []\r\n      this.putBulkTimeout = undefined\r\n\r\n      try {\r\n        await this.db.transaction('rw', this.db.chunks, () => {\r\n          return this.db.chunks.bulkPut(processing.map(p => ({ id: p.id, buf: p.buf })))\r\n        })\r\n      } catch (err) {\r\n        logger.info('Cannot bulk insert chunks. Store them in memory.', err)\r\n\r\n        processing.forEach(p => {\r\n          this.memoryChunks[p.id] = p.buf\r\n        })\r\n      } finally {\r\n        processing.forEach(p => p.cb())\r\n      }\r\n    }, PeertubeChunkStore.BUFFERING_PUT_MS)\r\n  }\r\n\r\n  get (index: number, opts: any, cb: (err?: Error, buf?: Buffer) => void): void {\r\n    if (typeof opts === 'function') return this.get(index, null, opts)\r\n\r\n    // IndexDB could be slow, use our memory index first\r\n    const memoryChunk = this.memoryChunks[index]\r\n    if (memoryChunk === undefined) {\r\n      const err = new Error('Chunk not found') as any\r\n      err['notFound'] = true\r\n\r\n      return process.nextTick(() => cb(err))\r\n    }\r\n\r\n    // Chunk in memory\r\n    if (memoryChunk !== true) return cb(null, memoryChunk)\r\n\r\n    // Chunk in store\r\n    this.db.transaction('r', this.db.chunks, async () => {\r\n      const result = await this.db.chunks.get({ id: index })\r\n      if (result === undefined) return cb(null, Buffer.alloc(0))\r\n\r\n      const buf = result.buf\r\n      if (!opts) return this.nextTick(cb, null, buf)\r\n\r\n      const offset = opts.offset || 0\r\n      const len = opts.length || (buf.length - offset)\r\n      return cb(null, buf.slice(offset, len + offset))\r\n    })\r\n    .catch(err => {\r\n      logger.error(err)\r\n      return cb(err)\r\n    })\r\n  }\r\n\r\n  close (cb: (err?: Error) => void) {\r\n    return this.destroy(cb)\r\n  }\r\n\r\n  async destroy (cb: (err?: Error) => void) {\r\n    try {\r\n      if (this.pendingPut) {\r\n        clearTimeout(this.putBulkTimeout)\r\n        this.pendingPut = null\r\n      }\r\n      if (this.cleanerInterval) {\r\n        clearInterval(this.cleanerInterval)\r\n        this.cleanerInterval = null\r\n      }\r\n\r\n      if (this.db) {\r\n        this.db.close()\r\n\r\n        await this.dropDatabase(this.databaseName)\r\n      }\r\n\r\n      if (this.expirationDB) {\r\n        this.expirationDB.close()\r\n        this.expirationDB = null\r\n      }\r\n\r\n      return cb()\r\n    } catch (err) {\r\n      logger.error('Cannot destroy peertube chunk store.', err)\r\n      return cb(err)\r\n    }\r\n  }\r\n\r\n  private runCleaner () {\r\n    this.checkExpiration()\r\n\r\n    this.cleanerInterval = setInterval(() => {\r\n      this.checkExpiration()\r\n    }, PeertubeChunkStore.CLEANER_INTERVAL_MS)\r\n  }\r\n\r\n  private async checkExpiration () {\r\n    let databasesToDeleteInfo: { name: string }[] = []\r\n\r\n    try {\r\n      await this.expirationDB.transaction('rw', this.expirationDB.databases, async () => {\r\n        // Update our database expiration since we are alive\r\n        await this.expirationDB.databases.put({\r\n          name: this.databaseName,\r\n          expiration: new Date().getTime() + PeertubeChunkStore.CLEANER_EXPIRATION_MS\r\n        })\r\n\r\n        const now = new Date().getTime()\r\n        databasesToDeleteInfo = await this.expirationDB.databases.where('expiration').below(now).toArray()\r\n      })\r\n    } catch (err) {\r\n      logger.error('Cannot update expiration of fetch expired databases.', err)\r\n    }\r\n\r\n    for (const databaseToDeleteInfo of databasesToDeleteInfo) {\r\n      await this.dropDatabase(databaseToDeleteInfo.name)\r\n    }\r\n  }\r\n\r\n  private async dropDatabase (databaseName: string) {\r\n    const dbToDelete = new ChunkDatabase(databaseName)\r\n    logger.info(`Destroying IndexDB database ${databaseName}`)\r\n\r\n    try {\r\n      await dbToDelete.delete()\r\n\r\n      await this.expirationDB.transaction('rw', this.expirationDB.databases, () => {\r\n        return this.expirationDB.databases.where({ name: databaseName }).delete()\r\n      })\r\n    } catch (err) {\r\n      logger.error(`Cannot delete ${databaseName}.`, err)\r\n    }\r\n  }\r\n\r\n  private nextTick <T> (cb: (err?: Error, val?: T) => void, err: Error, val?: T) {\r\n    process.nextTick(() => cb(err, val), undefined)\r\n  }\r\n}\r\n","// Thanks: https://github.com/feross/render-media\r\n\r\nconst MediaElementWrapper = require('mediasource')\r\nimport { logger } from '@root-helpers/logger'\r\nimport { extname } from 'path'\r\nconst Videostream = require('videostream')\r\n\r\nconst VIDEOSTREAM_EXTS = [\r\n  '.m4a',\r\n  '.m4v',\r\n  '.mp4'\r\n]\r\n\r\ntype RenderMediaOptions = {\r\n  controls: boolean\r\n  autoplay: boolean\r\n}\r\n\r\nfunction renderVideo (\r\n  file: any,\r\n  elem: HTMLVideoElement,\r\n  opts: RenderMediaOptions,\r\n  callback: (err: Error, renderer: any) => void\r\n) {\r\n  validateFile(file)\r\n\r\n  return renderMedia(file, elem, opts, callback)\r\n}\r\n\r\nfunction renderMedia (file: any, elem: HTMLVideoElement, opts: RenderMediaOptions, callback: (err: Error, renderer?: any) => void) {\r\n  const extension = extname(file.name).toLowerCase()\r\n  let preparedElem: any\r\n  let currentTime = 0\r\n  let renderer: any\r\n\r\n  try {\r\n    if (VIDEOSTREAM_EXTS.includes(extension)) {\r\n      renderer = useVideostream()\r\n    } else {\r\n      renderer = useMediaSource()\r\n    }\r\n  } catch (err) {\r\n    return callback(err)\r\n  }\r\n\r\n  function useVideostream () {\r\n    prepareElem()\r\n    preparedElem.addEventListener('error', function onError (err: Error) {\r\n      preparedElem.removeEventListener('error', onError)\r\n\r\n      return callback(err)\r\n    })\r\n    preparedElem.addEventListener('loadstart', onLoadStart)\r\n    return new Videostream(file, preparedElem)\r\n  }\r\n\r\n  function useMediaSource (useVP9 = false) {\r\n    const codecs = getCodec(file.name, useVP9)\r\n\r\n    prepareElem()\r\n    preparedElem.addEventListener('error', function onError (err: Error) {\r\n      preparedElem.removeEventListener('error', onError)\r\n\r\n      // Try with vp9 before returning an error\r\n      if (codecs.includes('vp8')) return fallbackToMediaSource(true)\r\n\r\n      return callback(err)\r\n    })\r\n    preparedElem.addEventListener('loadstart', onLoadStart)\r\n\r\n    const wrapper = new MediaElementWrapper(preparedElem)\r\n    const writable = wrapper.createWriteStream(codecs)\r\n    file.createReadStream().pipe(writable)\r\n\r\n    if (currentTime) preparedElem.currentTime = currentTime\r\n\r\n    return wrapper\r\n  }\r\n\r\n  function fallbackToMediaSource (useVP9 = false) {\r\n    if (useVP9 === true) logger.info('Falling back to media source with VP9 enabled.')\r\n    else logger.info('Falling back to media source..')\r\n\r\n    useMediaSource(useVP9)\r\n  }\r\n\r\n  function prepareElem () {\r\n    if (preparedElem === undefined) {\r\n      preparedElem = elem\r\n\r\n      preparedElem.addEventListener('progress', function () {\r\n        currentTime = elem.currentTime\r\n      })\r\n    }\r\n  }\r\n\r\n  function onLoadStart () {\r\n    preparedElem.removeEventListener('loadstart', onLoadStart)\r\n    if (opts.autoplay) preparedElem.play()\r\n\r\n    callback(null, renderer)\r\n  }\r\n}\r\n\r\nfunction validateFile (file: any) {\r\n  if (file == null) {\r\n    throw new Error('file cannot be null or undefined')\r\n  }\r\n  if (typeof file.name !== 'string') {\r\n    throw new Error('missing or invalid file.name property')\r\n  }\r\n  if (typeof file.createReadStream !== 'function') {\r\n    throw new Error('missing or invalid file.createReadStream property')\r\n  }\r\n}\r\n\r\nfunction getCodec (name: string, useVP9 = false) {\r\n  const ext = extname(name).toLowerCase()\r\n  if (ext === '.mp4') {\r\n    return 'video/mp4; codecs=\"avc1.640029, mp4a.40.5\"'\r\n  }\r\n\r\n  if (ext === '.webm') {\r\n    if (useVP9 === true) return 'video/webm; codecs=\"vp9, opus\"'\r\n\r\n    return 'video/webm; codecs=\"vp8, vorbis\"'\r\n  }\r\n\r\n  return undefined\r\n}\r\n\r\nexport {\r\n  renderVideo\r\n}\r\n","import videojs from 'video.js'\r\nimport * as WebTorrent from 'webtorrent'\r\nimport { logger } from '@root-helpers/logger'\r\nimport { isIOS } from '@root-helpers/web-browser'\r\nimport { timeToInt } from '@shared/core-utils'\r\nimport { VideoFile } from '@shared/models'\r\nimport { getAverageBandwidthInStore, getStoredMute, getStoredVolume, saveAverageBandwidth } from '../../peertube-player-local-storage'\r\nimport { PeerTubeResolution, PlayerNetworkInfo, WebtorrentPluginOptions } from '../../types'\r\nimport { getRtcConfig, videoFileMaxByResolution, videoFileMinByResolution } from '../common'\r\nimport { PeertubeChunkStore } from './peertube-chunk-store'\r\nimport { renderVideo } from './video-renderer'\r\n\r\nconst CacheChunkStore = require('cache-chunk-store')\r\n\r\ntype PlayOptions = {\r\n  forcePlay?: boolean\r\n  seek?: number\r\n  delay?: number\r\n}\r\n\r\nconst Plugin = videojs.getPlugin('plugin')\r\n\r\nclass WebTorrentPlugin extends Plugin {\r\n  readonly videoFiles: VideoFile[]\r\n\r\n  private readonly playerElement: HTMLVideoElement\r\n\r\n  private readonly autoplay: boolean = false\r\n  private readonly startTime: number = 0\r\n  private readonly savePlayerSrcFunction: videojs.Player['src']\r\n  private readonly videoDuration: number\r\n  private readonly CONSTANTS = {\r\n    INFO_SCHEDULER: 1000, // Don't change this\r\n    AUTO_QUALITY_SCHEDULER: 3000, // Check quality every 3 seconds\r\n    AUTO_QUALITY_THRESHOLD_PERCENT: 30, // Bandwidth should be 30% more important than a resolution bitrate to change to it\r\n    AUTO_QUALITY_OBSERVATION_TIME: 10000, // Wait 10 seconds after having change the resolution before another check\r\n    AUTO_QUALITY_HIGHER_RESOLUTION_DELAY: 5000, // Buffering higher resolution during 5 seconds\r\n    BANDWIDTH_AVERAGE_NUMBER_OF_VALUES: 5 // Last 5 seconds to build average bandwidth\r\n  }\r\n\r\n  private readonly webtorrent = new WebTorrent({\r\n    tracker: {\r\n      rtcConfig: getRtcConfig()\r\n    },\r\n    dht: false\r\n  })\r\n\r\n  private currentVideoFile: VideoFile\r\n  private torrent: WebTorrent.Torrent\r\n\r\n  private renderer: any\r\n  private fakeRenderer: any\r\n  private destroyingFakeRenderer = false\r\n\r\n  private autoResolution = true\r\n  private autoResolutionPossible = true\r\n  private isAutoResolutionObservation = false\r\n  private playerRefusedP2P = false\r\n\r\n  private torrentInfoInterval: any\r\n  private autoQualityInterval: any\r\n  private addTorrentDelay: any\r\n  private qualityObservationTimer: any\r\n  private runAutoQualitySchedulerTimer: any\r\n\r\n  private downloadSpeeds: number[] = []\r\n\r\n  constructor (player: videojs.Player, options?: WebtorrentPluginOptions) {\r\n    super(player)\r\n\r\n    this.startTime = timeToInt(options.startTime)\r\n\r\n    // Custom autoplay handled by webtorrent because we lazy play the video\r\n    this.autoplay = options.autoplay\r\n\r\n    this.playerRefusedP2P = options.playerRefusedP2P\r\n\r\n    this.videoFiles = options.videoFiles\r\n    this.videoDuration = options.videoDuration\r\n\r\n    this.savePlayerSrcFunction = this.player.src\r\n    this.playerElement = options.playerElement\r\n\r\n    this.player.ready(() => {\r\n      const playerOptions = this.player.options_\r\n\r\n      const volume = getStoredVolume()\r\n      if (volume !== undefined) this.player.volume(volume)\r\n\r\n      const muted = playerOptions.muted !== undefined ? playerOptions.muted : getStoredMute()\r\n      if (muted !== undefined) this.player.muted(muted)\r\n\r\n      this.player.duration(options.videoDuration)\r\n\r\n      this.initializePlayer()\r\n      this.runTorrentInfoScheduler()\r\n\r\n      this.player.one('play', () => {\r\n        // Don't run immediately scheduler, wait some seconds the TCP connections are made\r\n        this.runAutoQualitySchedulerTimer = setTimeout(() => this.runAutoQualityScheduler(), this.CONSTANTS.AUTO_QUALITY_SCHEDULER)\r\n      })\r\n    })\r\n  }\r\n\r\n  dispose () {\r\n    clearTimeout(this.addTorrentDelay)\r\n    clearTimeout(this.qualityObservationTimer)\r\n    clearTimeout(this.runAutoQualitySchedulerTimer)\r\n\r\n    clearInterval(this.torrentInfoInterval)\r\n    clearInterval(this.autoQualityInterval)\r\n\r\n    // Don't need to destroy renderer, video player will be destroyed\r\n    this.flushVideoFile(this.currentVideoFile, false)\r\n\r\n    this.destroyFakeRenderer()\r\n  }\r\n\r\n  getCurrentResolutionId () {\r\n    return this.currentVideoFile ? this.currentVideoFile.resolution.id : -1\r\n  }\r\n\r\n  updateVideoFile (\r\n    videoFile?: VideoFile,\r\n    options: {\r\n      forcePlay?: boolean\r\n      seek?: number\r\n      delay?: number\r\n    } = {},\r\n    done: () => void = () => { /* empty */ }\r\n  ) {\r\n    // Automatically choose the adapted video file\r\n    if (!videoFile) {\r\n      const savedAverageBandwidth = getAverageBandwidthInStore()\r\n      videoFile = savedAverageBandwidth\r\n        ? this.getAppropriateFile(savedAverageBandwidth)\r\n        : this.pickAverageVideoFile()\r\n    }\r\n\r\n    if (!videoFile) {\r\n      throw Error(`Can't update video file since videoFile is undefined.`)\r\n    }\r\n\r\n    // Don't add the same video file once again\r\n    if (this.currentVideoFile !== undefined && this.currentVideoFile.magnetUri === videoFile.magnetUri) {\r\n      return\r\n    }\r\n\r\n    // Do not display error to user because we will have multiple fallback\r\n    this.player.peertube().hideFatalError();\r\n\r\n    // Hack to \"simulate\" src link in video.js >= 6\r\n    // Without this, we can't play the video after pausing it\r\n    // https://github.com/videojs/video.js/blob/master/src/js/player.js#L1633\r\n    (this.player as any).src = () => true\r\n    const oldPlaybackRate = this.player.playbackRate()\r\n\r\n    const previousVideoFile = this.currentVideoFile\r\n    this.currentVideoFile = videoFile\r\n\r\n    // Don't try on iOS that does not support MediaSource\r\n    // Or don't use P2P if webtorrent is disabled\r\n    if (isIOS() || this.playerRefusedP2P) {\r\n      return this.fallbackToHttp(options, () => {\r\n        this.player.playbackRate(oldPlaybackRate)\r\n        return done()\r\n      })\r\n    }\r\n\r\n    this.addTorrent(this.currentVideoFile.magnetUri, previousVideoFile, options, () => {\r\n      this.player.playbackRate(oldPlaybackRate)\r\n      return done()\r\n    })\r\n\r\n    this.selectAppropriateResolution(true)\r\n  }\r\n\r\n  updateEngineResolution (resolutionId: number, delay = 0) {\r\n    // Remember player state\r\n    const currentTime = this.player.currentTime()\r\n    const isPaused = this.player.paused()\r\n\r\n    // Hide bigPlayButton\r\n    if (!isPaused) {\r\n      this.player.bigPlayButton.hide()\r\n    }\r\n\r\n    // Audio-only (resolutionId === 0) gets special treatment\r\n    if (resolutionId === 0) {\r\n      // Audio-only: show poster, do not auto-hide controls\r\n      this.player.addClass('vjs-playing-audio-only-content')\r\n      this.player.posterImage.show()\r\n    } else {\r\n      // Hide poster to have black background\r\n      this.player.removeClass('vjs-playing-audio-only-content')\r\n      this.player.posterImage.hide()\r\n    }\r\n\r\n    const newVideoFile = this.videoFiles.find(f => f.resolution.id === resolutionId)\r\n    const options = {\r\n      forcePlay: false,\r\n      delay,\r\n      seek: currentTime + (delay / 1000)\r\n    }\r\n\r\n    this.updateVideoFile(newVideoFile, options)\r\n  }\r\n\r\n  flushVideoFile (videoFile: VideoFile, destroyRenderer = true) {\r\n    if (videoFile !== undefined && this.webtorrent.get(videoFile.magnetUri)) {\r\n      if (destroyRenderer === true && this.renderer && this.renderer.destroy) this.renderer.destroy()\r\n\r\n      this.webtorrent.remove(videoFile.magnetUri)\r\n      logger.info(`Removed ${videoFile.magnetUri}`)\r\n    }\r\n  }\r\n\r\n  disableAutoResolution () {\r\n    this.autoResolution = false\r\n    this.autoResolutionPossible = false\r\n    this.player.peertubeResolutions().disableAutoResolution()\r\n  }\r\n\r\n  isAutoResolutionPossible () {\r\n    return this.autoResolutionPossible\r\n  }\r\n\r\n  getTorrent () {\r\n    return this.torrent\r\n  }\r\n\r\n  getCurrentVideoFile () {\r\n    return this.currentVideoFile\r\n  }\r\n\r\n  changeQuality (id: number) {\r\n    if (id === -1) {\r\n      if (this.autoResolutionPossible === true) {\r\n        this.autoResolution = true\r\n\r\n        this.selectAppropriateResolution(false)\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    this.autoResolution = false\r\n    this.updateEngineResolution(id)\r\n    this.selectAppropriateResolution(false)\r\n  }\r\n\r\n  private addTorrent (\r\n    magnetOrTorrentUrl: string,\r\n    previousVideoFile: VideoFile,\r\n    options: PlayOptions,\r\n    done: (err?: Error) => void\r\n  ) {\r\n    if (!magnetOrTorrentUrl) return this.fallbackToHttp(options, done)\r\n\r\n    logger.info(`Adding ${magnetOrTorrentUrl}.`)\r\n\r\n    const oldTorrent = this.torrent\r\n    const torrentOptions = {\r\n      // Don't use arrow function: it breaks webtorrent (that uses `new` keyword)\r\n      store: function (chunkLength: number, storeOpts: any) {\r\n        return new CacheChunkStore(new PeertubeChunkStore(chunkLength, storeOpts), {\r\n          max: 100\r\n        })\r\n      }\r\n    }\r\n\r\n    this.torrent = this.webtorrent.add(magnetOrTorrentUrl, torrentOptions, torrent => {\r\n      logger.info(`Added ${magnetOrTorrentUrl}.`)\r\n\r\n      if (oldTorrent) {\r\n        // Pause the old torrent\r\n        this.stopTorrent(oldTorrent)\r\n\r\n        // We use a fake renderer so we download correct pieces of the next file\r\n        if (options.delay) this.renderFileInFakeElement(torrent.files[0], options.delay)\r\n      }\r\n\r\n      // Render the video in a few seconds? (on resolution change for example, we wait some seconds of the new video resolution)\r\n      this.addTorrentDelay = setTimeout(() => {\r\n        // We don't need the fake renderer anymore\r\n        this.destroyFakeRenderer()\r\n\r\n        const paused = this.player.paused()\r\n\r\n        this.flushVideoFile(previousVideoFile)\r\n\r\n        // Update progress bar (just for the UI), do not wait rendering\r\n        if (options.seek) this.player.currentTime(options.seek)\r\n\r\n        const renderVideoOptions = { autoplay: false, controls: true }\r\n        renderVideo(torrent.files[0], this.playerElement, renderVideoOptions, (err, renderer) => {\r\n          this.renderer = renderer\r\n\r\n          if (err) return this.fallbackToHttp(options, done)\r\n\r\n          return this.tryToPlay(err => {\r\n            if (err) return done(err)\r\n\r\n            if (options.seek) this.seek(options.seek)\r\n            if (options.forcePlay === false && paused === true) this.player.pause()\r\n\r\n            return done()\r\n          })\r\n        })\r\n      }, options.delay || 0)\r\n    })\r\n\r\n    this.torrent.on('error', (err: any) => logger.error(err))\r\n\r\n    this.torrent.on('warning', (err: any) => {\r\n      // We don't support HTTP tracker but we don't care -> we use the web socket tracker\r\n      if (err.message.indexOf('Unsupported tracker protocol') !== -1) return\r\n\r\n      // Users don't care about issues with WebRTC, but developers do so log it in the console\r\n      if (err.message.indexOf('Ice connection failed') !== -1) {\r\n        logger.info(err)\r\n        return\r\n      }\r\n\r\n      // Magnet hash is not up to date with the torrent file, add directly the torrent file\r\n      if (err.message.indexOf('incorrect info hash') !== -1) {\r\n        logger.error('Incorrect info hash detected, falling back to torrent file.')\r\n        const newOptions = { forcePlay: true, seek: options.seek }\r\n        return this.addTorrent(this.torrent['xs'], previousVideoFile, newOptions, done)\r\n      }\r\n\r\n      // Remote instance is down\r\n      if (err.message.indexOf('from xs param') !== -1) {\r\n        this.handleError(err)\r\n      }\r\n\r\n      logger.warn(err)\r\n    })\r\n  }\r\n\r\n  private tryToPlay (done?: (err?: Error) => void) {\r\n    if (!done) done = function () { /* empty */ }\r\n\r\n    const playPromise = this.player.play()\r\n    if (playPromise !== undefined) {\r\n      return playPromise.then(() => done())\r\n                        .catch((err: Error) => {\r\n                          if (err.message.includes('The play() request was interrupted by a call to pause()')) {\r\n                            return\r\n                          }\r\n\r\n                          logger.warn(err)\r\n                          this.player.pause()\r\n                          this.player.posterImage.show()\r\n                          this.player.removeClass('vjs-has-autoplay')\r\n                          this.player.removeClass('vjs-has-big-play-button-clicked')\r\n                          this.player.removeClass('vjs-playing-audio-only-content')\r\n\r\n                          return done()\r\n                        })\r\n    }\r\n\r\n    return done()\r\n  }\r\n\r\n  private seek (time: number) {\r\n    this.player.currentTime(time)\r\n    this.player.handleTechSeeked_()\r\n  }\r\n\r\n  private getAppropriateFile (averageDownloadSpeed?: number): VideoFile {\r\n    if (this.videoFiles === undefined) return undefined\r\n    if (this.videoFiles.length === 1) return this.videoFiles[0]\r\n\r\n    const files = this.videoFiles.filter(f => f.resolution.id !== 0)\r\n    if (files.length === 0) return undefined\r\n\r\n    // Don't change the torrent if the player ended\r\n    if (this.torrent && this.torrent.progress === 1 && this.player.ended()) return this.currentVideoFile\r\n\r\n    if (!averageDownloadSpeed) averageDownloadSpeed = this.getAndSaveActualDownloadSpeed()\r\n\r\n    // Limit resolution according to player height\r\n    const playerHeight = this.playerElement.offsetHeight\r\n\r\n    // We take the first resolution just above the player height\r\n    // Example: player height is 530px, we want the 720p file instead of 480p\r\n    let maxResolution = files[0].resolution.id\r\n    for (let i = files.length - 1; i >= 0; i--) {\r\n      const resolutionId = files[i].resolution.id\r\n      if (resolutionId !== 0 && resolutionId >= playerHeight) {\r\n        maxResolution = resolutionId\r\n        break\r\n      }\r\n    }\r\n\r\n    // Filter videos we can play according to our screen resolution and bandwidth\r\n    const filteredFiles = files.filter(f => f.resolution.id <= maxResolution)\r\n                               .filter(f => {\r\n                                 const fileBitrate = (f.size / this.videoDuration)\r\n                                 let threshold = fileBitrate\r\n\r\n                                 // If this is for a higher resolution or an initial load: add a margin\r\n                                 if (!this.currentVideoFile || f.resolution.id > this.currentVideoFile.resolution.id) {\r\n                                   threshold += ((fileBitrate * this.CONSTANTS.AUTO_QUALITY_THRESHOLD_PERCENT) / 100)\r\n                                 }\r\n\r\n                                 return averageDownloadSpeed > threshold\r\n                               })\r\n\r\n    // If the download speed is too bad, return the lowest resolution we have\r\n    if (filteredFiles.length === 0) return videoFileMinByResolution(files)\r\n\r\n    return videoFileMaxByResolution(filteredFiles)\r\n  }\r\n\r\n  private getAndSaveActualDownloadSpeed () {\r\n    const start = Math.max(this.downloadSpeeds.length - this.CONSTANTS.BANDWIDTH_AVERAGE_NUMBER_OF_VALUES, 0)\r\n    const lastDownloadSpeeds = this.downloadSpeeds.slice(start, this.downloadSpeeds.length)\r\n    if (lastDownloadSpeeds.length === 0) return -1\r\n\r\n    const sum = lastDownloadSpeeds.reduce((a, b) => a + b)\r\n    const averageBandwidth = Math.round(sum / lastDownloadSpeeds.length)\r\n\r\n    // Save the average bandwidth for future use\r\n    saveAverageBandwidth(averageBandwidth)\r\n\r\n    return averageBandwidth\r\n  }\r\n\r\n  private initializePlayer () {\r\n    this.buildQualities()\r\n\r\n    if (this.videoFiles.length === 0) {\r\n      this.player.addClass('disabled')\r\n      return\r\n    }\r\n\r\n    if (this.autoplay) {\r\n      this.player.posterImage.hide()\r\n\r\n      return this.updateVideoFile(undefined, { forcePlay: true, seek: this.startTime })\r\n    }\r\n\r\n    // Proxy first play\r\n    const oldPlay = this.player.play.bind(this.player);\r\n    (this.player as any).play = () => {\r\n      this.player.addClass('vjs-has-big-play-button-clicked')\r\n      this.player.play = oldPlay\r\n\r\n      this.updateVideoFile(undefined, { forcePlay: true, seek: this.startTime })\r\n    }\r\n  }\r\n\r\n  private runAutoQualityScheduler () {\r\n    this.autoQualityInterval = setInterval(() => {\r\n\r\n      // Not initialized or in HTTP fallback\r\n      if (this.torrent === undefined || this.torrent === null) return\r\n      if (this.autoResolution === false) return\r\n      if (this.isAutoResolutionObservation === true) return\r\n\r\n      const file = this.getAppropriateFile()\r\n      let changeResolution = false\r\n      let changeResolutionDelay = 0\r\n\r\n      // Lower resolution\r\n      if (this.isPlayerWaiting() && file.resolution.id < this.currentVideoFile.resolution.id) {\r\n        logger.info(`Downgrading automatically the resolution to: ${file.resolution.label}`)\r\n        changeResolution = true\r\n      } else if (file.resolution.id > this.currentVideoFile.resolution.id) { // Higher resolution\r\n        logger.info(`Upgrading automatically the resolution to: ${file.resolution.label}`)\r\n        changeResolution = true\r\n        changeResolutionDelay = this.CONSTANTS.AUTO_QUALITY_HIGHER_RESOLUTION_DELAY\r\n      }\r\n\r\n      if (changeResolution === true) {\r\n        this.updateEngineResolution(file.resolution.id, changeResolutionDelay)\r\n\r\n        // Wait some seconds in observation of our new resolution\r\n        this.isAutoResolutionObservation = true\r\n\r\n        this.qualityObservationTimer = setTimeout(() => {\r\n          this.isAutoResolutionObservation = false\r\n        }, this.CONSTANTS.AUTO_QUALITY_OBSERVATION_TIME)\r\n      }\r\n    }, this.CONSTANTS.AUTO_QUALITY_SCHEDULER)\r\n  }\r\n\r\n  private isPlayerWaiting () {\r\n    return this.player?.hasClass('vjs-waiting')\r\n  }\r\n\r\n  private runTorrentInfoScheduler () {\r\n    this.torrentInfoInterval = setInterval(() => {\r\n      // Not initialized yet\r\n      if (this.torrent === undefined) return\r\n\r\n      // Http fallback\r\n      if (this.torrent === null) return this.player.trigger('p2pInfo', false)\r\n\r\n      // this.webtorrent.downloadSpeed because we need to take into account the potential old torrent too\r\n      if (this.webtorrent.downloadSpeed !== 0) this.downloadSpeeds.push(this.webtorrent.downloadSpeed)\r\n\r\n      return this.player.trigger('p2pInfo', {\r\n        source: 'webtorrent',\r\n        http: {\r\n          downloadSpeed: 0,\r\n          uploadSpeed: 0,\r\n          downloaded: 0,\r\n          uploaded: 0\r\n        },\r\n        p2p: {\r\n          downloadSpeed: this.torrent.downloadSpeed,\r\n          numPeers: this.torrent.numPeers,\r\n          uploadSpeed: this.torrent.uploadSpeed,\r\n          downloaded: this.torrent.downloaded,\r\n          uploaded: this.torrent.uploaded\r\n        },\r\n        bandwidthEstimate: this.webtorrent.downloadSpeed\r\n      } as PlayerNetworkInfo)\r\n    }, this.CONSTANTS.INFO_SCHEDULER)\r\n  }\r\n\r\n  private fallbackToHttp (options: PlayOptions, done?: (err?: Error) => void) {\r\n    const paused = this.player.paused()\r\n\r\n    this.disableAutoResolution()\r\n\r\n    this.flushVideoFile(this.currentVideoFile, true)\r\n    this.torrent = null\r\n\r\n    // Enable error display now this is our last fallback\r\n    this.player.one('error', () => this.player.peertube().displayFatalError())\r\n\r\n    const httpUrl = this.currentVideoFile.fileUrl\r\n    this.player.src = this.savePlayerSrcFunction\r\n    this.player.src(httpUrl)\r\n\r\n    this.selectAppropriateResolution(true)\r\n\r\n    // We changed the source, so reinit captions\r\n    this.player.trigger('sourcechange')\r\n\r\n    return this.tryToPlay(err => {\r\n      if (err && done) return done(err)\r\n\r\n      if (options.seek) this.seek(options.seek)\r\n      if (options.forcePlay === false && paused === true) this.player.pause()\r\n\r\n      if (done) return done()\r\n    })\r\n  }\r\n\r\n  private handleError (err: Error | string) {\r\n    return this.player.trigger('customError', { err })\r\n  }\r\n\r\n  private pickAverageVideoFile () {\r\n    if (this.videoFiles.length === 1) return this.videoFiles[0]\r\n\r\n    const files = this.videoFiles.filter(f => f.resolution.id !== 0)\r\n    return files[Math.floor(files.length / 2)]\r\n  }\r\n\r\n  private stopTorrent (torrent: WebTorrent.Torrent) {\r\n    torrent.pause()\r\n    // Pause does not remove actual peers (in particular the webseed peer)\r\n    torrent.removePeer(torrent['ws'])\r\n  }\r\n\r\n  private renderFileInFakeElement (file: WebTorrent.TorrentFile, delay: number) {\r\n    this.destroyingFakeRenderer = false\r\n\r\n    const fakeVideoElem = document.createElement('video')\r\n    renderVideo(file, fakeVideoElem, { autoplay: false, controls: false }, (err, renderer) => {\r\n      this.fakeRenderer = renderer\r\n\r\n      // The renderer returns an error when we destroy it, so skip them\r\n      if (this.destroyingFakeRenderer === false && err) {\r\n        logger.error('Cannot render new torrent in fake video element.', err)\r\n      }\r\n\r\n      // Load the future file at the correct time (in delay MS - 2 seconds)\r\n      fakeVideoElem.currentTime = this.player.currentTime() + (delay - 2000)\r\n    })\r\n  }\r\n\r\n  private destroyFakeRenderer () {\r\n    if (this.fakeRenderer) {\r\n      this.destroyingFakeRenderer = true\r\n\r\n      if (this.fakeRenderer.destroy) {\r\n        try {\r\n          this.fakeRenderer.destroy()\r\n        } catch (err) {\r\n          logger.info('Cannot destroy correctly fake renderer.', err)\r\n        }\r\n      }\r\n      this.fakeRenderer = undefined\r\n    }\r\n  }\r\n\r\n  private buildQualities () {\r\n    const resolutions: PeerTubeResolution[] = this.videoFiles.map(file => ({\r\n      id: file.resolution.id,\r\n      label: this.buildQualityLabel(file),\r\n      height: file.resolution.id,\r\n      selected: false,\r\n      selectCallback: () => this.changeQuality(file.resolution.id)\r\n    }))\r\n\r\n    resolutions.push({\r\n      id: -1,\r\n      label: this.player.localize('Auto'),\r\n      selected: true,\r\n      selectCallback: () => this.changeQuality(-1)\r\n    })\r\n\r\n    this.player.peertubeResolutions().add(resolutions)\r\n  }\r\n\r\n  private buildQualityLabel (file: VideoFile) {\r\n    let label = file.resolution.label\r\n\r\n    if (file.fps && file.fps >= 50) {\r\n      label += file.fps\r\n    }\r\n\r\n    return label\r\n  }\r\n\r\n  private selectAppropriateResolution (byEngine: boolean) {\r\n    const resolution = this.autoResolution\r\n      ? -1\r\n      : this.getCurrentResolutionId()\r\n\r\n    const autoResolutionChosen = this.autoResolution\r\n      ? this.getCurrentResolutionId()\r\n      : undefined\r\n\r\n    this.player.peertubeResolutions().select({ id: resolution, autoResolutionChosenId: autoResolutionChosen, byEngine })\r\n  }\r\n}\r\n\r\nvideojs.registerPlugin('webtorrent', WebTorrentPlugin)\r\nexport { WebTorrentPlugin }\r\n","module.exports = require('stream-http')\r\n","module.exports = require('https-browserify')\r\n","// Does nothing. Used to shim out node.js modules\r\n// which are no-ops in the browser.\r\nexport const NOOP = 0\r\n","module.exports = require('stream-browserify')\r\n"],"names":["ChunkDatabase","constructor","dbname","super","this","version","stores","chunks","ExpirationDatabase","databases","PeertubeChunkStore","EventEmitter","chunkLength","opts","pendingPut","memoryChunks","databaseName","torrent","infoHash","setMaxListeners","Number","Error","length","Infinity","lastChunkLength","lastChunkIndex","Math","ceil","db","expirationDB","runCleaner","put","index","buf","cb","isLastChunk","nextTick","push","id","putBulkTimeout","setTimeout","async","processing","undefined","transaction","bulkPut","map","p","err","logger","forEach","BUFFERING_PUT_MS","get","memoryChunk","process","result","Buffer","alloc","offset","slice","catch","close","destroy","clearTimeout","cleanerInterval","clearInterval","dropDatabase","checkExpiration","setInterval","CLEANER_INTERVAL_MS","databasesToDeleteInfo","name","expiration","Date","getTime","CLEANER_EXPIRATION_MS","now","where","below","toArray","databaseToDeleteInfo","dbToDelete","delete","val","MediaElementWrapper","Videostream","VIDEOSTREAM_EXTS","renderVideo","file","elem","callback","createReadStream","validateFile","extension","extname","toLowerCase","preparedElem","renderer","currentTime","includes","prepareElem","addEventListener","onError","removeEventListener","onLoadStart","useMediaSource","useVP9","codecs","ext","getCodec","fallbackToMediaSource","wrapper","writable","createWriteStream","pipe","autoplay","play","renderMedia","CacheChunkStore","Plugin","WebTorrentPlugin","player","options","startTime","CONSTANTS","INFO_SCHEDULER","AUTO_QUALITY_SCHEDULER","AUTO_QUALITY_THRESHOLD_PERCENT","AUTO_QUALITY_OBSERVATION_TIME","AUTO_QUALITY_HIGHER_RESOLUTION_DELAY","BANDWIDTH_AVERAGE_NUMBER_OF_VALUES","webtorrent","tracker","rtcConfig","dht","destroyingFakeRenderer","autoResolution","autoResolutionPossible","isAutoResolutionObservation","playerRefusedP2P","downloadSpeeds","videoFiles","videoDuration","savePlayerSrcFunction","src","playerElement","ready","playerOptions","options_","volume","muted","duration","initializePlayer","runTorrentInfoScheduler","one","runAutoQualitySchedulerTimer","runAutoQualityScheduler","dispose","addTorrentDelay","qualityObservationTimer","torrentInfoInterval","autoQualityInterval","flushVideoFile","currentVideoFile","destroyFakeRenderer","getCurrentResolutionId","resolution","updateVideoFile","videoFile","done","savedAverageBandwidth","getAppropriateFile","pickAverageVideoFile","magnetUri","peertube","hideFatalError","oldPlaybackRate","playbackRate","previousVideoFile","fallbackToHttp","addTorrent","selectAppropriateResolution","updateEngineResolution","resolutionId","delay","paused","bigPlayButton","hide","addClass","posterImage","show","removeClass","newVideoFile","find","f","forcePlay","seek","destroyRenderer","remove","disableAutoResolution","peertubeResolutions","isAutoResolutionPossible","getTorrent","getCurrentVideoFile","changeQuality","magnetOrTorrentUrl","oldTorrent","add","store","storeOpts","max","stopTorrent","renderFileInFakeElement","files","controls","tryToPlay","pause","on","message","indexOf","handleError","playPromise","then","time","handleTechSeeked_","averageDownloadSpeed","filter","progress","ended","getAndSaveActualDownloadSpeed","playerHeight","offsetHeight","maxResolution","i","filteredFiles","fileBitrate","size","threshold","start","lastDownloadSpeeds","sum","reduce","a","b","averageBandwidth","round","buildQualities","oldPlay","bind","changeResolution","changeResolutionDelay","isPlayerWaiting","label","hasClass","trigger","downloadSpeed","source","http","uploadSpeed","downloaded","uploaded","p2p","numPeers","bandwidthEstimate","displayFatalError","httpUrl","fileUrl","floor","removePeer","fakeVideoElem","document","createElement","fakeRenderer","resolutions","buildQualityLabel","height","selected","selectCallback","localize","fps","byEngine","autoResolutionChosen","select","autoResolutionChosenId","module","exports","NOOP"],"sourceRoot":""}