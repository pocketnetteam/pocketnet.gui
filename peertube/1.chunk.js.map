{"version":3,"sources":["webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/loader-interface.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/stringly-typed-event-emitter.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/http-media-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/media-peer.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/p2p-media-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/bandwidth-approximator.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/segments-memory-storage.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/hybrid-loader.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/byte-range.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/segment-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/hlsjs-loader.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/engine.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/index.ts"],"names":["Events","on","event","listener","super","emit","args","settings","xhrRequests","Map","failedSegments","debug","download","segment","downloadedPieces","this","isDownloading","cleanTimedOutFailedSegments","segmentUrl","buildSegmentUrl","requestUrl","xhr","XMLHttpRequest","open","responseType","range","setRequestHeader","undefined","httpUseRanges","bytesDownloaded","piece","byteLength","setupXhrEvents","xhrSetup","set","id","initialPriority","priority","send","updatePriority","request","get","Error","requiredSegmentsPriority","abort","delete","has","isFailed","time","now","getActiveDownloads","getActiveDownloadsCount","size","destroy","forEach","clear","prevBytesLoaded","addEventListener","bytesLoaded","loaded","lengthComputable","total","status","segmentFailure","data","response","segmentData","Uint8Array","offset","buffer","segmentDownloadFinished","responseUrl","responseURL","segmentValidator","error","httpFailedSegmentTimeout","candidates","push","performance","segmentUrlBuilder","url","MediaPeerCommands","MediaPeerSegmentStatus","DownloadingSegment","pieces","peer","remoteAddress","downloadingSegmentId","downloadingSegment","segmentsMap","timer","onPeerConnect","onPeerClose","terminateSegmentRequest","onPeerError","receiveSegmentPiece","segmentId","getJsonCommand","bytes","JSON","parse","TextDecoder","decode","onPeerData","command","c","SegmentsMap","createSegmentsMap","m","SegmentRequest","i","SegmentData","s","cancelResponseTimeoutTimer","SegmentAbsent","CancelSegmentRequest","segments","Object","streamSwarmId","keys","swarmData","Array","length","segmentsIds","split","segmentsStatuses","segmentStatus","sendCommand","write","stringify","getDownloadingSegmentId","getSegmentsMap","sendSegmentsMap","sendSegmentData","bytesLeft","bytesToSend","webRtcMaxMessageSize","from","sendSegmentAbsent","requestSegment","runResponseTimeoutTimer","cancelSegmentRequest","setTimeout","p2pSegmentDownloadTimeout","clearTimeout","PEER_ID_VERSION_PREFIX","replace","v","parseInt","slice","PeerSegmentRequest","peerId","segmentsStorage","trackerClient","peers","peerCandidates","peerSegmentRequests","pendingTrackerClient","getPeers","getPeerId","toString","setStreamSwarmId","masterSwarmId","isDestroyed","infoHash","update","digest","createClient","useP2P","clientOptions","announce","trackerAnnounce","rtcConfig","port","getAnnounceOpts","numwant","peerRequestsPerAnnounce","oldTrackerClient","onTrackerError","onTrackerWarning","onTrackerUpdate","onTrackerPeer","start","warning","trackerPeer","onPeerDataUpdated","onSegmentRequest","onSegmentLoaded","onSegmentAbsent","onSegmentError","onSegmentSize","onSegmentStartLoad","onSegmentTimeout","onPieceBytesDownloaded","onPieceBytesUploaded","peerCandidatesById","values","Loaded","Math","floor","random","peerSegmentRequest","swarmChange","stop","removeAllListeners","peerCandidateById","peerCandidate","sendSegmentsMapToAll","getOverallSegmentsMap","overallSegmentsMap","LoadingByHttp","index","indexOf","splice","key","value","getSegment","description","PEER_ID_SYMBOLS","charAt","TextEncoder","encode","generatePeerId","ArrayBuffer","enabled","SMOOTH_INTERVAL","NumberWithTime","timeStamp","BandwidthApproximator","lastBytes","currentBytesSum","lastBandwidth","addBytes","shift","interval","min","getBandwidth","maxBandwidth","bandwidth","getSmoothInterval","getMeasureInterval","cache","storeSegment","lastAccessed","cacheItem","hasSegment","clean","lockedSegmentsFilter","segmentsToDelete","remainingSegments","cachedSegment","cachedSegmentExpiration","countOverhead","cachedSegmentsCount","sort","a","b","defaultSettings","consumeOnly","simultaneousHttpDownloads","httpDownloadProbability","httpDownloadProbabilityInterval","httpDownloadProbabilitySkipIfNoPeers","httpDownloadMaxPriority","httpDownloadInitialTimeout","httpDownloadInitialTimeoutPerSegment","simultaneousP2PDownloads","p2pDownloadMaxPriority","config","debugSegments","segmentsQueue","bandwidthApproximator","httpDownloadInitialTimeoutTimestamp","Infinity","createHttpManager","createP2PManager","load","httpRandomDownloadInterval","setInterval","downloadRandomSegmentOverHttp","processInitialSegmentTimeout","p2pManager","updateSegmentsMap","find","f","httpManager","SegmentAbort","storageSegments","processSegmentsQueue","cleanSegmentsStorage","getSettings","getDetails","getBandwidthEstimate","clearInterval","httpAllowed","firstNotDownloadePriority","httpTimeout","segmentToAbort","pendingQueue","filter","method","SegmentStartLoad","PieceBytesDownloaded","PieceBytesUploaded","downloadBandwidth","SegmentLoaded","details","SegmentError","SegmentSize","getStreamSwarmId","streamId","addSegmentToMap","sequence","segmentsIdsAndStatuses","storageSegment","PeerConnect","PeerClose","incomplete","queueSegment","bufferedSegmentsCount","isSupported","window","RTCPeerConnection","prototype","createDataChannel","getByteRange","context","rangeEnd","rangeStart","compareByteRanges","b1","b2","byteRangeToString","byteRange","end","forwardSegmentCount","swarmId","assetsStorage","loader","masterPlaylist","variantPlaylists","segmentRequest","playQueue","segmentByteRange","onSuccess","onError","onSegmentAbort","content","parser","playlist","manifest","playlists","variantPlaylist","found","updateSegments","getMasterSwarmId","asset","getAsset","responseUri","loadContent","storeAsset","masterManifestUri","requestUri","processPlaylist","segmentLocation","getSegmentLocation","byteRangeString","result","next","done","requestRange","segmentSequence","mediaSequence","segmentIndex","promise","Promise","resolve","reject","loadSegments","duration","urlIndex","findIndex","playPosition","playheadPosition","currentSegmentPosition","getSegmentIndex","requestFirstSegment","playlistSegments","initialSequence","loadSegmentId","max","getSegmentAbsoluteUrl","uri","byterange","getSegmentId","settingsSwarmId","playlistUrl","URL","readyState","statusText","playlistRequestUrl","segmentManager","isLoaded","stats","aborted","retry","chunkCount","bwEstimate","loading","first","parsing","buffering","_config","callbacks","updateStatsToStartLoading","type","loadPlaylist","successPlaylist","e","frag","isSegment","updateStart","onUpdateSegmentSize","onUpdateLoaded","_type","loadSegment","successSegment","off","console","warn","abortSegment","onAbort","onProgress","map","eventKey","engine","impl","getResponseHeader","getEngine","setPlayingSegment","setPlayingSegmentByCurrentTime","version","initHlsJsPlayer","player","initHlsJsEvents","initClapprPlayer","playback","core","getCurrentPlayback","_hls","_p2pm_linitialized","initFlowplayerHlsJsPlayer","hlsjs","hls","initVideoJsContribHlsJsPlayer","ready","options","tech_","options_","hlsjsConfig","initVideoJsHlsJsPlugin","videojs","Html5Hlsjs","addHook","videojsPlayer","initMediaElementJsPlayer","mediaElement","hlsPlayer","media","currentTime","initJwPlayer","iid","assign","_event","errorData","htmlMediaElement","el_"],"mappings":"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","file":"1.chunk.js?v=664","sourcesContent":["/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { EventEmitter } from \"events\";\n\nexport type Segment = {\n    readonly id: string;\n    readonly url: string;\n    readonly masterSwarmId: string;\n    readonly masterManifestUri: string;\n    readonly streamId: string | undefined;\n    readonly sequence: string;\n    readonly range: string | undefined;\n    readonly priority: number;\n    data?: ArrayBuffer;\n    downloadBandwidth?: number;\n    requestUrl?: string;\n    responseUrl?: string;\n};\n\nexport enum Events {\n    /**\n     * Emitted when segment has been downloaded.\n     * Args: segment\n     */\n    SegmentLoaded = \"segment_loaded\",\n\n    /**\n     * Emitted when an error occurred while loading the segment.\n     * Args: segment, error\n     */\n    SegmentError = \"segment_error\",\n\n\n    /**\n     * Emitter when we the segment size is known\n     * Args: segment, size\n     */\n    SegmentSize = \"segment_size\",\n\n    /**\n     * Emitted for each segment that does not hit into a new segments queue when the load() method is called.\n     * Args: segment\n     */\n    SegmentAbort = \"segment_abort\",\n\n\n    /**\n     * Emitted when the loader started to load a segment\n     * Args: method, segment\n     */\n    SegmentStartLoad = \"segment_start_load\",\n\n    /**\n     * Emitted when a peer is connected.\n     * Args: peer\n     */\n    PeerConnect = \"peer_connect\",\n\n    /**\n     * Emitted when a peer is disconnected.\n     * Args: peerId\n     */\n    PeerClose = \"peer_close\",\n\n    /**\n     * Emitted when a segment piece has been downloaded.\n     * Args: method (can be \"http\" or \"p2p\" only), bytes\n     */\n    PieceBytesDownloaded = \"piece_bytes_downloaded\",\n\n    /**\n     * Emitted when a segment piece has been uploaded.\n     * Args: method (can be \"p2p\" only), bytes\n     */\n    PieceBytesUploaded = \"piece_bytes_uploaded\",\n}\n\nexport interface LoaderInterface extends EventEmitter {\n    on: ((eventName: string, listener: (...params: unknown[]) => void) => this) &\n        ((eventName: Events.SegmentStartLoad, listener: (method: \"http\" | \"p2p\", segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentSize, listener: (segment: Segment, size: number) => void) => this) &\n        ((eventName: Events.PieceBytesDownloaded | Events.PieceBytesUploaded, listener: (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => void) => this) &\n        ((eventName: Events.SegmentLoaded, listener: (segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentError, listener: (segment: Segment, error: unknown) => void) => this) &\n        ((eventName: Events.SegmentAbort, listener: (segment: Segment) => void) => this);\n    load: (segments: Segment[], streamSwarmId: string) => void;\n    getSegment: (id: string) => Promise<Segment | undefined>;\n    getSettings: () => unknown;\n    getDetails: () => unknown;\n    getBandwidthEstimate: () => number;\n    destroy: () => Promise<void>;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { EventEmitter } from \"events\";\n\nexport class STEEmitter<T extends string | symbol> extends EventEmitter {\n    public on = (event: T, listener: (...args: any[]) => void): this => super.on(event, listener);\n    public emit = (event: T, ...args: any[]): boolean => super.emit(event, ...args);\n}\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport Debug from \"debug\";\r\n\r\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\r\nimport { Segment } from \"./loader-interface\";\r\nimport { SegmentValidatorCallback, XhrSetupCallback, SegmentUrlBuilder } from \"./hybrid-loader\";\r\n\r\nclass FilteredEmitter extends STEEmitter<\r\n    \"segment-start-load\" | \"segment-loaded\" | \"segment-error\" | \"segment-size\" | \"bytes-downloaded\"\r\n> { }\r\n\r\nexport class HttpMediaManager extends FilteredEmitter {\r\n    private xhrRequests = new Map<string, { xhr: XMLHttpRequest; segment: Segment, initialPriority: number, segmentUrl: string }>();\r\n    private failedSegments = new Map<string, number>();\r\n    private debug = Debug(\"p2pml:http-media-manager\");\r\n\r\n    public constructor(\r\n        readonly settings: {\r\n            httpFailedSegmentTimeout: number;\r\n            httpUseRanges: boolean;\r\n            requiredSegmentsPriority: number;\r\n            segmentValidator?: SegmentValidatorCallback;\r\n            xhrSetup?: XhrSetupCallback;\r\n            segmentUrlBuilder?: SegmentUrlBuilder;\r\n        }\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    public download = (segment: Segment, downloadedPieces?: ArrayBuffer[]): void => {\r\n        if (this.isDownloading(segment)) {\r\n            return;\r\n        }\r\n\r\n        this.cleanTimedOutFailedSegments();\r\n\r\n        this.emit(\"segment-start-load\", segment);\r\n\r\n        const segmentUrl = this.buildSegmentUrl(segment);\r\n\r\n        this.debug(\"http segment download\", segmentUrl);\r\n\r\n        segment.requestUrl = segmentUrl;\r\n\r\n        const xhr = new XMLHttpRequest();\r\n        xhr.open(\"GET\", segmentUrl, true);\r\n        xhr.responseType = \"arraybuffer\";\r\n\r\n        if (segment.range) {\r\n            xhr.setRequestHeader(\"Range\", segment.range);\r\n            downloadedPieces = undefined; // TODO: process downloadedPieces for segments with range headers too\r\n        } else if (downloadedPieces !== undefined && this.settings.httpUseRanges) {\r\n            let bytesDownloaded = 0;\r\n            for (const piece of downloadedPieces) {\r\n                bytesDownloaded += piece.byteLength;\r\n            }\r\n\r\n            xhr.setRequestHeader(\"Range\", `bytes=${bytesDownloaded}-`);\r\n\r\n            this.debug(\"continue download from\", bytesDownloaded);\r\n        } else {\r\n            downloadedPieces = undefined;\r\n        }\r\n\r\n        this.setupXhrEvents(xhr, segment, downloadedPieces);\r\n\r\n        if (this.settings.xhrSetup) {\r\n            this.settings.xhrSetup(xhr, segmentUrl);\r\n        }\r\n\r\n        this.xhrRequests.set(segment.id, { xhr, segment, initialPriority: segment.priority, segmentUrl });\r\n        xhr.send();\r\n    };\r\n\r\n    public updatePriority = (segment: Segment): void => {\r\n        const request = this.xhrRequests.get(segment.id);\r\n\r\n        if (!request) {\r\n            throw new Error(\"Cannot update priority of not downloaded segment \" + segment.id);\r\n        }\r\n\r\n        // Segment is now in high priority\r\n        // If the segment URL changed, retry the request with the new URL\r\n        if (\r\n            segment.priority <= this.settings.requiredSegmentsPriority &&\r\n            request.initialPriority > this.settings.requiredSegmentsPriority &&\r\n            request.segmentUrl !== this.buildSegmentUrl(segment)\r\n        ) {\r\n            this.debug(\"aborting http segment abort because the segment is now in a high priority\", segment.id);\r\n            this.abort(segment)\r\n            this.download(segment)\r\n        }\r\n\r\n    }\r\n\r\n    public abort = (segment: Segment): void => {\r\n        const request = this.xhrRequests.get(segment.id);\r\n\r\n        if (request) {\r\n            request.xhr.abort();\r\n            this.xhrRequests.delete(segment.id);\r\n            this.debug(\"http segment abort\", segment.id);\r\n        }\r\n    };\r\n\r\n    public isDownloading = (segment: Segment): boolean => {\r\n        return this.xhrRequests.has(segment.id);\r\n    };\r\n\r\n    public isFailed = (segment: Segment): boolean => {\r\n        const time = this.failedSegments.get(segment.id);\r\n        return time !== undefined && time > this.now();\r\n    };\r\n\r\n    public getActiveDownloads = (): ReadonlyMap<string, { segment: Segment }> => {\r\n        return this.xhrRequests;\r\n    };\r\n\r\n    public getActiveDownloadsCount = (): number => {\r\n        return this.xhrRequests.size;\r\n    };\r\n\r\n    public destroy = (): void => {\r\n        this.xhrRequests.forEach((request) => request.xhr.abort());\r\n        this.xhrRequests.clear();\r\n    };\r\n\r\n    private setupXhrEvents = (xhr: XMLHttpRequest, segment: Segment, downloadedPieces?: ArrayBuffer[]) => {\r\n        let prevBytesLoaded = 0;\r\n\r\n        xhr.addEventListener(\"progress\", (event) => {\r\n            const bytesLoaded = event.loaded - prevBytesLoaded;\r\n            this.emit(\"bytes-downloaded\", segment, bytesLoaded);\r\n            prevBytesLoaded = event.loaded;\r\n\r\n            if (event.lengthComputable) {\r\n                this.emit(\"segment-size\", segment, event.total);\r\n            }\r\n        });\r\n\r\n        xhr.addEventListener(\"load\", async (event) => {\r\n            if (xhr.status < 200 || xhr.status >= 300) {\r\n                this.segmentFailure(segment, event, xhr);\r\n                return;\r\n            }\r\n\r\n            let data = xhr.response as ArrayBuffer;\r\n\r\n            if (downloadedPieces !== undefined && xhr.status === 206) {\r\n                let bytesDownloaded = 0;\r\n                for (const piece of downloadedPieces) {\r\n                    bytesDownloaded += piece.byteLength;\r\n                }\r\n\r\n                const segmentData = new Uint8Array(bytesDownloaded + data.byteLength);\r\n                let offset = 0;\r\n\r\n                for (const piece of downloadedPieces) {\r\n                    segmentData.set(new Uint8Array(piece), offset);\r\n                    offset += piece.byteLength;\r\n                }\r\n\r\n                segmentData.set(new Uint8Array(data), offset);\r\n                data = segmentData.buffer;\r\n            }\r\n\r\n            await this.segmentDownloadFinished(segment, data, xhr);\r\n        });\r\n\r\n        xhr.addEventListener(\"error\", (event: unknown) => {\r\n            this.segmentFailure(segment, event, xhr);\r\n        });\r\n\r\n        xhr.addEventListener(\"timeout\", (event: unknown) => {\r\n            this.segmentFailure(segment, event, xhr);\r\n        });\r\n    };\r\n\r\n    private segmentDownloadFinished = async (segment: Segment, data: ArrayBuffer, xhr: XMLHttpRequest) => {\r\n        segment.responseUrl = xhr.responseURL === null ? undefined : xhr.responseURL;\r\n\r\n        if (this.settings.segmentValidator) {\r\n            try {\r\n                await this.settings.segmentValidator({ ...segment, data: data }, \"http\");\r\n            } catch (error) {\r\n                this.debug(\"segment validator failed\", error);\r\n                this.segmentFailure(segment, error, xhr);\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.xhrRequests.delete(segment.id);\r\n        this.emit(\"segment-loaded\", segment, data);\r\n    };\r\n\r\n    private segmentFailure = (segment: Segment, error: unknown, xhr: XMLHttpRequest) => {\r\n        segment.responseUrl = xhr.responseURL === null ? undefined : xhr.responseURL;\r\n\r\n        this.xhrRequests.delete(segment.id);\r\n        this.failedSegments.set(segment.id, this.now() + this.settings.httpFailedSegmentTimeout);\r\n        this.emit(\"segment-error\", segment, error);\r\n    };\r\n\r\n    private cleanTimedOutFailedSegments = () => {\r\n        const now = this.now();\r\n        const candidates: string[] = [];\r\n\r\n        this.failedSegments.forEach((time, id) => {\r\n            if (time < now) {\r\n                candidates.push(id);\r\n            }\r\n        });\r\n\r\n        candidates.forEach((id) => this.failedSegments.delete(id));\r\n    };\r\n\r\n    private buildSegmentUrl (segment: Segment) {\r\n        if (this.settings.segmentUrlBuilder) {\r\n            return this.settings.segmentUrlBuilder(segment);\r\n        }\r\n\r\n        return segment.url;\r\n    }\r\n\r\n    private now = () => performance.now();\r\n}\r\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nimport Debug from \"debug\";\nimport { Buffer } from \"buffer\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\n\nenum MediaPeerCommands {\n    SegmentData,\n    SegmentAbsent,\n    SegmentsMap,\n    SegmentRequest,\n    CancelSegmentRequest,\n}\n\ntype MediaPeerCommand =\n    | {\n          c:\n              | MediaPeerCommands.SegmentAbsent\n              | MediaPeerCommands.SegmentRequest\n              | MediaPeerCommands.CancelSegmentRequest;\n          i: string;\n      }\n    | {\n          c: MediaPeerCommands.SegmentsMap;\n          m: { [key: string]: [string, number[]] };\n      }\n    | {\n          c: MediaPeerCommands.SegmentData;\n          i: string;\n          s: number;\n      };\n\nexport enum MediaPeerSegmentStatus {\n    Loaded,\n    LoadingByHttp,\n}\n\nclass DownloadingSegment {\n    public bytesDownloaded = 0;\n    public pieces: ArrayBuffer[] = [];\n    constructor(readonly id: string, readonly size: number) {}\n}\n\nexport class MediaPeer extends STEEmitter<\n    | \"connect\"\n    | \"close\"\n    | \"data-updated\"\n    | \"segment-start-load\"\n    | \"segment-request\"\n    | \"segment-absent\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-timeout\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n> {\n    public id: string;\n    public remoteAddress = \"\";\n    private downloadingSegmentId: string | null = null;\n    private downloadingSegment: DownloadingSegment | null = null;\n    private segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n    private debug = Debug(\"p2pml:media-peer\");\n    private timer: ReturnType<typeof setTimeout> | null = null;\n\n    constructor(\n        // eslint-disable-next-line\n        readonly peer: any,\n        readonly settings: {\n            p2pSegmentDownloadTimeout: number;\n            webRtcMaxMessageSize: number;\n        }\n    ) {\n        super();\n\n        this.peer.on(\"connect\", this.onPeerConnect);\n        this.peer.on(\"close\", this.onPeerClose);\n        this.peer.on(\"error\", this.onPeerError);\n        this.peer.on(\"data\", this.onPeerData);\n\n        this.id = peer.id;\n    }\n\n    private onPeerConnect = () => {\n        this.debug(\"peer connect\", this.id, this);\n        this.remoteAddress = this.peer.remoteAddress;\n        this.emit(\"connect\", this);\n    };\n\n    private onPeerClose = () => {\n        this.debug(\"peer close\", this.id, this);\n        this.terminateSegmentRequest();\n        this.emit(\"close\", this);\n    };\n\n    private onPeerError = (error: unknown) => {\n        this.debug(\"peer error\", this.id, error, this);\n    };\n\n    private receiveSegmentPiece = (data: ArrayBuffer): void => {\n        if (!this.downloadingSegment) {\n            // The segment was not requested or canceled\n            this.debug(\"peer segment not requested\", this.id, this);\n            return;\n        }\n\n        this.downloadingSegment.bytesDownloaded += data.byteLength;\n        this.downloadingSegment.pieces.push(data);\n\n        const segmentId = this.downloadingSegment.id;\n        this.emit(\"bytes-downloaded\", this, segmentId, data.byteLength);\n\n        if (this.downloadingSegment.bytesDownloaded === this.downloadingSegment.size) {\n            const segmentData = new Uint8Array(this.downloadingSegment.size);\n            let offset = 0;\n            for (const piece of this.downloadingSegment.pieces) {\n                segmentData.set(new Uint8Array(piece), offset);\n                offset += piece.byteLength;\n            }\n\n            this.debug(\"peer segment download done\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-loaded\", this, segmentId, segmentData.buffer);\n        } else if (this.downloadingSegment.bytesDownloaded > this.downloadingSegment.size) {\n            this.debug(\"peer segment download bytes mismatch\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Too many bytes received for segment\");\n        }\n    };\n\n    private getJsonCommand = (data: ArrayBuffer) => {\n        const bytes = new Uint8Array(data);\n\n        // Serialized JSON string check by first, second and last characters: '{\" .... }'\n        if (bytes[0] === 123 && bytes[1] === 34 && bytes[data.byteLength - 1] === 125) {\n            try {\n                return JSON.parse(new TextDecoder().decode(data)) as Record<string, unknown>;\n            } catch {\n                return null;\n            }\n        }\n\n        return null;\n    };\n\n    private onPeerData = (data: ArrayBuffer) => {\n        const command = this.getJsonCommand(data);\n\n        if (command === null) {\n            this.receiveSegmentPiece(data);\n            return;\n        }\n\n        if (this.downloadingSegment) {\n            this.debug(\"peer segment download is interrupted by a command\", this.id, this);\n\n            const segmentId = this.downloadingSegment.id;\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Segment download is interrupted by a command\");\n            return;\n        }\n\n        this.debug(\"peer receive command\", this.id, command, this);\n\n        switch (command.c) {\n            case MediaPeerCommands.SegmentsMap:\n                this.segmentsMap = this.createSegmentsMap(command.m);\n                this.emit(\"data-updated\");\n                break;\n\n            case MediaPeerCommands.SegmentRequest:\n                this.emit(\"segment-request\", this, command.i);\n                break;\n\n            case MediaPeerCommands.SegmentData:\n                if (\n                    this.downloadingSegmentId &&\n                    this.downloadingSegmentId === command.i &&\n                    typeof command.s === \"number\" &&\n                    command.s >= 0\n                ) {\n                    this.downloadingSegment = new DownloadingSegment(command.i, command.s);\n                    this.emit(\"segment-start-load\", this.downloadingSegment.id)\n                    this.emit(\"segment-size\", this.downloadingSegment.id, this.downloadingSegment.size)\n                    this.cancelResponseTimeoutTimer();\n                }\n                break;\n\n            case MediaPeerCommands.SegmentAbsent:\n                if (this.downloadingSegmentId && this.downloadingSegmentId === command.i) {\n                    this.terminateSegmentRequest();\n                    this.segmentsMap.delete(command.i);\n                    this.emit(\"segment-absent\", this, command.i);\n                }\n                break;\n\n            case MediaPeerCommands.CancelSegmentRequest:\n                // TODO: peer stop sending buffer\n                break;\n\n            default:\n                break;\n        }\n    };\n\n    private createSegmentsMap = (segments: unknown) => {\n        if (!(segments instanceof Object)) {\n            return new Map<string, MediaPeerSegmentStatus>();\n        }\n\n        const segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const streamSwarmId of Object.keys(segments)) {\n            const swarmData = (segments as Record<string, unknown>)[streamSwarmId];\n            if (\n                !(swarmData instanceof Array) ||\n                swarmData.length !== 2 ||\n                typeof swarmData[0] !== \"string\" ||\n                !(swarmData[1] instanceof Array)\n            ) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            const segmentsIds = swarmData[0].split(\"|\");\n            const segmentsStatuses = swarmData[1] as MediaPeerSegmentStatus[];\n\n            if (segmentsIds.length !== segmentsStatuses.length) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            for (let i = 0; i < segmentsIds.length; i++) {\n                const segmentStatus = segmentsStatuses[i];\n                if (typeof segmentStatus !== \"number\" || MediaPeerSegmentStatus[segmentStatus] === undefined) {\n                    return new Map<string, MediaPeerSegmentStatus>();\n                }\n\n                segmentsMap.set(`${streamSwarmId}+${segmentsIds[i]}`, segmentStatus);\n            }\n        }\n\n        return segmentsMap;\n    };\n\n    private sendCommand = (command: MediaPeerCommand): void => {\n        this.debug(\"peer send command\", this.id, command, this);\n        this.peer.write(JSON.stringify(command));\n    };\n\n    public destroy = (): void => {\n        this.debug(\"peer destroy\", this.id, this);\n        this.terminateSegmentRequest();\n        this.peer.destroy();\n    };\n\n    public getDownloadingSegmentId = (): string | null => {\n        return this.downloadingSegmentId;\n    };\n\n    public getSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        return this.segmentsMap;\n    };\n\n    public sendSegmentsMap = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentsMap, m: segmentsMap });\n    };\n\n    public sendSegmentData = (segmentId: string, data: ArrayBuffer): void => {\n        this.sendCommand({\n            c: MediaPeerCommands.SegmentData,\n            i: segmentId,\n            s: data.byteLength,\n        });\n\n        let bytesLeft = data.byteLength;\n        while (bytesLeft > 0) {\n            const bytesToSend =\n                bytesLeft >= this.settings.webRtcMaxMessageSize ? this.settings.webRtcMaxMessageSize : bytesLeft;\n            const buffer = Buffer.from(data, data.byteLength - bytesLeft, bytesToSend);\n\n            this.peer.write(buffer);\n            bytesLeft -= bytesToSend;\n        }\n\n        this.emit(\"bytes-uploaded\", this, segmentId, data.byteLength);\n    };\n\n    public sendSegmentAbsent = (segmentId: string): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentAbsent, i: segmentId });\n    };\n\n    public requestSegment = (segmentId: string): void => {\n        if (this.downloadingSegmentId) {\n            throw new Error(\"A segment is already downloading: \" + this.downloadingSegmentId);\n        }\n\n        this.sendCommand({ c: MediaPeerCommands.SegmentRequest, i: segmentId });\n        this.downloadingSegmentId = segmentId;\n        this.runResponseTimeoutTimer();\n    };\n\n    public cancelSegmentRequest = (): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n\n        if (this.downloadingSegmentId) {\n            const segmentId = this.downloadingSegmentId;\n            downloadingSegment = this.downloadingSegment ? this.downloadingSegment.pieces : undefined;\n            this.terminateSegmentRequest();\n            this.sendCommand({ c: MediaPeerCommands.CancelSegmentRequest, i: segmentId });\n        }\n\n        return downloadingSegment;\n    };\n\n    private runResponseTimeoutTimer = (): void => {\n        this.timer = setTimeout(() => {\n            this.timer = null;\n            if (!this.downloadingSegmentId) {\n                return;\n            }\n            const segmentId = this.downloadingSegmentId;\n            this.cancelSegmentRequest();\n            this.emit(\"segment-timeout\", this, segmentId); // TODO: send peer not responding event\n        }, this.settings.p2pSegmentDownloadTimeout);\n    };\n\n    private cancelResponseTimeoutTimer = (): void => {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n\n    private terminateSegmentRequest = () => {\n        this.downloadingSegmentId = null;\n        this.downloadingSegment = null;\n        this.cancelResponseTimeoutTimer();\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nimport Debug from \"debug\";\nimport Client from \"bittorrent-tracker/client\";\nimport { Buffer } from \"buffer\";\nimport sha1 from \"sha.js/sha1\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\nimport { Segment } from \"./loader-interface\";\nimport { MediaPeer, MediaPeerSegmentStatus } from \"./media-peer\";\nimport { SegmentsStorage, SegmentValidatorCallback } from \"./hybrid-loader\";\n\nconst PEER_PROTOCOL_VERSION = 2;\nconst PEER_ID_VERSION_STRING = '0.6.2'.replace(/\\d*./g, (v) => `0${parseInt(v, 10) % 100}`.slice(-2)).slice(0, 4);\nconst PEER_ID_VERSION_PREFIX = `-WW${PEER_ID_VERSION_STRING}-`; // Using WebTorrent client ID in order to not be banned by websocket trackers\n\nclass PeerSegmentRequest {\n    constructor(readonly peerId: string, readonly segment: Segment) {}\n}\n\nfunction generatePeerId(): ArrayBuffer {\n    const PEER_ID_SYMBOLS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const PEER_ID_LENGTH = 20;\n\n    let peerId = PEER_ID_VERSION_PREFIX;\n\n    for (let i = 0; i < PEER_ID_LENGTH - PEER_ID_VERSION_PREFIX.length; i++) {\n        peerId += PEER_ID_SYMBOLS.charAt(Math.floor(Math.random() * PEER_ID_SYMBOLS.length));\n    }\n\n    return new TextEncoder().encode(peerId).buffer;\n}\n\nexport class P2PMediaManager extends STEEmitter<\n    | \"peer-connected\"\n    | \"peer-closed\"\n    | \"peer-data-updated\"\n    | \"segment-start-load\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n    | \"tracker-update\"\n> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private trackerClient: any = null;\n    private peers = new Map<string, MediaPeer>();\n    private peerCandidates = new Map<string, MediaPeer[]>();\n    private peerSegmentRequests = new Map<string, PeerSegmentRequest>();\n    private streamSwarmId: string | null = null;\n    private readonly peerId: ArrayBuffer;\n    private debug = Debug(\"p2pml:p2p-media-manager\");\n    private pendingTrackerClient: {\n        isDestroyed: boolean;\n    } | null = null;\n    private masterSwarmId?: string;\n\n    public constructor(\n        private segmentsStorage: SegmentsStorage,\n        private settings: {\n            useP2P: boolean;\n            trackerAnnounce: string[];\n            p2pSegmentDownloadTimeout: number;\n            segmentValidator?: SegmentValidatorCallback;\n            webRtcMaxMessageSize: number;\n            rtcConfig?: RTCConfiguration;\n            peerRequestsPerAnnounce: number;\n        }\n    ) {\n        super();\n\n        this.peerId = settings.useP2P ? generatePeerId() : new ArrayBuffer(0);\n\n        if (this.debug.enabled) {\n            this.debug(\"peer ID\", this.getPeerId(), new TextDecoder().decode(this.peerId));\n        }\n    }\n\n    public getPeers = (): Map<string, MediaPeer> => {\n        return this.peers;\n    };\n\n    public getPeerId = (): string => {\n        return Buffer.from(this.peerId).toString(\"hex\");\n    };\n\n    public setStreamSwarmId = (streamSwarmId: string, masterSwarmId: string): void => {\n        if (this.streamSwarmId === streamSwarmId) {\n            return;\n        }\n\n        this.destroy(true);\n\n        this.streamSwarmId = streamSwarmId;\n        this.masterSwarmId = masterSwarmId;\n        this.debug(\"stream swarm ID\", this.streamSwarmId);\n\n        this.pendingTrackerClient = {\n            isDestroyed: false,\n        };\n\n        const pendingTrackerClient = this.pendingTrackerClient;\n\n        // TODO: native browser 'crypto.subtle' implementation doesn't work in Chrome in insecure pages\n        // TODO: Edge doesn't support SHA-1. Change to SHA-256 once Edge support is required.\n        // const infoHash = await crypto.subtle.digest(\"SHA-1\", new TextEncoder().encode(PEER_PROTOCOL_VERSION + this.streamSwarmId));\n\n        const infoHash = new sha1().update(`${PEER_PROTOCOL_VERSION}${this.streamSwarmId}`).digest();\n\n        // destroy may be called while waiting for the hash to be calculated\n        if (!pendingTrackerClient.isDestroyed) {\n            this.pendingTrackerClient = null;\n            this.createClient(infoHash);\n        } else if (this.trackerClient !== null) {\n            this.trackerClient.destroy();\n            this.trackerClient = null;\n        }\n    };\n\n    private createClient = (infoHash: ArrayBuffer): void => {\n        if (!this.settings.useP2P) {\n            return;\n        }\n\n        const clientOptions = {\n            infoHash: Buffer.from(infoHash, 0, 20),\n            peerId: Buffer.from(this.peerId, 0, 20),\n            announce: this.settings.trackerAnnounce,\n            rtcConfig: this.settings.rtcConfig,\n            port: 6881, // a dummy value allows running in Node.js environment\n            getAnnounceOpts: () => {\n                return { numwant: this.settings.peerRequestsPerAnnounce };\n            },\n        };\n\n        let oldTrackerClient = this.trackerClient;\n\n        this.trackerClient = new Client(clientOptions);\n        this.trackerClient.on(\"error\", this.onTrackerError);\n        this.trackerClient.on(\"warning\", this.onTrackerWarning);\n        this.trackerClient.on(\"update\", this.onTrackerUpdate);\n        this.trackerClient.on(\"peer\", this.onTrackerPeer);\n\n        this.trackerClient.start();\n\n        if (oldTrackerClient !== null) {\n            oldTrackerClient.destroy();\n            oldTrackerClient = null;\n        }\n    };\n\n    private onTrackerError = (error: unknown) => {\n        this.debug(\"tracker error\", error);\n    };\n\n    private onTrackerWarning = (warning: unknown) => {\n        this.debug(\"tracker warning\", warning);\n    };\n\n    private onTrackerUpdate = (data: unknown): void => {\n        this.debug(\"tracker update\", data);\n        this.emit(\"tracker-update\", data);\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private onTrackerPeer = (trackerPeer: any): void => {\n        this.debug(\"tracker peer\", trackerPeer.id, trackerPeer);\n\n        if (this.peers.has(trackerPeer.id)) {\n            this.debug(\"tracker peer already connected\", trackerPeer.id, trackerPeer);\n            trackerPeer.destroy();\n            return;\n        }\n\n        const peer = new MediaPeer(trackerPeer, this.settings);\n\n        peer.on(\"connect\", this.onPeerConnect);\n        peer.on(\"close\", this.onPeerClose);\n        peer.on(\"data-updated\", this.onPeerDataUpdated);\n        peer.on(\"segment-request\", this.onSegmentRequest);\n        peer.on(\"segment-loaded\", this.onSegmentLoaded);\n        peer.on(\"segment-absent\", this.onSegmentAbsent);\n        peer.on(\"segment-error\", this.onSegmentError);\n        peer.on(\"segment-size\", this.onSegmentSize);\n        peer.on(\"segment-start-load\", this.onSegmentStartLoad);\n        peer.on(\"segment-timeout\", this.onSegmentTimeout);\n        peer.on(\"bytes-downloaded\", this.onPieceBytesDownloaded);\n        peer.on(\"bytes-uploaded\", this.onPieceBytesUploaded);\n\n        let peerCandidatesById = this.peerCandidates.get(peer.id);\n\n        if (!peerCandidatesById) {\n            peerCandidatesById = [];\n            this.peerCandidates.set(peer.id, peerCandidatesById);\n        }\n\n        peerCandidatesById.push(peer);\n    };\n\n    public download = (segment: Segment): boolean => {\n        if (this.isDownloading(segment)) {\n            return false;\n        }\n\n        const candidates: MediaPeer[] = [];\n\n        for (const peer of this.peers.values()) {\n            if (\n                peer.getDownloadingSegmentId() === null &&\n                peer.getSegmentsMap().get(segment.id) === MediaPeerSegmentStatus.Loaded\n            ) {\n                candidates.push(peer);\n            }\n        }\n\n        if (candidates.length === 0) {\n            return false;\n        }\n\n        const peer = candidates[Math.floor(Math.random() * candidates.length)];\n        peer.requestSegment(segment.id);\n        this.peerSegmentRequests.set(segment.id, new PeerSegmentRequest(peer.id, segment));\n        return true;\n    };\n\n    public abort = (segment: Segment): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n        const peerSegmentRequest = this.peerSegmentRequests.get(segment.id);\n        if (peerSegmentRequest) {\n            const peer = this.peers.get(peerSegmentRequest.peerId);\n            if (peer) {\n                downloadingSegment = peer.cancelSegmentRequest();\n            }\n            this.peerSegmentRequests.delete(segment.id);\n        }\n        return downloadingSegment;\n    };\n\n    public isDownloading = (segment: Segment): boolean => {\n        return this.peerSegmentRequests.has(segment.id);\n    };\n\n    public getActiveDownloadsCount = (): number => {\n        return this.peerSegmentRequests.size;\n    };\n\n    public destroy = (swarmChange = false): void => {\n        this.streamSwarmId = null;\n\n        if (this.trackerClient) {\n            this.trackerClient.stop();\n            if (swarmChange) {\n                // Don't destroy trackerClient to reuse its WebSocket connection to the tracker server\n                this.trackerClient.removeAllListeners(\"error\");\n                this.trackerClient.removeAllListeners(\"warning\");\n                this.trackerClient.removeAllListeners(\"update\");\n                this.trackerClient.removeAllListeners(\"peer\");\n            } else {\n                this.trackerClient.destroy();\n                this.trackerClient = null;\n            }\n        }\n\n        if (this.pendingTrackerClient) {\n            this.pendingTrackerClient.isDestroyed = true;\n            this.pendingTrackerClient = null;\n        }\n\n        this.peers.forEach((peer) => peer.destroy());\n        this.peers.clear();\n\n        this.peerSegmentRequests.clear();\n\n        for (const peerCandidateById of this.peerCandidates.values()) {\n            for (const peerCandidate of peerCandidateById) {\n                peerCandidate.destroy();\n            }\n        }\n        this.peerCandidates.clear();\n    };\n\n    public sendSegmentsMapToAll = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.peers.forEach((peer) => peer.sendSegmentsMap(segmentsMap));\n    };\n\n    public sendSegmentsMap = (peerId: string, segmentsMap: { [key: string]: [string, number[]] }): void => {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.sendSegmentsMap(segmentsMap);\n        }\n    };\n\n    public getOverallSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        const overallSegmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const peer of this.peers.values()) {\n            for (const [segmentId, segmentStatus] of peer.getSegmentsMap()) {\n                if (segmentStatus === MediaPeerSegmentStatus.Loaded) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.Loaded);\n                } else if (!overallSegmentsMap.get(segmentId)) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.LoadingByHttp);\n                }\n            }\n        }\n\n        return overallSegmentsMap;\n    };\n\n    private onPieceBytesDownloaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"bytes-downloaded\", peerSegmentRequest.segment, bytes, peer.id);\n        }\n    };\n\n    private onPieceBytesUploaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        \n        this.emit(\"bytes-uploaded\", peerSegmentRequest ? peerSegmentRequest.segment : null, bytes, peer.id);\n      \n    };\n\n    private onPeerConnect = (peer: MediaPeer) => {\n        const connectedPeer = this.peers.get(peer.id);\n\n        if (connectedPeer) {\n            this.debug(\"tracker peer already connected (in peer connect)\", peer.id, peer);\n            peer.destroy();\n            return;\n        }\n\n        // First peer with the ID connected\n        this.peers.set(peer.id, peer);\n\n        // Destroy all other peer candidates\n        const peerCandidatesById = this.peerCandidates.get(peer.id);\n        if (peerCandidatesById) {\n            for (const peerCandidate of peerCandidatesById) {\n                if (peerCandidate !== peer) {\n                    peerCandidate.destroy();\n                }\n            }\n\n            this.peerCandidates.delete(peer.id);\n        }\n\n        this.emit(\"peer-connected\", { id: peer.id, remoteAddress: peer.remoteAddress });\n    };\n\n    private onPeerClose = (peer: MediaPeer) => {\n        if (this.peers.get(peer.id) !== peer) {\n            // Try to delete the peer candidate\n\n            const peerCandidatesById = this.peerCandidates.get(peer.id);\n            if (!peerCandidatesById) {\n                return;\n            }\n\n            const index = peerCandidatesById.indexOf(peer);\n            if (index !== -1) {\n                peerCandidatesById.splice(index, 1);\n            }\n\n            if (peerCandidatesById.length === 0) {\n                this.peerCandidates.delete(peer.id);\n            }\n\n            return;\n        }\n\n        for (const [key, value] of this.peerSegmentRequests) {\n            if (value.peerId === peer.id) {\n                this.peerSegmentRequests.delete(key);\n            }\n        }\n\n        this.peers.delete(peer.id);\n        this.emit(\"peer-data-updated\");\n        this.emit(\"peer-closed\", peer.id);\n    };\n\n    private onPeerDataUpdated = () => {\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentRequest = async (peer: MediaPeer, segmentId: string) => {\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        const segment = await this.segmentsStorage.getSegment(segmentId, this.masterSwarmId);\n        if (segment && segment.data) {\n            peer.sendSegmentData(segmentId, segment.data);\n        } else {\n            peer.sendSegmentAbsent(segmentId);\n        }\n    };\n\n    private onSegmentLoaded = async (peer: MediaPeer, segmentId: string, data: ArrayBuffer) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (!peerSegmentRequest) {\n            return;\n        }\n\n        const segment = peerSegmentRequest.segment;\n\n        if (this.settings.segmentValidator) {\n            try {\n                await this.settings.segmentValidator({ ...segment, data: data }, \"p2p\", peer.id);\n            } catch (error) {\n                this.debug(\"segment validator failed\", error);\n                this.peerSegmentRequests.delete(segmentId);\n                this.emit(\"segment-error\", segment, error, peer.id);\n                this.onPeerClose(peer);\n                return;\n            }\n        }\n\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"segment-loaded\", segment, data, peer.id);\n    };\n\n    private onSegmentAbsent = (peer: MediaPeer, segmentId: string) => {\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentError = (peer: MediaPeer, segmentId: string, description: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            this.emit(\"segment-error\", peerSegmentRequest.segment, description, peer.id);\n        }\n    };\n\n    private onSegmentSize = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-size\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentStartLoad = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-start-load\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentTimeout = (peer: MediaPeer, segmentId: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            peer.destroy();\n            if (this.peers.delete(peerSegmentRequest.peerId)) {\n                this.emit(\"peer-data-updated\");\n            }\n        }\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\n\nconst debug = Debug(\"p2pml:bandwidth-approximator\");\n\nconst SMOOTH_INTERVAL = 2 * 1000;\nconst MEASURE_INTERVAL = 40 * 1000;\n\nclass NumberWithTime {\n    constructor(readonly value: number, readonly timeStamp: number) {}\n}\n\nexport class BandwidthApproximator {\n    private lastBytes: NumberWithTime[] = [];\n    private currentBytesSum = 0;\n    private lastBandwidth: NumberWithTime[] = [];\n\n    public addBytes = (bytes: number, timeStamp: number): void => {\n        debug(\"Add %d bytes.\", bytes)\n\n        this.lastBytes.push(new NumberWithTime(bytes, timeStamp));\n        this.currentBytesSum += bytes;\n\n        while (timeStamp - this.lastBytes[0].timeStamp > SMOOTH_INTERVAL) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.currentBytesSum -= this.lastBytes.shift()!.value;\n        }\n\n        const interval = Math.min(SMOOTH_INTERVAL, timeStamp);\n        this.lastBandwidth.push(new NumberWithTime(this.currentBytesSum / interval, timeStamp));\n    };\n\n    // in bytes per millisecond\n    public getBandwidth = (timeStamp: number): number => {\n        while (this.lastBandwidth.length !== 0 && timeStamp - this.lastBandwidth[0].timeStamp > MEASURE_INTERVAL) {\n            this.lastBandwidth.shift();\n        }\n\n        let maxBandwidth = 0;\n        for (const bandwidth of this.lastBandwidth) {\n            if (bandwidth.value > maxBandwidth) {\n                maxBandwidth = bandwidth.value;\n            }\n        }\n\n        debug(\"Max bandwidth: %d.\", maxBandwidth)\n\n        return maxBandwidth;\n    };\n\n    public getSmoothInterval = (): number => {\n        return SMOOTH_INTERVAL;\n    };\n\n    public getMeasureInterval = (): number => {\n        return MEASURE_INTERVAL;\n    };\n}\n","/**\n * Copyright 2019 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Segment } from \"./loader-interface\";\nimport { SegmentsStorage } from \"./hybrid-loader\";\n\nexport class SegmentsMemoryStorage implements SegmentsStorage {\n    private cache = new Map<string, { segment: Segment; lastAccessed: number }>();\n\n    constructor(\n        private settings: {\n            cachedSegmentExpiration: number;\n            cachedSegmentsCount: number;\n        }\n    ) {}\n\n    public storeSegment = async (segment: Segment): Promise<void> => {\n        this.cache.set(segment.id, { segment, lastAccessed: performance.now() });\n    };\n\n    public getSegmentsMap = async (): Promise<Map<string, { segment: Segment }>> => {\n        return this.cache;\n    };\n\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\n        const cacheItem = this.cache.get(id);\n\n        if (cacheItem === undefined) {\n            return undefined;\n        }\n\n        cacheItem.lastAccessed = performance.now();\n        return cacheItem.segment;\n    };\n\n    public hasSegment = async (id: string): Promise<boolean> => {\n        return this.cache.has(id);\n    };\n\n    public clean = async (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean): Promise<boolean> => {\n        const segmentsToDelete: string[] = [];\n        const remainingSegments: { segment: Segment; lastAccessed: number }[] = [];\n\n        // Delete old segments\n        const now = performance.now();\n\n        for (const cachedSegment of this.cache.values()) {\n            if (now - cachedSegment.lastAccessed > this.settings.cachedSegmentExpiration) {\n                segmentsToDelete.push(cachedSegment.segment.id);\n            } else {\n                remainingSegments.push(cachedSegment);\n            }\n        }\n\n        // Delete segments over cached count\n        let countOverhead = remainingSegments.length - this.settings.cachedSegmentsCount;\n        if (countOverhead > 0) {\n            remainingSegments.sort((a, b) => a.lastAccessed - b.lastAccessed);\n\n            for (const cachedSegment of remainingSegments) {\n                if (lockedSegmentsFilter === undefined || !lockedSegmentsFilter(cachedSegment.segment.id)) {\n                    segmentsToDelete.push(cachedSegment.segment.id);\n                    countOverhead--;\n                    if (countOverhead === 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        segmentsToDelete.forEach((id) => this.cache.delete(id));\n        return segmentsToDelete.length > 0;\n    };\n\n    public destroy = async (): Promise<void> => {\n        this.cache.clear();\n    };\n}\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport Debug from \"debug\";\r\nimport { EventEmitter } from \"events\";\r\nimport Peer from \"simple-peer\";\r\n\r\nimport { LoaderInterface, Events, Segment } from \"./loader-interface\";\r\nimport { HttpMediaManager } from \"./http-media-manager\";\r\nimport { P2PMediaManager } from \"./p2p-media-manager\";\r\nimport { MediaPeerSegmentStatus } from \"./media-peer\";\r\nimport { BandwidthApproximator } from \"./bandwidth-approximator\";\r\nimport { SegmentsMemoryStorage } from \"./segments-memory-storage\";\r\n/*\r\nconst defaultSettings: HybridLoaderSettings = {\r\n    cachedSegmentExpiration: 5 * 60 * 1000,\r\n    cachedSegmentsCount: 30,\r\n\r\n    useP2P: true,\r\n    consumeOnly: false,\r\n\r\n    requiredSegmentsPriority: 1,\r\n\r\n    simultaneousHttpDownloads: 2,\r\n    httpDownloadProbability: 0.1,\r\n    httpDownloadProbabilityInterval: 1000,\r\n    httpDownloadProbabilitySkipIfNoPeers: false,\r\n    httpFailedSegmentTimeout: 10000,\r\n    httpDownloadMaxPriority: 20,\r\n    httpDownloadInitialTimeout: 0,\r\n    httpDownloadInitialTimeoutPerSegment: 4000,\r\n    httpUseRanges: false,\r\n\r\n    simultaneousP2PDownloads: 3,\r\n    p2pDownloadMaxPriority: 20,\r\n    p2pSegmentDownloadTimeout: 60000,\r\n\r\n    webRtcMaxMessageSize: 64 * 1024 - 1,\r\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\r\n    peerRequestsPerAnnounce: 10,\r\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\r\n};*/\r\n\r\n\r\nconst defaultSettings: HybridLoaderSettings = {\r\n    cachedSegmentExpiration: 10 * 60 * 1000,\r\n    cachedSegmentsCount: 1000,\r\n\r\n    useP2P: true,\r\n    consumeOnly: false,\r\n\r\n    requiredSegmentsPriority: 3,\r\n\r\n    simultaneousHttpDownloads: 2,\r\n    httpDownloadProbability: 0.06,\r\n    httpDownloadProbabilityInterval: 1000,\r\n    httpDownloadProbabilitySkipIfNoPeers: false,\r\n    httpFailedSegmentTimeout: 1500,\r\n    httpDownloadMaxPriority: 20,\r\n    httpDownloadInitialTimeout: 0,\r\n    httpDownloadInitialTimeoutPerSegment: 100, ///segment = 4000\r\n    httpUseRanges: false,\r\n\r\n    simultaneousP2PDownloads: 20,\r\n    p2pDownloadMaxPriority: 50,\r\n    p2pSegmentDownloadTimeout: 60000,\r\n\r\n    webRtcMaxMessageSize: 64 * 1024 - 1,\r\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\r\n    peerRequestsPerAnnounce: 10,\r\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\r\n};\r\n\r\nexport class HybridLoader extends EventEmitter implements LoaderInterface {\r\n    private readonly debug = Debug(\"p2pml:hybrid-loader\");\r\n    private readonly debugSegments = Debug(\"p2pml:hybrid-loader-segments\");\r\n    private readonly httpManager: HttpMediaManager;\r\n    private readonly p2pManager: P2PMediaManager;\r\n    private segmentsStorage: SegmentsStorage;\r\n    private segmentsQueue: Segment[] = [];\r\n    private readonly bandwidthApproximator = new BandwidthApproximator();\r\n    private readonly settings: HybridLoaderSettings;\r\n    private httpRandomDownloadInterval: ReturnType<typeof setInterval> | undefined;\r\n    private httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n    private masterSwarmId?: string;\r\n\r\n    public static isSupported = (): boolean => {\r\n        return window.RTCPeerConnection.prototype.createDataChannel !== undefined;\r\n    };\r\n\r\n    public constructor(settings: Partial<HybridLoaderSettings> = {}) {\r\n        super();\r\n\r\n        this.settings = { ...defaultSettings, ...settings };\r\n\r\n        const { bufferedSegmentsCount } = settings as Record<string, unknown>;\r\n\r\n        if (typeof bufferedSegmentsCount === \"number\") {\r\n            if (settings.p2pDownloadMaxPriority === undefined) {\r\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\r\n            }\r\n\r\n            if (settings.httpDownloadMaxPriority === undefined) {\r\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\r\n            }\r\n        }\r\n\r\n        this.segmentsStorage =\r\n            this.settings.segmentsStorage === undefined\r\n                ? new SegmentsMemoryStorage(this.settings)\r\n                : this.settings.segmentsStorage;\r\n\r\n        this.debug(\"loader settings\", this.settings);\r\n\r\n        this.httpManager = this.createHttpManager();\r\n        this.httpManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"http\", segment));\r\n        this.httpManager.on(\"segment-loaded\", this.onSegmentLoaded);\r\n        this.httpManager.on(\"segment-error\", this.onSegmentError);\r\n        this.httpManager.on(\"segment-size\", this.onSegmentSize);\r\n        this.httpManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number) => {\r\n            this.onPieceBytesDownloaded(\"http\", segment, bytes)\r\n        });\r\n\r\n        this.p2pManager = this.createP2PManager();\r\n        this.p2pManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"p2p\", segment));\r\n        this.p2pManager.on(\"segment-loaded\", this.onSegmentLoaded);\r\n        this.p2pManager.on(\"segment-error\", this.onSegmentError);\r\n        this.p2pManager.on(\"segment-size\", this.onSegmentSize);\r\n        this.p2pManager.on(\"peer-data-updated\", async () => {\r\n            if (this.masterSwarmId === undefined) {\r\n                return;\r\n            }\r\n\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        });\r\n        this.p2pManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number, peerId: string) =>\r\n            this.onPieceBytesDownloaded(\"p2p\", segment, bytes, peerId)\r\n        );\r\n        this.p2pManager.on(\"bytes-uploaded\", (segment: Segment, bytes: number, peerId: string) =>\r\n            this.onPieceBytesUploaded(\"p2p\", segment, bytes, peerId)\r\n        );\r\n        this.p2pManager.on(\"peer-connected\", this.onPeerConnect);\r\n        this.p2pManager.on(\"peer-closed\", this.onPeerClose);\r\n        this.p2pManager.on(\"tracker-update\", this.onTrackerUpdate);\r\n    }\r\n\r\n    private createHttpManager = () => {\r\n        return new HttpMediaManager(this.settings);\r\n    };\r\n\r\n    private createP2PManager = () => {\r\n        return new P2PMediaManager(this.segmentsStorage, this.settings);\r\n    };\r\n\r\n    public load = async (segments: Segment[], streamSwarmId: string): Promise<void> => {\r\n        if (this.httpRandomDownloadInterval === undefined) {\r\n            // Do once on first call\r\n            this.httpRandomDownloadInterval = setInterval(\r\n                this.downloadRandomSegmentOverHttp,\r\n                this.settings.httpDownloadProbabilityInterval\r\n            );\r\n\r\n            if (\r\n                this.settings.httpDownloadInitialTimeout > 0 &&\r\n                this.settings.httpDownloadInitialTimeoutPerSegment > 0\r\n            ) {\r\n                // Initialize initial HTTP download timeout (i.e. download initial segments over P2P)\r\n                this.debugSegments(\r\n                    \"enable initial HTTP download timeout\",\r\n                    this.settings.httpDownloadInitialTimeout,\r\n                    \"per segment\",\r\n                    this.settings.httpDownloadInitialTimeoutPerSegment\r\n                );\r\n                this.httpDownloadInitialTimeoutTimestamp = this.now();\r\n                setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment + 100);\r\n            }\r\n        }\r\n\r\n        if (segments.length > 0) {\r\n            this.masterSwarmId = segments[0].masterSwarmId;\r\n        }\r\n\r\n        if (this.masterSwarmId !== undefined) {\r\n            this.p2pManager.setStreamSwarmId(streamSwarmId, this.masterSwarmId);\r\n        }\r\n\r\n        this.debug(\"load segments\");\r\n\r\n        let updateSegmentsMap = false;\r\n\r\n        // stop all http requests and p2p downloads for segments that are not in the new load\r\n        for (const segment of this.segmentsQueue) {\r\n            if (!segments.find((f) => f.url === segment.url)) {\r\n                this.debug(\"remove segment\", segment.url);\r\n                if (this.httpManager.isDownloading(segment)) {\r\n                    updateSegmentsMap = true;\r\n                    this.httpManager.abort(segment);\r\n                } else {\r\n                    this.p2pManager.abort(segment);\r\n                }\r\n                this.emit(Events.SegmentAbort, segment);\r\n            }\r\n        }\r\n\r\n        if (this.debug.enabled) {\r\n            for (const segment of segments) {\r\n                if (!this.segmentsQueue.find((f) => f.url === segment.url)) {\r\n                    this.debug(\"add segment\", segment.url);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.segmentsQueue = segments;\r\n\r\n        if (this.masterSwarmId === undefined) {\r\n            return;\r\n        }\r\n\r\n        let storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n        updateSegmentsMap = this.processSegmentsQueue(storageSegments) || updateSegmentsMap;\r\n\r\n        if (await this.cleanSegmentsStorage()) {\r\n            storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            updateSegmentsMap = true;\r\n        }\r\n\r\n        if (updateSegmentsMap && !this.settings.consumeOnly) {\r\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n        }\r\n    };\r\n\r\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\r\n        return this.masterSwarmId === undefined ? undefined : this.segmentsStorage.getSegment(id, this.masterSwarmId);\r\n    };\r\n\r\n    public getSettings = (): HybridLoaderSettings => {\r\n        return this.settings;\r\n    };\r\n\r\n    public getDetails = (): { peerId: string } => {\r\n        return {\r\n            peerId: this.p2pManager.getPeerId(),\r\n        };\r\n    };\r\n\r\n    public getBandwidthEstimate = (): number => {\r\n        return this.bandwidthApproximator.getBandwidth(this.now());\r\n    };\r\n\r\n    public destroy = async (): Promise<void> => {\r\n        if (this.httpRandomDownloadInterval !== undefined) {\r\n            clearInterval(this.httpRandomDownloadInterval);\r\n            this.httpRandomDownloadInterval = undefined;\r\n        }\r\n\r\n        this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n\r\n        this.segmentsQueue = [];\r\n        this.httpManager.destroy();\r\n        this.p2pManager.destroy();\r\n        this.masterSwarmId = undefined;\r\n        await this.segmentsStorage.destroy();\r\n    };\r\n\r\n    private processInitialSegmentTimeout = async () => {\r\n        if (this.httpRandomDownloadInterval === undefined) {\r\n            return; // Instance destroyed\r\n        }\r\n\r\n        if (this.masterSwarmId !== undefined) {\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        }\r\n\r\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\r\n            // Set one more timeout for a next segment\r\n            setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment);\r\n        }\r\n    };\r\n\r\n    private processSegmentsQueue = (storageSegments: Map<string, { segment: Segment }>) => {\r\n        this.debugSegments(\r\n            \"process segments queue. priority\",\r\n            this.segmentsQueue.length > 0 ? this.segmentsQueue[0].priority : 0\r\n        );\r\n\r\n        if (this.masterSwarmId === undefined || this.segmentsQueue.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        let updateSegmentsMap = false;\r\n        let segmentsMap: Map<string, MediaPeerSegmentStatus> | undefined;\r\n\r\n        let httpAllowed = true;\r\n\r\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\r\n            let firstNotDownloadePriority: number | undefined;\r\n\r\n            for (const segment of this.segmentsQueue) {\r\n                if (!storageSegments.has(segment.id)) {\r\n                    firstNotDownloadePriority = segment.priority;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            const httpTimeout = this.now() - this.httpDownloadInitialTimeoutTimestamp;\r\n            httpAllowed =\r\n                httpTimeout >= this.settings.httpDownloadInitialTimeout ||\r\n                (firstNotDownloadePriority !== undefined &&\r\n                    httpTimeout > this.settings.httpDownloadInitialTimeoutPerSegment &&\r\n                    firstNotDownloadePriority <= 0);\r\n\r\n            if (httpAllowed) {\r\n                this.debugSegments(\"cancel initial HTTP download timeout - timed out\");\r\n                this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this.segmentsQueue.length; index++) {\r\n            const segment = this.segmentsQueue[index];\r\n\r\n            if (storageSegments.has(segment.id)) {\r\n                continue;\r\n            }\r\n\r\n            // Segment priority changed, notify http manager\r\n            if (this.httpManager.isDownloading(segment)) {\r\n                this.httpManager.updatePriority(segment);\r\n                continue;\r\n            }\r\n\r\n            if (\r\n                segment.priority <= this.settings.requiredSegmentsPriority &&\r\n                httpAllowed &&\r\n                !this.httpManager.isFailed(segment)\r\n            ) {\r\n                // Download required segments over HTTP\r\n                if (this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads) {\r\n                    // Not enough HTTP download resources. Abort one of the HTTP downloads.\r\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\r\n                        const segmentToAbort = this.segmentsQueue[i];\r\n                        if (this.httpManager.isDownloading(segmentToAbort)) {\r\n                            this.debugSegments(\"cancel HTTP download\", segmentToAbort.priority, segmentToAbort.url);\r\n                            this.httpManager.abort(segmentToAbort);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.httpManager.getActiveDownloadsCount() < this.settings.simultaneousHttpDownloads) {\r\n                    // Abort P2P download of the required segment if any and force HTTP download\r\n                    const downloadedPieces = this.p2pManager.abort(segment);\r\n                    this.httpManager.download(segment, downloadedPieces);\r\n                    this.debugSegments(\"HTTP download (priority)\", segment.priority, segment.url);\r\n                    updateSegmentsMap = true;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (this.p2pManager.isDownloading(segment)) {\r\n                continue;\r\n            }\r\n\r\n            if (segment.priority <= this.settings.requiredSegmentsPriority) {\r\n                // Download required segments over P2P\r\n                segmentsMap = segmentsMap ? segmentsMap : this.p2pManager.getOverallSegmentsMap();\r\n\r\n                if (segmentsMap.get(segment.id) !== MediaPeerSegmentStatus.Loaded) {\r\n                    continue;\r\n                }\r\n\r\n                if (this.p2pManager.getActiveDownloadsCount() >= this.settings.simultaneousP2PDownloads) {\r\n                    // Not enough P2P download resources. Abort one of the P2P downloads.\r\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\r\n                        const segmentToAbort = this.segmentsQueue[i];\r\n                        if (this.p2pManager.isDownloading(segmentToAbort)) {\r\n                            this.debugSegments(\"cancel P2P download\", segmentToAbort.priority, segmentToAbort.url);\r\n                            this.p2pManager.abort(segmentToAbort);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads) {\r\n                    if (this.p2pManager.download(segment)) {\r\n                        this.debugSegments(\"P2P download (priority)\", segment.priority, segment.url);\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (\r\n                this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads &&\r\n                segment.priority <= this.settings.p2pDownloadMaxPriority\r\n            ) {\r\n                if (this.p2pManager.download(segment)) {\r\n                    this.debugSegments(\"P2P download\", segment.priority, segment.url);\r\n                }\r\n            }\r\n        }\r\n\r\n        return updateSegmentsMap;\r\n    };\r\n\r\n    private downloadRandomSegmentOverHttp = async () => {\r\n        if (\r\n            this.masterSwarmId === undefined ||\r\n            this.httpRandomDownloadInterval === undefined ||\r\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity ||\r\n            this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads ||\r\n            (this.settings.httpDownloadProbabilitySkipIfNoPeers && this.p2pManager.getPeers().size === 0) ||\r\n            this.settings.consumeOnly\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n        const segmentsMap = this.p2pManager.getOverallSegmentsMap();\r\n\r\n        const pendingQueue = this.segmentsQueue.filter(\r\n            (s) =>\r\n                !this.p2pManager.isDownloading(s) &&\r\n                !this.httpManager.isDownloading(s) &&\r\n                !segmentsMap.has(s.id) &&\r\n                !this.httpManager.isFailed(s) &&\r\n                s.priority <= this.settings.httpDownloadMaxPriority &&\r\n                !storageSegments.has(s.id)\r\n        );\r\n\r\n        if (pendingQueue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (Math.random() > this.settings.httpDownloadProbability * pendingQueue.length) {\r\n            return;\r\n        }\r\n\r\n        const segment = pendingQueue[Math.floor(Math.random() * pendingQueue.length)];\r\n        this.debugSegments(\"HTTP download (random)\", segment.priority, segment.url);\r\n        this.httpManager.download(segment);\r\n        this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n    };\r\n\r\n    private onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\r\n        this.emit(Events.SegmentStartLoad, method, segment);\r\n    };\r\n\r\n    private onPieceBytesDownloaded = (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\r\n        this.bandwidthApproximator.addBytes(bytes, this.now());\r\n        this.emit(Events.PieceBytesDownloaded, method, segment, bytes, peerId);\r\n\r\n    };\r\n\r\n    private onPieceBytesUploaded = (method: \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\r\n        this.emit(Events.PieceBytesUploaded, method, segment, bytes, peerId);\r\n    };\r\n\r\n    private onSegmentLoaded = async (segment: Segment, data: ArrayBuffer, peerId?: string) => {\r\n        this.debugSegments(\"segment loaded\", segment.id, segment.url);\r\n\r\n        if (this.masterSwarmId === undefined) {\r\n            return;\r\n        }\r\n\r\n        segment.data = data;\r\n        segment.downloadBandwidth = this.bandwidthApproximator.getBandwidth(this.now());\r\n\r\n        await this.segmentsStorage.storeSegment(segment);\r\n        this.emit(Events.SegmentLoaded, segment, peerId);\r\n\r\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n        this.processSegmentsQueue(storageSegments);\r\n        if (!this.settings.consumeOnly) {\r\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n        }\r\n    };\r\n\r\n    private onSegmentError = async (segment: Segment, details: unknown, peerId?: string) => {\r\n        this.debugSegments(\"segment error\", segment.id, segment.url, peerId, details);\r\n        this.emit(Events.SegmentError, segment, details, peerId);\r\n        if (this.masterSwarmId !== undefined) {\r\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n            }\r\n        }\r\n    };\r\n\r\n    private onSegmentSize = async (segment: Segment, size: number) => {\r\n        this.debugSegments(\"segment size\", segment.id, size);\r\n        this.emit(Events.SegmentSize, segment, size);\r\n    };\r\n\r\n    private getStreamSwarmId = (segment: Segment) => {\r\n        return segment.streamId === undefined ? segment.masterSwarmId : `${segment.masterSwarmId}+${segment.streamId}`;\r\n    };\r\n\r\n    private createSegmentsMap = (storageSegments: Map<string, { segment: Segment }>) => {\r\n        const segmentsMap: { [key: string]: [string, number[]] } = {};\r\n\r\n        const addSegmentToMap = (segment: Segment, status: MediaPeerSegmentStatus) => {\r\n            const streamSwarmId = this.getStreamSwarmId(segment);\r\n            const segmentId = segment.sequence;\r\n\r\n            let segmentsIdsAndStatuses = segmentsMap[streamSwarmId];\r\n            if (segmentsIdsAndStatuses === undefined) {\r\n                segmentsIdsAndStatuses = [\"\", []];\r\n                segmentsMap[streamSwarmId] = segmentsIdsAndStatuses;\r\n            }\r\n            const segmentsStatuses = segmentsIdsAndStatuses[1];\r\n            segmentsIdsAndStatuses[0] += segmentsStatuses.length === 0 ? segmentId : `|${segmentId}`;\r\n            segmentsStatuses.push(status);\r\n        };\r\n\r\n        for (const storageSegment of storageSegments.values()) {\r\n            addSegmentToMap(storageSegment.segment, MediaPeerSegmentStatus.Loaded);\r\n        }\r\n\r\n        for (const download of this.httpManager.getActiveDownloads().values()) {\r\n            addSegmentToMap(download.segment, MediaPeerSegmentStatus.LoadingByHttp);\r\n        }\r\n\r\n        return segmentsMap;\r\n    };\r\n\r\n    private onPeerConnect = async (peer: { id: string }) => {\r\n        this.emit(Events.PeerConnect, peer);\r\n        if (!this.settings.consumeOnly && this.masterSwarmId !== undefined) {\r\n            this.p2pManager.sendSegmentsMap(\r\n                peer.id,\r\n                this.createSegmentsMap(await this.segmentsStorage.getSegmentsMap(this.masterSwarmId))\r\n            );\r\n        }\r\n    };\r\n\r\n    private onPeerClose = (peerId: string) => {\r\n        this.emit(Events.PeerClose, peerId);\r\n    };\r\n\r\n    private onTrackerUpdate = async (data: { incomplete?: number }) => {\r\n        if (\r\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity &&\r\n            data.incomplete !== undefined &&\r\n            data.incomplete <= 1\r\n        ) {\r\n            this.debugSegments(\"cancel initial HTTP download timeout - no peers\");\r\n\r\n            this.httpDownloadInitialTimeoutTimestamp = -Infinity;\r\n\r\n            if (this.masterSwarmId !== undefined) {\r\n                const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\r\n\r\n                if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\r\n                    this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    private cleanSegmentsStorage = async (): Promise<boolean> => {\r\n        if (this.masterSwarmId === undefined) {\r\n            return false;\r\n        }\r\n\r\n        return this.segmentsStorage.clean(\r\n            this.masterSwarmId,\r\n            (id: string) => this.segmentsQueue.find((queueSegment) => queueSegment.id === id) !== undefined\r\n        );\r\n    };\r\n\r\n    private now = () => {\r\n        return performance.now();\r\n    };\r\n}\r\n\r\nexport interface SegmentsStorage {\r\n    storeSegment: (segment: Segment) => Promise<void>;\r\n    getSegmentsMap: (masterSwarmId: string) => Promise<Map<string, { segment: Segment }>>;\r\n    getSegment: (id: string, masterSwarmId: string) => Promise<Segment | undefined>;\r\n    clean: (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean) => Promise<boolean>;\r\n    destroy: () => Promise<void>;\r\n}\r\n\r\nexport type SegmentValidatorCallback = (segment: Segment, method: \"http\" | \"p2p\", peerId?: string) => Promise<void>;\r\nexport type XhrSetupCallback = (xhr: XMLHttpRequest, url: string) => void;\r\nexport type SegmentUrlBuilder = (segment: Segment) => string;\r\n\r\nexport type HybridLoaderSettings = {\r\n    /**\r\n     * Segment lifetime in cache. The segment is deleted from the cache if the last access time is greater than this value (in milliseconds).\r\n     */\r\n    cachedSegmentExpiration: number;\r\n\r\n    /**\r\n     * Max number of segments that can be stored in the cache.\r\n     */\r\n    cachedSegmentsCount: number;\r\n\r\n    /**\r\n     * Enable/Disable peers interaction.\r\n     */\r\n    useP2P: boolean;\r\n\r\n    /**\r\n     * The peer will not upload segments data to the P2P network but still download from others.\r\n     */\r\n    consumeOnly: boolean;\r\n\r\n    /**\r\n     * The maximum priority of the segments to be downloaded (if not available) as quickly as possible (i.e. via HTTP method).\r\n     */\r\n    requiredSegmentsPriority: number;\r\n\r\n    /**\r\n     * Max number of simultaneous downloads from HTTP source.\r\n     */\r\n    simultaneousHttpDownloads: number;\r\n\r\n    /**\r\n     * Probability of downloading remaining not downloaded segment in the segments queue via HTTP.\r\n     */\r\n    httpDownloadProbability: number;\r\n\r\n    /**\r\n     * Interval of the httpDownloadProbability check (in milliseconds).\r\n     */\r\n    httpDownloadProbabilityInterval: number;\r\n\r\n    /**\r\n     * Don't download segments over HTTP randomly when there is no peers.\r\n     */\r\n    httpDownloadProbabilitySkipIfNoPeers: boolean;\r\n\r\n    /**\r\n     * Timeout before trying to load segment again via HTTP after failed attempt (in milliseconds).\r\n     */\r\n    httpFailedSegmentTimeout: number;\r\n\r\n    /**\r\n     * Segments with higher priority will not be downloaded over HTTP.\r\n     */\r\n    httpDownloadMaxPriority: number;\r\n\r\n    /**\r\n     * Try to download initial segments over P2P if the value is > 0.\r\n     * But HTTP download will be forcibly enabled if there is no peers on tracker or\r\n     * single sequential segment P2P download is timed out (see httpDownloadInitialTimeoutPerSegment).\r\n     */\r\n    httpDownloadInitialTimeout: number;\r\n\r\n    /**\r\n     * Use HTTP ranges requests where it is possible.\r\n     * Allows to continue (and not start over) aborted P2P downloads over HTTP.\r\n     */\r\n    httpUseRanges: boolean;\r\n\r\n    /**\r\n     * If initial HTTP download timeout is enabled (see httpDownloadInitialTimeout)\r\n     * this parameter sets additional timeout for a single sequential segment download\r\n     * over P2P. It will cancel initial HTTP download timeout mode if a segment download is timed out.\r\n     */\r\n    httpDownloadInitialTimeoutPerSegment: number;\r\n\r\n    /**\r\n     * Max number of simultaneous downloads from peers.\r\n     */\r\n    simultaneousP2PDownloads: number;\r\n\r\n    /**\r\n     * Segments with higher priority will not be downloaded over P2P.\r\n     */\r\n    p2pDownloadMaxPriority: number;\r\n\r\n    /**\r\n     * Timeout to download a segment from a peer. If exceeded the peer is dropped.\r\n     */\r\n    p2pSegmentDownloadTimeout: number;\r\n\r\n    /**\r\n     * Max WebRTC message size. 64KiB - 1B should work with most of recent browsers. Set it to 16KiB for older browsers support.\r\n     */\r\n    webRtcMaxMessageSize: number;\r\n\r\n    /**\r\n     * Torrent trackers (announcers) to use.\r\n     */\r\n    trackerAnnounce: string[];\r\n\r\n    /**\r\n     * Number of requested peers in each announce for each tracker. Maximum is 10.\r\n     */\r\n    peerRequestsPerAnnounce: number;\r\n\r\n    /**\r\n     * An RTCConfiguration dictionary providing options to configure WebRTC connections.\r\n     */\r\n    rtcConfig: RTCConfiguration;\r\n\r\n    /**\r\n     * Segment validation callback - validates the data after it has been downloaded.\r\n     */\r\n    segmentValidator?: SegmentValidatorCallback;\r\n\r\n    /**\r\n     * XMLHttpRequest setup callback. Handle it when you need additional setup for requests made by the library.\r\n     */\r\n    xhrSetup?: XhrSetupCallback;\r\n\r\n    /**\r\n     * Allow to modify the segment URL before HTTP request.\r\n     */\r\n    segmentUrlBuilder?: SegmentUrlBuilder;\r\n\r\n    /**\r\n     * A storage for the downloaded segments.\r\n     * By default the segments are stored in JavaScript memory.\r\n     */\r\n    segmentsStorage?: SegmentsStorage;\r\n};\r\n","import { LoaderContext } from \"hls.js\"\r\n\r\nexport type ByteRange = { length: number; offset: number } | undefined;\r\n\r\nexport function getByteRange(context: LoaderContext): { offset: number, length: number } | undefined {\r\n  return context.rangeEnd && context.rangeStart !== undefined\r\n      ? { offset: context.rangeStart, length: context.rangeEnd - context.rangeStart }\r\n      : undefined;\r\n}\r\n\r\nexport function compareByteRanges(b1: ByteRange, b2: ByteRange): boolean {\r\n  return b1 === undefined ? b2 === undefined : b2 !== undefined && b1.length === b2.length && b1.offset === b2.offset;\r\n}\r\n\r\nexport function byteRangeToString(byteRange: ByteRange): string | undefined {\r\n  if (byteRange === undefined) {\r\n      return undefined;\r\n  }\r\n\r\n  const end = byteRange.offset + byteRange.length - 1;\r\n\r\n  return `bytes=${byteRange.offset}-${end}`;\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { Events, Segment, LoaderInterface, XhrSetupCallback } from \"../../p2p-media-loader-core/lib\";\r\nimport { Manifest, Parser } from \"m3u8-parser\";\r\nimport { ByteRange, byteRangeToString, compareByteRanges } from \"./byte-range\"\r\nimport { AssetsStorage } from \"./engine\";\r\n\r\nconst defaultSettings: SegmentManagerSettings = {\r\n    forwardSegmentCount: 20,\r\n    swarmId: undefined,\r\n    assetsStorage: undefined,\r\n};\r\n\r\nexport class SegmentManager {\r\n    public readonly loader: LoaderInterface;\r\n    private masterPlaylist: Playlist | null = null;\r\n    private readonly variantPlaylists = new Map<string, Playlist>();\r\n    private segmentRequest: SegmentRequest | null = null;\r\n    private playQueue: {\r\n        segmentSequence: number;\r\n        segmentUrl: string;\r\n        segmentByteRange: ByteRange;\r\n        playPosition?: {\r\n            start: number;\r\n            duration: number;\r\n        };\r\n    }[] = [];\r\n    private readonly settings: SegmentManagerSettings;\r\n\r\n    public constructor(loader: LoaderInterface, settings: Partial<SegmentManagerSettings> = {}) {\r\n        this.settings = { ...defaultSettings, ...settings };\r\n\r\n        this.loader = loader;\r\n        this.loader.on(Events.SegmentLoaded, this.onSegmentLoaded);\r\n        this.loader.on(Events.SegmentError, this.onSegmentError);\r\n        this.loader.on(Events.SegmentAbort, this.onSegmentAbort);\r\n    }\r\n\r\n    public getSettings(): SegmentManagerSettings {\r\n        return this.settings;\r\n    }\r\n\r\n    public processPlaylist(requestUrl: string, content: string, responseUrl: string): void {\r\n        const parser = new Parser();\r\n        parser.push(content);\r\n        parser.end();\r\n\r\n        const playlist = new Playlist(requestUrl, responseUrl, parser.manifest);\r\n\r\n        if (playlist.manifest.playlists) {\r\n            this.masterPlaylist = playlist;\r\n\r\n            for (const [key, variantPlaylist] of this.variantPlaylists) {\r\n                const { streamSwarmId, found, index } = this.getStreamSwarmId(variantPlaylist.requestUrl);\r\n                if (!found) {\r\n                    this.variantPlaylists.delete(key);\r\n                } else {\r\n                    variantPlaylist.streamSwarmId = streamSwarmId;\r\n                    variantPlaylist.streamId = \"V\" + index.toString();\r\n                }\r\n            }\r\n        } else {\r\n            const { streamSwarmId, found, index } = this.getStreamSwarmId(requestUrl);\r\n\r\n            if (found || this.masterPlaylist === null) {\r\n                // do not add audio and subtitles to variants\r\n                playlist.streamSwarmId = streamSwarmId;\r\n                playlist.streamId = this.masterPlaylist === null ? undefined : \"V\" + index.toString();\r\n                this.variantPlaylists.set(requestUrl, playlist);\r\n                this.updateSegments();\r\n            }\r\n        }\r\n    }\r\n\r\n    public async loadPlaylist(url: string): Promise<{ response: string; responseURL: string }> {\r\n        const assetsStorage = this.settings.assetsStorage;\r\n        let xhr: { response: string; responseURL: string } | undefined;\r\n\r\n        if (assetsStorage !== undefined) {\r\n            let masterSwarmId: string | undefined;\r\n            masterSwarmId = this.getMasterSwarmId();\r\n            if (masterSwarmId === undefined) {\r\n                masterSwarmId = url.split(\"?\")[0];\r\n            }\r\n            const asset = await assetsStorage.getAsset(url, undefined, masterSwarmId);\r\n\r\n            if (asset !== undefined) {\r\n                xhr = {\r\n                    responseURL: asset.responseUri,\r\n                    response: asset.data as string,\r\n                };\r\n            } else {\r\n                xhr = await this.loadContent(url, \"text\");\r\n                void assetsStorage.storeAsset({\r\n                    masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : url,\r\n                    masterSwarmId: masterSwarmId,\r\n                    requestUri: url,\r\n                    responseUri: xhr.responseURL,\r\n                    data: xhr.response,\r\n                });\r\n            }\r\n        } else {\r\n            xhr = await this.loadContent(url, \"text\");\r\n        }\r\n\r\n        this.processPlaylist(url, xhr.response, xhr.responseURL);\r\n        return xhr;\r\n    }\r\n\r\n    \r\n\r\n    public async loadSegment(\r\n        url: string,\r\n        byteRange: ByteRange\r\n    ): Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }> {\r\n        const segmentLocation = this.getSegmentLocation(url, byteRange);\r\n        const byteRangeString = byteRangeToString(byteRange);\r\n\r\n        if (!segmentLocation) {\r\n            let content: ArrayBuffer | undefined;\r\n\r\n            // Not a segment from variants; usually can be: init, audio or subtitles segment, encryption key etc.\r\n            const assetsStorage = this.settings.assetsStorage;\r\n            if (assetsStorage !== undefined) {\r\n                let masterManifestUri = this.masterPlaylist?.requestUrl;\r\n\r\n                let masterSwarmId: string | undefined;\r\n                masterSwarmId = this.getMasterSwarmId();\r\n\r\n                if (masterSwarmId === undefined && this.variantPlaylists.size === 1) {\r\n                    const result = this.variantPlaylists.values().next();\r\n                    if (!result.done) {\r\n                        // always true\r\n                        masterSwarmId = result.value.requestUrl.split(\"?\")[0];\r\n                    }\r\n                }\r\n\r\n                if (masterManifestUri === undefined && this.variantPlaylists.size === 1) {\r\n                    const result = this.variantPlaylists.values().next();\r\n                    if (!result.done) {\r\n                        // always true\r\n                        masterManifestUri = result.value.requestUrl;\r\n                    }\r\n                }\r\n\r\n                if (masterSwarmId !== undefined && masterManifestUri !== undefined) {\r\n                    const asset = await assetsStorage.getAsset(url, byteRangeString, masterSwarmId);\r\n                    if (asset !== undefined) {\r\n                        content = asset.data as ArrayBuffer;\r\n                    } else {\r\n                        const xhr = await this.loadContent(url, \"arraybuffer\", byteRangeString);\r\n                        content = xhr.response as ArrayBuffer;\r\n                        void assetsStorage.storeAsset({\r\n                            masterManifestUri: masterManifestUri,\r\n                            masterSwarmId: masterSwarmId,\r\n                            requestUri: url,\r\n                            requestRange: byteRangeString,\r\n                            responseUri: xhr.responseURL,\r\n                            data: content,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (content === undefined) {\r\n                const xhr = await this.loadContent(url, \"arraybuffer\", byteRangeString);\r\n                content = xhr.response as ArrayBuffer;\r\n            }\r\n\r\n            return { content, downloadBandwidth: 0 };\r\n        }\r\n\r\n        const segmentSequence =\r\n            (segmentLocation.playlist.manifest.mediaSequence ? segmentLocation.playlist.manifest.mediaSequence : 0) +\r\n            segmentLocation.segmentIndex;\r\n\r\n        if (this.playQueue.length > 0) {\r\n            const previousSegment = this.playQueue[this.playQueue.length - 1];\r\n            if (previousSegment.segmentSequence !== segmentSequence - 1) {\r\n                // Reset play queue in case of segment loading out of sequence\r\n                this.playQueue = [];\r\n            }\r\n        }\r\n\r\n        if (this.segmentRequest) {\r\n            this.segmentRequest.onError(\"Cancel segment request: simultaneous segment requests are not supported\");\r\n        }\r\n\r\n        const promise = new Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }>(\r\n            (resolve, reject) => {\r\n\r\n                this.segmentRequest = new SegmentRequest(\r\n                    url,\r\n                    byteRange,\r\n                    segmentSequence,\r\n                    segmentLocation.playlist.requestUrl,\r\n                    (content: ArrayBuffer | undefined, downloadBandwidth?: number) =>\r\n                        resolve({ content, downloadBandwidth }),\r\n                    (error) => reject(error)\r\n                );\r\n                \r\n            }\r\n        );\r\n\r\n        this.playQueue.push({ segmentUrl: url, segmentByteRange: byteRange, segmentSequence: segmentSequence });\r\n        void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, true);\r\n\r\n        return promise;\r\n    }\r\n\r\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\r\n        const urlIndex = this.playQueue.findIndex(\r\n            (segment) => segment.segmentUrl === url && compareByteRanges(segment.segmentByteRange, byteRange)\r\n        );\r\n\r\n        if (urlIndex >= 0) {\r\n            this.playQueue = this.playQueue.slice(urlIndex);\r\n            this.playQueue[0].playPosition = { start, duration };\r\n            this.updateSegments();\r\n        }\r\n    }\r\n\r\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\r\n        if (this.playQueue.length === 0 || !this.playQueue[0].playPosition) {\r\n            return;\r\n        }\r\n\r\n        const currentSegmentPosition = this.playQueue[0].playPosition;\r\n        const segmentEndTime = currentSegmentPosition.start + currentSegmentPosition.duration;\r\n\r\n        if (segmentEndTime - playheadPosition < 0.2) {\r\n            // means that current segment is (almost) finished playing\r\n            // remove it from queue\r\n\r\n            this.playQueue = this.playQueue.slice(1);\r\n            this.updateSegments();\r\n        }\r\n    }\r\n\r\n    public abortSegment(url: string, byteRange: ByteRange): void {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === url &&\r\n            compareByteRanges(this.segmentRequest.segmentByteRange, byteRange)\r\n        ) {\r\n            this.segmentRequest.onSuccess(undefined, 0);\r\n            this.segmentRequest = null;\r\n        }\r\n    }\r\n\r\n    public async destroy(): Promise<void> {\r\n        if (this.segmentRequest) {\r\n            this.segmentRequest.onError(\"Loading aborted: object destroyed\");\r\n            this.segmentRequest = null;\r\n        }\r\n\r\n        this.masterPlaylist = null;\r\n        this.variantPlaylists.clear();\r\n        this.playQueue = [];\r\n\r\n        if (this.settings.assetsStorage !== undefined) {\r\n            await this.settings.assetsStorage.destroy();\r\n        }\r\n\r\n        await this.loader.destroy();\r\n    }\r\n\r\n    private updateSegments(): void {\r\n        if (!this.segmentRequest) {\r\n            return;\r\n        }\r\n\r\n        const segmentLocation = this.getSegmentLocation(\r\n            this.segmentRequest.segmentUrl,\r\n            this.segmentRequest.segmentByteRange\r\n        );\r\n        if (segmentLocation) {\r\n            void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, false);\r\n        }\r\n    }\r\n\r\n    private onSegmentLoaded = (segment: Segment) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            this.segmentRequest.onSuccess(segment.data!.slice(0), segment.downloadBandwidth);\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private onSegmentError = (segment: Segment, error: unknown) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            this.segmentRequest.onError(error);\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private onSegmentAbort = (segment: Segment) => {\r\n        if (\r\n            this.segmentRequest &&\r\n            this.segmentRequest.segmentUrl === segment.url &&\r\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\r\n        ) {\r\n            this.segmentRequest.onError(\"Loading aborted: internal abort\");\r\n            this.segmentRequest = null;\r\n        }\r\n    };\r\n\r\n    private getSegmentLocation(\r\n        url: string,\r\n        byteRange: ByteRange\r\n    ): { playlist: Playlist; segmentIndex: number } | undefined {\r\n        for (const playlist of this.variantPlaylists.values()) {\r\n            const segmentIndex = playlist.getSegmentIndex(url, byteRange);\r\n            if (segmentIndex >= 0) {\r\n                return { playlist: playlist, segmentIndex: segmentIndex };\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    private async loadSegments(playlist: Playlist, segmentIndex: number, requestFirstSegment: boolean) {\r\n        const segments: Segment[] = [];\r\n        const playlistSegments = playlist.manifest.segments;\r\n        const initialSequence = playlist.manifest.mediaSequence ?? 0;\r\n        let loadSegmentId: string | null = null;\r\n\r\n        let priority = Math.max(0, this.playQueue.length - 1);\r\n\r\n        const masterSwarmId = this.getMasterSwarmId();\r\n\r\n        for (\r\n            let i = segmentIndex;\r\n            i < playlistSegments.length && segments.length < this.settings.forwardSegmentCount;\r\n            ++i\r\n        ) {\r\n            const segment = playlist.manifest.segments[i];\r\n\r\n            const url = playlist.getSegmentAbsoluteUrl(segment.uri);\r\n            const byteRange: ByteRange = segment.byterange;\r\n            const id = this.getSegmentId(playlist, initialSequence + i);\r\n\r\n            segments.push({\r\n                id: id,\r\n                url: url,\r\n                masterSwarmId: masterSwarmId !== undefined ? masterSwarmId : playlist.streamSwarmId,\r\n                masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : playlist.requestUrl,\r\n                streamId: playlist.streamId,\r\n                sequence: (initialSequence + i).toString(),\r\n                range: byteRangeToString(byteRange),\r\n                priority: priority++,\r\n            });\r\n            if (requestFirstSegment && !loadSegmentId) {\r\n                loadSegmentId = id;\r\n            }\r\n        }\r\n\r\n        this.loader.load(segments, playlist.streamSwarmId);\r\n\r\n        if (loadSegmentId) {\r\n            const segment = await this.loader.getSegment(loadSegmentId);\r\n\r\n\r\n\r\n            if (segment) {\r\n                // Segment already loaded by loader\r\n                this.onSegmentLoaded(segment);\r\n            }\r\n        }\r\n    }\r\n\r\n    private getSegmentId(playlist: Playlist, segmentSequence: number): string {\r\n        return `${playlist.streamSwarmId}+${segmentSequence}`;\r\n    }\r\n\r\n    private getMasterSwarmId() {\r\n        const settingsSwarmId =\r\n            this.settings.swarmId && this.settings.swarmId.length !== 0 ? this.settings.swarmId : undefined;\r\n        if (settingsSwarmId !== undefined) {\r\n            return settingsSwarmId;\r\n        }\r\n\r\n        return this.masterPlaylist !== null ? this.masterPlaylist.requestUrl.split(\"?\")[0] : undefined;\r\n    }\r\n\r\n    private getStreamSwarmId(playlistUrl: string): { streamSwarmId: string; found: boolean; index: number } {\r\n        const masterSwarmId = this.getMasterSwarmId();\r\n\r\n        if (this.masterPlaylist && this.masterPlaylist.manifest.playlists && masterSwarmId) {\r\n            for (let i = 0; i < this.masterPlaylist.manifest.playlists.length; ++i) {\r\n                const url = new URL(\r\n                    this.masterPlaylist.manifest.playlists[i].uri,\r\n                    this.masterPlaylist.responseUrl\r\n                ).toString();\r\n                if (url === playlistUrl) {\r\n                    return { streamSwarmId: `${masterSwarmId}+V${i}`, found: true, index: i };\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            streamSwarmId: masterSwarmId ?? playlistUrl.split(\"?\")[0],\r\n            found: false,\r\n            index: -1,\r\n        };\r\n    }\r\n\r\n    private async loadContent(\r\n        url: string,\r\n        responseType: XMLHttpRequestResponseType,\r\n        range?: string\r\n    ): Promise<XMLHttpRequest> {\r\n        return new Promise<XMLHttpRequest>((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.open(\"GET\", url, true);\r\n            xhr.responseType = responseType;\r\n\r\n            if (range) {\r\n                xhr.setRequestHeader(\"Range\", range);\r\n            }\r\n\r\n            xhr.addEventListener(\"readystatechange\", () => {\r\n                if (xhr.readyState !== 4) return;\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(xhr);\r\n                } else {\r\n                    reject(xhr.statusText);\r\n                }\r\n            });\r\n\r\n            const xhrSetup = (this.loader.getSettings() as { xhrSetup?: XhrSetupCallback }).xhrSetup;\r\n            if (xhrSetup) {\r\n                xhrSetup(xhr, url);\r\n            }\r\n\r\n            xhr.send();\r\n        });\r\n    }\r\n}\r\n\r\nclass Playlist {\r\n    public streamSwarmId = \"\";\r\n    public streamId?: string;\r\n\r\n    public constructor(readonly requestUrl: string, readonly responseUrl: string, readonly manifest: Manifest) {}\r\n\r\n    public getSegmentIndex(url: string, byteRange: ByteRange): number {\r\n        for (let i = 0; i < this.manifest.segments.length; ++i) {\r\n            const segment = this.manifest.segments[i];\r\n            const segmentUrl = this.getSegmentAbsoluteUrl(segment.uri);\r\n\r\n            if (url === segmentUrl && compareByteRanges(segment.byterange, byteRange)) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    public getSegmentAbsoluteUrl(segmentUrl: string): string {\r\n        return new URL(segmentUrl, this.responseUrl).toString();\r\n    }\r\n}\r\n\r\nclass SegmentRequest {\r\n    public constructor(\r\n        readonly segmentUrl: string,\r\n        readonly segmentByteRange: ByteRange,\r\n        readonly segmentSequence: number,\r\n        readonly playlistRequestUrl: string,\r\n        readonly onSuccess: (content: ArrayBuffer | undefined, downloadBandwidth: number | undefined) => void,\r\n        readonly onError: (error: unknown) => void\r\n    ) {}\r\n}\r\n\r\nexport interface SegmentManagerSettings {\r\n    /**\r\n     * Number of segments for building up predicted forward segments sequence; used to predownload and share via P2P\r\n     */\r\n    forwardSegmentCount: number;\r\n\r\n    /**\r\n     * Override default swarm ID that is used to identify unique media stream with trackers (manifest URL without\r\n     * query parameters is used as the swarm ID if the parameter is not specified)\r\n     */\r\n    swarmId?: string;\r\n\r\n    /**\r\n     * A storage for the downloaded assets: manifests, subtitles, init segments, DRM assets etc. By default the assets are not stored.\r\n     */\r\n    assetsStorage?: AssetsStorage;\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { SegmentManager } from \"./segment-manager\";\r\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\r\nimport { Events, Segment } from \"../../p2p-media-loader-core/lib\";\r\nimport { byteRangeToString, getByteRange } from \"./byte-range\"\r\n\r\nexport class HlsJsLoader {\r\n    private isLoaded = false;\r\n    private segmentManager: SegmentManager;\r\n    public stats: LoaderStats = {\r\n        loaded: 0,\r\n        total: 0,\r\n        aborted: false,\r\n        retry: 0,\r\n        chunkCount: 0,\r\n        bwEstimate: 0,\r\n        loading: {\r\n            start: 0,\r\n            end: 0,\r\n            first: 0,\r\n        },\r\n        parsing: {\r\n            start: 0,\r\n            end: 0,\r\n        },\r\n        buffering: {\r\n            start: 0,\r\n            end: 0,\r\n            first: 0,\r\n        },\r\n    };\r\n\r\n    public constructor(segmentManager: SegmentManager) {\r\n        this.segmentManager = segmentManager;\r\n    }\r\n\r\n    public async load(\r\n        context: LoaderContext,\r\n        _config: LoaderConfiguration,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): Promise<void> {\r\n        HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n\r\n        if (((context as unknown) as { type: unknown }).type) {\r\n            try {\r\n                const result = await this.segmentManager.loadPlaylist(context.url);\r\n                this.isLoaded = true;\r\n                this.successPlaylist(result, context, callbacks);\r\n            } catch (e : any) {\r\n                this.error(e, context, callbacks);\r\n            }\r\n        } else if (((context as unknown) as { frag: unknown }).frag) {\r\n            const { loader } = this.segmentManager;\r\n            const byteRange = getByteRange(context)\r\n\r\n            const isSegment = (segment: Segment) => {\r\n                return segment.url === context.url && segment.range === byteRangeToString(byteRange)\r\n            }\r\n\r\n            // We may be downloading the segment by P2P, so we don't care about the stats sent to HLS ABR\r\n            let updateStart: NodeJS.Timeout | undefined = setInterval(() => {\r\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n            }, 200)\r\n\r\n            const onUpdateSegmentSize = (segment: Segment, size: number) => {\r\n                if (!isSegment(segment)) return\r\n\r\n                this.stats.total = size\r\n            };\r\n            loader.on(Events.SegmentSize, onUpdateSegmentSize)\r\n\r\n            const onUpdateLoaded = (_type: unknown, segment: Segment, bytes: number) => {\r\n                if (!isSegment(segment)) return\r\n\r\n                this.stats.loaded += bytes\r\n            };\r\n\r\n            const onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\r\n                if (!updateStart || method !== \"http\" || !isSegment(segment)) return\r\n\r\n                clearInterval(updateStart)\r\n                updateStart = undefined\r\n\r\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\r\n\r\n                loader.on(Events.PieceBytesDownloaded, onUpdateLoaded)\r\n            };\r\n\r\n            loader.on(Events.SegmentStartLoad, onSegmentStartLoad)\r\n\r\n\r\n            try {\r\n                const result = await this.segmentManager.loadSegment(context.url, byteRange);\r\n                const { content } = result;\r\n                if (content) {\r\n                    this.isLoaded = true;\r\n                    setTimeout(() => this.successSegment(content, context, callbacks), 0);\r\n                }\r\n\r\n            } catch (e : any) {\r\n                setTimeout(() => this.error(e, context, callbacks), 0);\r\n            } finally {\r\n\r\n                clearInterval(updateStart)\r\n                loader.off(Events.SegmentStartLoad, onSegmentStartLoad)\r\n                loader.off(Events.SegmentSize, onUpdateSegmentSize)\r\n                loader.off(Events.PieceBytesDownloaded, onUpdateLoaded)\r\n            }\r\n\r\n\r\n\r\n\r\n        } else {\r\n            console.warn(\"Unknown load request\", context);\r\n        }\r\n    }\r\n\r\n    public abort(context: LoaderContext, callbacks?: LoaderCallbacks<LoaderContext>): void {\r\n        if (this.isLoaded) return;\r\n\r\n        this.segmentManager.abortSegment(context.url, getByteRange(context));\r\n        this.stats.aborted = true;\r\n\r\n        const onAbort = callbacks?.onAbort;\r\n        if (onAbort) {\r\n            onAbort(this.stats, context, undefined);\r\n        }\r\n    }\r\n\r\n    private successPlaylist(\r\n        xhr: { response: string; responseURL: string },\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        const now = performance.now();\r\n\r\n        this.stats.loading.end = now;\r\n        this.stats.loaded = xhr.response.length;\r\n        this.stats.total = xhr.response.length;\r\n\r\n        callbacks.onSuccess(\r\n            {\r\n                url: xhr.responseURL,\r\n                data: xhr.response,\r\n            },\r\n            this.stats,\r\n            context,\r\n            undefined\r\n        );\r\n    }\r\n\r\n    private successSegment(\r\n        content: ArrayBuffer,\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        const now = performance.now();\r\n\r\n        this.stats.loading.end = now;\r\n        this.stats.loaded = content.byteLength;\r\n        this.stats.total = content.byteLength;\r\n\r\n        if (callbacks.onProgress) {\r\n            callbacks.onProgress(this.stats, context, content, undefined);\r\n        }\r\n\r\n        callbacks.onSuccess(\r\n            {\r\n                url: context.url,\r\n                data: content,\r\n            },\r\n            this.stats,\r\n            context,\r\n            undefined\r\n        );\r\n    }\r\n\r\n    private error(\r\n        error: { code: number; text: string },\r\n        context: LoaderContext,\r\n        callbacks: LoaderCallbacks<LoaderContext>\r\n    ): void {\r\n        callbacks.onError(error, context, undefined);\r\n    }\r\n\r\n    private static updateStatsToStartLoading (stats: LoaderStats) {\r\n        const start = performance.now();\r\n        stats.loading.start = start;\r\n        stats.loading.first = start;\r\n    }\r\n}\r\n","/**\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { EventEmitter } from \"events\";\r\nimport { Events, LoaderInterface, HybridLoader, HybridLoaderSettings } from \"../../p2p-media-loader-core/lib\";\r\nimport { SegmentManager, SegmentManagerSettings } from \"./segment-manager\";\r\nimport { HlsJsLoader } from \"./hlsjs-loader\";\r\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\r\nimport { ByteRange } from \"./byte-range\"\r\n\r\nexport interface HlsJsEngineSettings {\r\n    loader: Partial<HybridLoaderSettings>;\r\n    segments: Partial<SegmentManagerSettings>;\r\n}\r\n\r\nexport class Engine extends EventEmitter {\r\n    public static isSupported(): boolean {\r\n        return HybridLoader.isSupported();\r\n    }\r\n\r\n    private readonly loader: LoaderInterface;\r\n    private readonly segmentManager: SegmentManager;\r\n\r\n    public constructor(settings: Partial<HlsJsEngineSettings> = {}) {\r\n        super();\r\n\r\n        this.loader = new HybridLoader(settings.loader);\r\n        this.segmentManager = new SegmentManager(this.loader, settings.segments);\r\n\r\n        Object.keys(Events)\r\n            .map((eventKey) => Events[eventKey as keyof typeof Events])\r\n            .forEach((event) => this.loader.on(event, (...args: unknown[]) => this.emit(event, ...args)));\r\n    }\r\n\r\n    public createLoaderClass(): new () => unknown {\r\n        const engine = this; // eslint-disable-line @typescript-eslint/no-this-alias\r\n        return class {\r\n            private impl: HlsJsLoader;\r\n            private context?: LoaderContext;\r\n            private callbacks?: LoaderCallbacks<LoaderContext>;\r\n            public stats: LoaderStats;\r\n\r\n            constructor() {\r\n                this.impl = new HlsJsLoader(engine.segmentManager);\r\n                this.stats = this.impl.stats;\r\n            }\r\n\r\n            load = async (\r\n                context: LoaderContext,\r\n                config: LoaderConfiguration,\r\n                callbacks: LoaderCallbacks<LoaderContext>\r\n            ) => {\r\n                this.context = context;\r\n                this.callbacks = callbacks;\r\n                this.impl.load(context, config, callbacks);\r\n\r\n            };\r\n\r\n            abort = () => {\r\n                if (this.context) {\r\n                    this.impl.abort(this.context, this.callbacks);\r\n                }\r\n            };\r\n\r\n            destroy = () => {\r\n                if (this.context) {\r\n                    this.impl.abort(this.context);\r\n                }\r\n            };\r\n\r\n            getResponseHeader = () => undefined;\r\n\r\n            static getEngine = () => {\r\n                return engine;\r\n            };\r\n        };\r\n    }\r\n\r\n    public async destroy(): Promise<void> {\r\n        await this.segmentManager.destroy();\r\n    }\r\n\r\n    public getSettings(): {\r\n        segments: SegmentManagerSettings;\r\n        loader: unknown;\r\n    } {\r\n        return {\r\n            segments: this.segmentManager.getSettings(),\r\n            loader: this.loader.getSettings(),\r\n        };\r\n    }\r\n\r\n    public getDetails(): unknown {\r\n        return {\r\n            loader: this.loader.getDetails(),\r\n        };\r\n    }\r\n\r\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\r\n        this.segmentManager.setPlayingSegment(url, byteRange, start, duration);\r\n    }\r\n\r\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\r\n        this.segmentManager.setPlayingSegmentByCurrentTime(playheadPosition);\r\n    }\r\n\r\n}\r\n\r\nexport interface Asset {\r\n    masterSwarmId: string;\r\n    masterManifestUri: string;\r\n    requestUri: string;\r\n    requestRange?: string;\r\n    responseUri: string;\r\n    data: ArrayBuffer | string;\r\n}\r\n\r\nexport interface AssetsStorage {\r\n    storeAsset(asset: Asset): Promise<void>;\r\n    getAsset(requestUri: string, requestRange: string | undefined, masterSwarmId: string): Promise<Asset | undefined>;\r\n    destroy(): Promise<void>;\r\n}\r\n","/**\r\n * @license Apache-2.0\r\n * Copyright 2018 Novage LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/* eslint-disable */\r\n\r\nexport const version = \"0.6.2\";\r\nexport * from \"./engine\";\r\nexport * from \"./segment-manager\";\r\n\r\nimport { Engine } from \"./engine\";\r\n\r\ndeclare const videojs: any;\r\n\r\ndeclare global {\r\n    interface Window {\r\n        p2pml: Record<string, unknown>;\r\n    }\r\n}\r\n\r\nexport function initHlsJsPlayer(player: any): void {\r\n    if (player && player.config && player.config.loader && typeof player.config.loader.getEngine === \"function\") {\r\n        initHlsJsEvents(player, player.config.loader.getEngine());\r\n    }\r\n}\r\n\r\nexport function initClapprPlayer(player: any): void {\r\n    player.on(\"play\", () => {\r\n        const playback = player.core.getCurrentPlayback();\r\n        if (playback._hls && !playback._hls._p2pm_linitialized) {\r\n            playback._hls._p2pm_linitialized = true;\r\n            initHlsJsPlayer(player.core.getCurrentPlayback()._hls);\r\n        }\r\n    });\r\n}\r\n\r\nexport function initFlowplayerHlsJsPlayer(player: any): void {\r\n    player.on(\"ready\", () => initHlsJsPlayer(player.engine.hlsjs ?? player.engine.hls));\r\n}\r\n\r\nexport function initVideoJsContribHlsJsPlayer(player: any): void {\r\n    player.ready(() => {\r\n        const options = player.tech_.options_;\r\n        if (\r\n            options &&\r\n            options.hlsjsConfig &&\r\n            options.hlsjsConfig.loader &&\r\n            typeof options.hlsjsConfig.loader.getEngine === \"function\"\r\n        ) {\r\n            initHlsJsEvents(player.tech_, options.hlsjsConfig.loader.getEngine());\r\n        }\r\n    });\r\n}\r\n\r\nexport function initVideoJsHlsJsPlugin(): void {\r\n    if (videojs == undefined || videojs.Html5Hlsjs == undefined) {\r\n        return;\r\n    }\r\n\r\n    videojs.Html5Hlsjs.addHook(\"beforeinitialize\", (videojsPlayer: any, hlsjs: any) => {\r\n        if (hlsjs.config && hlsjs.config.loader && typeof hlsjs.config.loader.getEngine === \"function\") {\r\n            initHlsJsEvents(hlsjs, hlsjs.config.loader.getEngine());\r\n        }\r\n    });\r\n}\r\n\r\nexport function initMediaElementJsPlayer(mediaElement: any): void {\r\n\r\n\r\n    mediaElement.addEventListener(\"hlsFragChanged\", (event: any) => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            const engine: Engine = hls.config.loader.getEngine();\r\n\r\n            if (event.data && event.data.length > 1) {\r\n                const frag = event.data[1].frag;\r\n                const byteRange =\r\n                    frag.byteRange.length !== 2\r\n                        ? undefined\r\n                        : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\r\n                engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\r\n            }\r\n        }\r\n    });\r\n    mediaElement.addEventListener(\"hlsDestroying\", async () => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            const engine: Engine = hls.config.loader.getEngine();\r\n            await engine.destroy();\r\n        }\r\n    });\r\n    mediaElement.addEventListener(\"hlsError\", (event: any) => {\r\n        const hls = mediaElement.hlsPlayer;\r\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\r\n            if (event.data !== undefined && event.data.details === \"bufferStalledError\") {\r\n                const engine: Engine = hls.config.loader.getEngine();\r\n                engine.setPlayingSegmentByCurrentTime(hls.media.currentTime);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function initJwPlayer(player: any, hlsjsConfig: any): void {\r\n    const iid = setInterval(() => {\r\n        if (player.hls && player.hls.config) {\r\n            clearInterval(iid);\r\n            Object.assign(player.hls.config, hlsjsConfig);\r\n            initHlsJsPlayer(player.hls);\r\n        }\r\n    }, 200);\r\n}\r\n\r\nfunction initHlsJsEvents(player: any, engine: Engine): void {\r\n    player.on(\"hlsFragChanged\", (_event: string, data: any) => {\r\n        const frag = data.frag;\r\n        const byteRange =\r\n            frag.byteRange.length !== 2\r\n                ? undefined\r\n                : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\r\n        engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\r\n    });\r\n    player.on(\"hlsDestroying\", async () => {\r\n        await engine.destroy();\r\n    });\r\n    player.on(\"hlsError\", (_event: string, errorData: { details: string }) => {\r\n        if (errorData.details === \"bufferStalledError\") {\r\n            const htmlMediaElement = (player.media === undefined\r\n                ? player.el_ // videojs-contrib-hlsjs\r\n                : player.media) as HTMLMediaElement | undefined; // all others\r\n            if (htmlMediaElement) {\r\n                engine.setPlayingSegmentByCurrentTime(htmlMediaElement.currentTime);\r\n            }\r\n        }\r\n    });\r\n}\r\n"],"sourceRoot":""}