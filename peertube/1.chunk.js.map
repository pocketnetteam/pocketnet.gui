{"version":3,"sources":["webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/loader-interface.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/stringly-typed-event-emitter.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/http-media-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/media-peer.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/p2p-media-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/bandwidth-approximator.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/segments-memory-storage.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/hybrid-loader.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/byte-range.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/segment-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/hlsjs-loader.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/engine.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/index.ts"],"names":["Events","on","event","listener","super","emit","args","settings","fetchRequests","Map","failedSegments","debug","fetch","download","segment","downloadedPieces","this","isDownloading","cleanTimedOutFailedSegments","segmentUrl","buildSegmentUrl","requestUrl","headers","Headers","range","append","undefined","httpUseRanges","bytesDownloaded","piece","byteLength","fetchAbort","AbortController","signal","fetchRequest","setupFetchEvents","fetchResponse","set","id","initialPriority","priority","updatePriority","request","get","Error","requiredSegmentsPriority","abort","delete","has","isFailed","time","now","getActiveDownloads","getActiveDownloadsCount","size","destroy","forEach","clear","catch","error","segmentFailure","dataReader","body","getReader","contentLengthStr","contentLength","Number","parseFloat","dataBytes","Uint8Array","nextChunkPos","Array","isArray","status","pieceBytes","read","done","chunkBytes","value","length","err","url","segmentDownloadFinished","buffer","data","responseUrl","segmentValidator","httpFailedSegmentTimeout","candidates","push","performance","localTransport","segmentUrlBuilder","MediaPeerCommands","MediaPeerSegmentStatus","DownloadingSegment","pieces","peer","remoteAddress","downloadingSegmentId","downloadingSegment","segmentsMap","timer","onPeerConnect","onPeerClose","terminateSegmentRequest","onPeerError","receiveSegmentPiece","segmentId","segmentData","offset","getJsonCommand","bytes","JSON","parse","TextDecoder","decode","onPeerData","command","c","SegmentsMap","createSegmentsMap","m","SegmentRequest","i","SegmentData","s","cancelResponseTimeoutTimer","SegmentAbsent","CancelSegmentRequest","segments","Object","streamSwarmId","keys","swarmData","segmentsIds","split","segmentsStatuses","segmentStatus","sendCommand","write","stringify","getDownloadingSegmentId","getSegmentsMap","sendSegmentsMap","sendSegmentData","bytesLeft","bytesToSend","webRtcMaxMessageSize","from","sendSegmentAbsent","requestSegment","runResponseTimeoutTimer","cancelSegmentRequest","setTimeout","p2pSegmentDownloadTimeout","clearTimeout","PEER_ID_VERSION_PREFIX","replace","v","parseInt","slice","PeerSegmentRequest","peerId","segmentsStorage","trackerClient","peers","peerCandidates","peerSegmentRequests","pendingTrackerClient","getPeers","getPeerId","toString","setStreamSwarmId","masterSwarmId","isDestroyed","infoHash","update","digest","createClient","useP2P","clientOptions","announce","trackerAnnounce","rtcConfig","port","getAnnounceOpts","numwant","peerRequestsPerAnnounce","oldTrackerClient","onTrackerError","onTrackerWarning","onTrackerUpdate","onTrackerPeer","start","warning","trackerPeer","onPeerDataUpdated","onSegmentRequest","onSegmentLoaded","onSegmentAbsent","onSegmentError","onSegmentSize","onSegmentStartLoad","onSegmentTimeout","onPieceBytesDownloaded","onPieceBytesUploaded","peerCandidatesById","values","Loaded","Math","floor","random","peerSegmentRequest","swarmChange","stop","removeAllListeners","peerCandidateById","peerCandidate","sendSegmentsMapToAll","getOverallSegmentsMap","overallSegmentsMap","LoadingByHttp","index","indexOf","splice","key","getSegment","description","PEER_ID_SYMBOLS","charAt","TextEncoder","encode","generatePeerId","ArrayBuffer","enabled","SMOOTH_INTERVAL","NumberWithTime","timeStamp","BandwidthApproximator","lastBytes","currentBytesSum","lastBandwidth","addBytes","shift","interval","min","getBandwidth","maxBandwidth","bandwidth","getSmoothInterval","getMeasureInterval","cache","storeSegment","lastAccessed","cacheItem","hasSegment","clean","lockedSegmentsFilter","segmentsToDelete","remainingSegments","cachedSegment","cachedSegmentExpiration","countOverhead","cachedSegmentsCount","sort","a","b","defaultSettings","consumeOnly","simultaneousHttpDownloads","httpDownloadProbability","httpDownloadProbabilityInterval","httpDownloadProbabilitySkipIfNoPeers","httpDownloadMaxPriority","httpDownloadInitialTimeout","httpDownloadInitialTimeoutPerSegment","simultaneousP2PDownloads","p2pDownloadMaxPriority","config","debugSegments","segmentsQueue","bandwidthApproximator","httpDownloadInitialTimeoutTimestamp","Infinity","createHttpManager","createP2PManager","load","httpRandomDownloadInterval","setInterval","downloadRandomSegmentOverHttp","processInitialSegmentTimeout","p2pManager","updateSegmentsMap","find","f","httpManager","SegmentAbort","storageSegments","processSegmentsQueue","cleanSegmentsStorage","getSettings","getDetails","getBandwidthEstimate","clearInterval","httpAllowed","firstNotDownloadePriority","httpTimeout","segmentToAbort","pendingQueue","filter","method","SegmentStartLoad","PieceBytesDownloaded","PieceBytesUploaded","downloadBandwidth","SegmentLoaded","details","SegmentError","SegmentSize","getStreamSwarmId","streamId","addSegmentToMap","sequence","segmentsIdsAndStatuses","storageSegment","PeerConnect","PeerClose","incomplete","queueSegment","bufferedSegmentsCount","isSupported","window","RTCPeerConnection","prototype","createDataChannel","getByteRange","context","rangeEnd","rangeStart","compareByteRanges","b1","b2","byteRangeToString","byteRange","end","forwardSegmentCount","swarmId","assetsStorage","loader","masterPlaylist","variantPlaylists","segmentRequest","playQueue","segmentByteRange","onSuccess","onError","onSegmentAbort","content","parser","playlist","manifest","playlists","variantPlaylist","found","updateSegments","res","getMasterSwarmId","asset","getAsset","responseURL","responseUri","response","loadContent","text","storeAsset","masterManifestUri","requestUri","processPlaylist","segmentLocation","getSegmentLocation","byteRangeString","result","next","arrayBuffer","requestRange","segmentSequence","mediaSequence","segmentIndex","promise","Promise","resolve","reject","loadSegments","duration","urlIndex","findIndex","playPosition","playheadPosition","currentSegmentPosition","getSegmentIndex","requestFirstSegment","playlistSegments","initialSequence","loadSegmentId","max","getSegmentAbsoluteUrl","uri","byterange","getSegmentId","settingsSwarmId","playlistUrl","URL","playlistRequestUrl","segmentManager","isLoaded","stats","loaded","total","aborted","retry","chunkCount","bwEstimate","loading","first","parsing","buffering","_config","callbacks","updateStatsToStartLoading","type","loadPlaylist","successPlaylist","e","frag","isSegment","updateStart","onUpdateSegmentSize","onUpdateLoaded","_type","loadSegment","successSegment","off","console","warn","abortSegment","onAbort","xhr","onProgress","map","eventKey","engine","impl","getResponseHeader","getEngine","setPlayingSegment","setPlayingSegmentByCurrentTime","version","initHlsJsPlayer","player","initHlsJsEvents","initClapprPlayer","playback","core","getCurrentPlayback","_hls","_p2pm_linitialized","initFlowplayerHlsJsPlayer","hlsjs","hls","initVideoJsContribHlsJsPlayer","ready","options","tech_","options_","hlsjsConfig","initVideoJsHlsJsPlugin","videojs","Html5Hlsjs","addHook","videojsPlayer","initMediaElementJsPlayer","mediaElement","addEventListener","hlsPlayer","media","currentTime","initJwPlayer","iid","assign","_event","errorData","htmlMediaElement","el_"],"mappings":"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","file":"1.chunk.js?v=9443","sourcesContent":["/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { EventEmitter } from \"events\";\n\nexport type Segment = {\n    readonly id: string;\n    readonly url: string;\n    readonly masterSwarmId: string;\n    readonly masterManifestUri: string;\n    readonly streamId: string | undefined;\n    readonly sequence: string;\n    readonly range: string | undefined;\n    readonly priority: number;\n    data?: ArrayBuffer;\n    downloadBandwidth?: number;\n    requestUrl?: string;\n    responseUrl?: string;\n};\n\nexport enum Events {\n    /**\n     * Emitted when segment has been downloaded.\n     * Args: segment\n     */\n    SegmentLoaded = \"segment_loaded\",\n\n    /**\n     * Emitted when an error occurred while loading the segment.\n     * Args: segment, error\n     */\n    SegmentError = \"segment_error\",\n\n\n    /**\n     * Emitter when we the segment size is known\n     * Args: segment, size\n     */\n    SegmentSize = \"segment_size\",\n\n    /**\n     * Emitted for each segment that does not hit into a new segments queue when the load() method is called.\n     * Args: segment\n     */\n    SegmentAbort = \"segment_abort\",\n\n\n    /**\n     * Emitted when the loader started to load a segment\n     * Args: method, segment\n     */\n    SegmentStartLoad = \"segment_start_load\",\n\n    /**\n     * Emitted when a peer is connected.\n     * Args: peer\n     */\n    PeerConnect = \"peer_connect\",\n\n    /**\n     * Emitted when a peer is disconnected.\n     * Args: peerId\n     */\n    PeerClose = \"peer_close\",\n\n    /**\n     * Emitted when a segment piece has been downloaded.\n     * Args: method (can be \"http\" or \"p2p\" only), bytes\n     */\n    PieceBytesDownloaded = \"piece_bytes_downloaded\",\n\n    /**\n     * Emitted when a segment piece has been uploaded.\n     * Args: method (can be \"p2p\" only), bytes\n     */\n    PieceBytesUploaded = \"piece_bytes_uploaded\",\n}\n\nexport interface LoaderInterface extends EventEmitter {\n    on: ((eventName: string, listener: (...params: unknown[]) => void) => this) &\n        ((eventName: Events.SegmentStartLoad, listener: (method: \"http\" | \"p2p\", segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentSize, listener: (segment: Segment, size: number) => void) => this) &\n        ((eventName: Events.PieceBytesDownloaded | Events.PieceBytesUploaded, listener: (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => void) => this) &\n        ((eventName: Events.SegmentLoaded, listener: (segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentError, listener: (segment: Segment, error: unknown) => void) => this) &\n        ((eventName: Events.SegmentAbort, listener: (segment: Segment) => void) => this);\n    load: (segments: Segment[], streamSwarmId: string) => void;\n    getSegment: (id: string) => Promise<Segment | undefined>;\n    getSettings: () => unknown;\n    getDetails: () => unknown;\n    getBandwidthEstimate: () => number;\n    destroy: () => Promise<void>;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { EventEmitter } from \"events\";\n\nexport class STEEmitter<T extends string | symbol> extends EventEmitter {\n    public on = (event: T, listener: (...args: any[]) => void): this => super.on(event, listener);\n    public emit = (event: T, ...args: any[]): boolean => super.emit(event, ...args);\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\nimport { Segment } from \"./loader-interface\";\nimport { SegmentValidatorCallback /*, XhrSetupCallback */, SegmentUrlBuilder } from \"./hybrid-loader\";\n\nclass FilteredEmitter extends STEEmitter<\n    \"segment-start-load\" | \"segment-loaded\" | \"segment-error\" | \"segment-size\" | \"bytes-downloaded\"\n> { }\n\nexport class HttpMediaManager extends FilteredEmitter {\n    private fetchRequests = new Map<string, { fetchResponse: Response; fetchAbort: AbortController, segment: Segment, initialPriority: number, segmentUrl: string }>();\n    private failedSegments = new Map<string, number>();\n    private debug = Debug(\"p2pml:http-media-manager\");\n    private fetch: typeof fetch = (...args) => fetch(...args);\n\n    public constructor(\n        readonly settings: {\n            httpFailedSegmentTimeout: number;\n            httpUseRanges: boolean;\n            requiredSegmentsPriority: number;\n            segmentValidator?: SegmentValidatorCallback;\n            /* xhrSetup?: XhrSetupCallback; */\n            segmentUrlBuilder?: SegmentUrlBuilder;\n            localTransport?: typeof fetch;\n        }\n    ) {\n        super();\n\n        if (settings.localTransport) {\n            this.fetch = settings.localTransport;\n        }\n    }\n\n    public download = async (segment: Segment, downloadedPieces?: ArrayBuffer[]): Promise<void> => {\n        if (this.isDownloading(segment)) {\n            return;\n        }\n\n        this.cleanTimedOutFailedSegments();\n\n        this.emit(\"segment-start-load\", segment);\n\n        const segmentUrl = this.buildSegmentUrl(segment);\n\n        this.debug(\"http segment download\", segmentUrl);\n\n        segment.requestUrl = segmentUrl;\n\n        const headers = new Headers();\n\n        if (segment.range) {\n            headers.append('Range', segment.range);\n        } else if (downloadedPieces !== undefined && this.settings.httpUseRanges) {\n            let bytesDownloaded = 0;\n            for (const piece of downloadedPieces) {\n                bytesDownloaded += piece.byteLength;\n            }\n\n            headers.append(\"Range\", `bytes=${bytesDownloaded}-`);\n\n            this.debug(\"continue download from\", bytesDownloaded);\n        } else {\n            downloadedPieces = undefined;\n        }\n\n        const fetchAbort = new AbortController();\n        const signal = fetchAbort.signal;\n\n        const fetchRequest = this.fetch(segmentUrl, { headers, signal });\n\n        void this.setupFetchEvents(fetchRequest, segment, downloadedPieces);\n\n        /* if (this.settings.xhrSetup) {\n            this.settings.xhrSetup(xhr, segmentUrl);\n        } */\n\n        const fetchResponse = await fetchRequest;\n\n        this.fetchRequests.set(segment.id, { fetchResponse, fetchAbort, segment, initialPriority: segment.priority, segmentUrl });\n    };\n\n    public updatePriority = (segment: Segment): void => {\n        const request = this.fetchRequests.get(segment.id);\n\n        if (!request) {\n            throw new Error(\"Cannot update priority of not downloaded segment \" + segment.id);\n        }\n\n        // Segment is now in high priority\n        // If the segment URL changed, retry the request with the new URL\n        if (\n            segment.priority <= this.settings.requiredSegmentsPriority &&\n            request.initialPriority > this.settings.requiredSegmentsPriority &&\n            request.segmentUrl !== this.buildSegmentUrl(segment)\n        ) {\n            this.debug(\"aborting http segment abort because the segment is now in a high priority\", segment.id);\n            this.abort(segment)\n            void this.download(segment)\n        }\n\n    }\n\n    public abort = (segment: Segment): void => {\n        const request = this.fetchRequests.get(segment.id);\n\n        if (request) {\n            request.fetchAbort.abort();\n            this.fetchRequests.delete(segment.id);\n            this.debug(\"http segment abort\", segment.id);\n        }\n    };\n\n    public isDownloading = (segment: Segment): boolean => {\n        return this.fetchRequests.has(segment.id);\n    };\n\n    public isFailed = (segment: Segment): boolean => {\n        const time = this.failedSegments.get(segment.id);\n        return time !== undefined && time > this.now();\n    };\n\n    public getActiveDownloads = (): ReadonlyMap<string, { segment: Segment }> => {\n        return this.fetchRequests;\n    };\n\n    public getActiveDownloadsCount = (): number => {\n        return this.fetchRequests.size;\n    };\n\n    public destroy = (): void => {\n        this.fetchRequests.forEach((request) => request.fetchAbort.abort());\n        this.fetchRequests.clear();\n    };\n\n    private setupFetchEvents = async (fetch: Promise<Response>, segment: Segment, downloadedPieces?: ArrayBuffer[]) => {\n        const fetchResponse = await fetch.catch((error) => {\n            this.segmentFailure(segment, error, \"url_not_retrieved\");\n        }) as Response & { body: ReadableStream };\n\n        const dataReader = fetchResponse.body.getReader();\n\n        const contentLengthStr = fetchResponse.headers.get(\"Content-Length\") as string;\n\n        const contentLength = Number.parseFloat(contentLengthStr);\n\n        const dataBytes: Uint8Array = new Uint8Array(contentLength);\n\n        let done = false;\n        let nextChunkPos = 0;\n\n        if (Array.isArray(downloadedPieces) && fetchResponse.status === 206) {\n            for (const piece of downloadedPieces) {\n                const pieceBytes = new Uint8Array(piece);\n\n                dataBytes.set(pieceBytes, nextChunkPos);\n\n                nextChunkPos = piece.byteLength;\n            }\n        }\n\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const read = await dataReader.read();\n\n            if (read.done) {\n                break;\n            }\n\n            const chunkBytes = read.value;\n\n            dataBytes.set(chunkBytes, nextChunkPos);\n\n            nextChunkPos += chunkBytes.length;\n\n            /** Events emitters */\n\n            this.emit(\"bytes-downloaded\", segment, chunkBytes.length);\n\n            if (contentLength) {\n                this.emit(\"segment-size\", segment, contentLength);\n            }\n        }\n\n        if (fetchResponse.status < 200 || fetchResponse.status >= 300) {\n            const err = Error(`Segment failure with HTTP code ${fetchResponse.status}`);\n            this.segmentFailure(segment, err, fetchResponse.url);\n            return;\n        }\n\n        await this.segmentDownloadFinished(segment, dataBytes.buffer, fetchResponse);\n    };\n\n    private segmentDownloadFinished = async (segment: Segment, data: ArrayBuffer, fetchResponse: Response) => {\n        segment.responseUrl = fetchResponse.url;\n\n        if (this.settings.segmentValidator) {\n            try {\n                await this.settings.segmentValidator({ ...segment, data: data }, \"http\");\n            } catch (error) {\n                this.debug(\"segment validator failed\", error);\n                this.segmentFailure(segment, error, fetchResponse.url);\n                return;\n            }\n        }\n\n        this.fetchRequests.delete(segment.id);\n        this.emit(\"segment-loaded\", segment, data);\n    };\n\n    private segmentFailure = (segment: Segment, error: Error, responseUrl: string) => {\n        segment.responseUrl = responseUrl;\n\n        this.fetchRequests.delete(segment.id);\n        this.failedSegments.set(segment.id, this.now() + this.settings.httpFailedSegmentTimeout);\n        this.emit(\"segment-error\", segment, error);\n    };\n\n    private cleanTimedOutFailedSegments = () => {\n        const now = this.now();\n        const candidates: string[] = [];\n\n        this.failedSegments.forEach((time, id) => {\n            if (time < now) {\n                candidates.push(id);\n            }\n        });\n\n        candidates.forEach((id) => this.failedSegments.delete(id));\n    };\n\n    private buildSegmentUrl (segment: Segment) {\n        if (this.settings.segmentUrlBuilder) {\n            return this.settings.segmentUrlBuilder(segment);\n        }\n\n        return segment.url;\n    }\n\n    private now = () => performance.now();\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nimport Debug from \"debug\";\nimport { Buffer } from \"buffer\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\n\nenum MediaPeerCommands {\n    SegmentData,\n    SegmentAbsent,\n    SegmentsMap,\n    SegmentRequest,\n    CancelSegmentRequest,\n}\n\ntype MediaPeerCommand =\n    | {\n          c:\n              | MediaPeerCommands.SegmentAbsent\n              | MediaPeerCommands.SegmentRequest\n              | MediaPeerCommands.CancelSegmentRequest;\n          i: string;\n      }\n    | {\n          c: MediaPeerCommands.SegmentsMap;\n          m: { [key: string]: [string, number[]] };\n      }\n    | {\n          c: MediaPeerCommands.SegmentData;\n          i: string;\n          s: number;\n      };\n\nexport enum MediaPeerSegmentStatus {\n    Loaded,\n    LoadingByHttp,\n}\n\nclass DownloadingSegment {\n    public bytesDownloaded = 0;\n    public pieces: ArrayBuffer[] = [];\n    constructor(readonly id: string, readonly size: number) {}\n}\n\nexport class MediaPeer extends STEEmitter<\n    | \"connect\"\n    | \"close\"\n    | \"data-updated\"\n    | \"segment-start-load\"\n    | \"segment-request\"\n    | \"segment-absent\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-timeout\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n> {\n    public id: string;\n    public remoteAddress = \"\";\n    private downloadingSegmentId: string | null = null;\n    private downloadingSegment: DownloadingSegment | null = null;\n    private segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n    private debug = Debug(\"p2pml:media-peer\");\n    private timer: ReturnType<typeof setTimeout> | null = null;\n\n    constructor(\n        // eslint-disable-next-line\n        readonly peer: any,\n        readonly settings: {\n            p2pSegmentDownloadTimeout: number;\n            webRtcMaxMessageSize: number;\n        }\n    ) {\n        super();\n\n        this.peer.on(\"connect\", this.onPeerConnect);\n        this.peer.on(\"close\", this.onPeerClose);\n        this.peer.on(\"error\", this.onPeerError);\n        this.peer.on(\"data\", this.onPeerData);\n\n        this.id = peer.id;\n    }\n\n    private onPeerConnect = () => {\n        this.debug(\"peer connect\", this.id, this);\n        this.remoteAddress = this.peer.remoteAddress;\n        this.emit(\"connect\", this);\n    };\n\n    private onPeerClose = () => {\n        this.debug(\"peer close\", this.id, this);\n        this.terminateSegmentRequest();\n        this.emit(\"close\", this);\n    };\n\n    private onPeerError = (error: unknown) => {\n        this.debug(\"peer error\", this.id, error, this);\n    };\n\n    private receiveSegmentPiece = (data: ArrayBuffer): void => {\n        if (!this.downloadingSegment) {\n            // The segment was not requested or canceled\n            this.debug(\"peer segment not requested\", this.id, this);\n            return;\n        }\n\n        this.downloadingSegment.bytesDownloaded += data.byteLength;\n        this.downloadingSegment.pieces.push(data);\n\n        const segmentId = this.downloadingSegment.id;\n        this.emit(\"bytes-downloaded\", this, segmentId, data.byteLength);\n\n        if (this.downloadingSegment.bytesDownloaded === this.downloadingSegment.size) {\n            const segmentData = new Uint8Array(this.downloadingSegment.size);\n            let offset = 0;\n            for (const piece of this.downloadingSegment.pieces) {\n                segmentData.set(new Uint8Array(piece), offset);\n                offset += piece.byteLength;\n            }\n\n            this.debug(\"peer segment download done\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-loaded\", this, segmentId, segmentData.buffer);\n        } else if (this.downloadingSegment.bytesDownloaded > this.downloadingSegment.size) {\n            this.debug(\"peer segment download bytes mismatch\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Too many bytes received for segment\");\n        }\n    };\n\n    private getJsonCommand = (data: ArrayBuffer) => {\n        const bytes = new Uint8Array(data);\n\n        // Serialized JSON string check by first, second and last characters: '{\" .... }'\n        if (bytes[0] === 123 && bytes[1] === 34 && bytes[data.byteLength - 1] === 125) {\n            try {\n                return JSON.parse(new TextDecoder().decode(data)) as Record<string, unknown>;\n            } catch {\n                return null;\n            }\n        }\n\n        return null;\n    };\n\n    private onPeerData = (data: ArrayBuffer) => {\n        const command = this.getJsonCommand(data);\n\n        if (command === null) {\n            this.receiveSegmentPiece(data);\n            return;\n        }\n\n        if (this.downloadingSegment) {\n            this.debug(\"peer segment download is interrupted by a command\", this.id, this);\n\n            const segmentId = this.downloadingSegment.id;\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Segment download is interrupted by a command\");\n            return;\n        }\n\n        this.debug(\"peer receive command\", this.id, command, this);\n\n        switch (command.c) {\n            case MediaPeerCommands.SegmentsMap:\n                this.segmentsMap = this.createSegmentsMap(command.m);\n                this.emit(\"data-updated\");\n                break;\n\n            case MediaPeerCommands.SegmentRequest:\n                this.emit(\"segment-request\", this, command.i);\n                break;\n\n            case MediaPeerCommands.SegmentData:\n                if (\n                    this.downloadingSegmentId &&\n                    this.downloadingSegmentId === command.i &&\n                    typeof command.s === \"number\" &&\n                    command.s >= 0\n                ) {\n                    this.downloadingSegment = new DownloadingSegment(command.i, command.s);\n                    this.emit(\"segment-start-load\", this.downloadingSegment.id)\n                    this.emit(\"segment-size\", this.downloadingSegment.id, this.downloadingSegment.size)\n                    this.cancelResponseTimeoutTimer();\n                }\n                break;\n\n            case MediaPeerCommands.SegmentAbsent:\n                if (this.downloadingSegmentId && this.downloadingSegmentId === command.i) {\n                    this.terminateSegmentRequest();\n                    this.segmentsMap.delete(command.i);\n                    this.emit(\"segment-absent\", this, command.i);\n                }\n                break;\n\n            case MediaPeerCommands.CancelSegmentRequest:\n                // TODO: peer stop sending buffer\n                break;\n\n            default:\n                break;\n        }\n    };\n\n    private createSegmentsMap = (segments: unknown) => {\n        if (!(segments instanceof Object)) {\n            return new Map<string, MediaPeerSegmentStatus>();\n        }\n\n        const segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const streamSwarmId of Object.keys(segments)) {\n            const swarmData = (segments as Record<string, unknown>)[streamSwarmId];\n            if (\n                !(swarmData instanceof Array) ||\n                swarmData.length !== 2 ||\n                typeof swarmData[0] !== \"string\" ||\n                !(swarmData[1] instanceof Array)\n            ) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            const segmentsIds = swarmData[0].split(\"|\");\n            const segmentsStatuses = swarmData[1] as MediaPeerSegmentStatus[];\n\n            if (segmentsIds.length !== segmentsStatuses.length) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            for (let i = 0; i < segmentsIds.length; i++) {\n                const segmentStatus = segmentsStatuses[i];\n                if (typeof segmentStatus !== \"number\" || MediaPeerSegmentStatus[segmentStatus] === undefined) {\n                    return new Map<string, MediaPeerSegmentStatus>();\n                }\n\n                segmentsMap.set(`${streamSwarmId}+${segmentsIds[i]}`, segmentStatus);\n            }\n        }\n\n        return segmentsMap;\n    };\n\n    private sendCommand = (command: MediaPeerCommand): void => {\n        this.debug(\"peer send command\", this.id, command, this);\n        this.peer.write(JSON.stringify(command));\n    };\n\n    public destroy = (): void => {\n        this.debug(\"peer destroy\", this.id, this);\n        this.terminateSegmentRequest();\n        this.peer.destroy();\n    };\n\n    public getDownloadingSegmentId = (): string | null => {\n        return this.downloadingSegmentId;\n    };\n\n    public getSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        return this.segmentsMap;\n    };\n\n    public sendSegmentsMap = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentsMap, m: segmentsMap });\n    };\n\n    public sendSegmentData = (segmentId: string, data: ArrayBuffer): void => {\n        this.sendCommand({\n            c: MediaPeerCommands.SegmentData,\n            i: segmentId,\n            s: data.byteLength,\n        });\n\n        let bytesLeft = data.byteLength;\n        while (bytesLeft > 0) {\n            const bytesToSend =\n                bytesLeft >= this.settings.webRtcMaxMessageSize ? this.settings.webRtcMaxMessageSize : bytesLeft;\n            const buffer = Buffer.from(data, data.byteLength - bytesLeft, bytesToSend);\n\n            this.peer.write(buffer);\n            bytesLeft -= bytesToSend;\n        }\n\n        this.emit(\"bytes-uploaded\", this, segmentId, data.byteLength);\n    };\n\n    public sendSegmentAbsent = (segmentId: string): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentAbsent, i: segmentId });\n    };\n\n    public requestSegment = (segmentId: string): void => {\n        if (this.downloadingSegmentId) {\n            throw new Error(\"A segment is already downloading: \" + this.downloadingSegmentId);\n        }\n\n        this.sendCommand({ c: MediaPeerCommands.SegmentRequest, i: segmentId });\n        this.downloadingSegmentId = segmentId;\n        this.runResponseTimeoutTimer();\n    };\n\n    public cancelSegmentRequest = (): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n\n        if (this.downloadingSegmentId) {\n            const segmentId = this.downloadingSegmentId;\n            downloadingSegment = this.downloadingSegment ? this.downloadingSegment.pieces : undefined;\n            this.terminateSegmentRequest();\n            this.sendCommand({ c: MediaPeerCommands.CancelSegmentRequest, i: segmentId });\n        }\n\n        return downloadingSegment;\n    };\n\n    private runResponseTimeoutTimer = (): void => {\n        this.timer = setTimeout(() => {\n            this.timer = null;\n            if (!this.downloadingSegmentId) {\n                return;\n            }\n            const segmentId = this.downloadingSegmentId;\n            this.cancelSegmentRequest();\n            this.emit(\"segment-timeout\", this, segmentId); // TODO: send peer not responding event\n        }, this.settings.p2pSegmentDownloadTimeout);\n    };\n\n    private cancelResponseTimeoutTimer = (): void => {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n\n    private terminateSegmentRequest = () => {\n        this.downloadingSegmentId = null;\n        this.downloadingSegment = null;\n        this.cancelResponseTimeoutTimer();\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nimport Debug from \"debug\";\nimport Client from \"bittorrent-tracker/client\";\nimport { Buffer } from \"buffer\";\nimport sha1 from \"sha.js/sha1\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\nimport { Segment } from \"./loader-interface\";\nimport { MediaPeer, MediaPeerSegmentStatus } from \"./media-peer\";\nimport { SegmentsStorage, SegmentValidatorCallback } from \"./hybrid-loader\";\n\nconst PEER_PROTOCOL_VERSION = 2;\nconst PEER_ID_VERSION_STRING = '0.6.2'.replace(/\\d*./g, (v) => `0${parseInt(v, 10) % 100}`.slice(-2)).slice(0, 4);\nconst PEER_ID_VERSION_PREFIX = `-WW${PEER_ID_VERSION_STRING}-`; // Using WebTorrent client ID in order to not be banned by websocket trackers\n\nclass PeerSegmentRequest {\n    constructor(readonly peerId: string, readonly segment: Segment) {}\n}\n\nfunction generatePeerId(): ArrayBuffer {\n    const PEER_ID_SYMBOLS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const PEER_ID_LENGTH = 20;\n\n    let peerId = PEER_ID_VERSION_PREFIX;\n\n    for (let i = 0; i < PEER_ID_LENGTH - PEER_ID_VERSION_PREFIX.length; i++) {\n        peerId += PEER_ID_SYMBOLS.charAt(Math.floor(Math.random() * PEER_ID_SYMBOLS.length));\n    }\n\n    return new TextEncoder().encode(peerId).buffer;\n}\n\nexport class P2PMediaManager extends STEEmitter<\n    | \"peer-connected\"\n    | \"peer-closed\"\n    | \"peer-data-updated\"\n    | \"segment-start-load\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n    | \"tracker-update\"\n> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private trackerClient: any = null;\n    private peers = new Map<string, MediaPeer>();\n    private peerCandidates = new Map<string, MediaPeer[]>();\n    private peerSegmentRequests = new Map<string, PeerSegmentRequest>();\n    private streamSwarmId: string | null = null;\n    private readonly peerId: ArrayBuffer;\n    private debug = Debug(\"p2pml:p2p-media-manager\");\n    private pendingTrackerClient: {\n        isDestroyed: boolean;\n    } | null = null;\n    private masterSwarmId?: string;\n\n    public constructor(\n        private segmentsStorage: SegmentsStorage,\n        private settings: {\n            useP2P: boolean;\n            trackerAnnounce: string[];\n            p2pSegmentDownloadTimeout: number;\n            segmentValidator?: SegmentValidatorCallback;\n            webRtcMaxMessageSize: number;\n            rtcConfig?: RTCConfiguration;\n            peerRequestsPerAnnounce: number;\n        }\n    ) {\n        super();\n\n        this.peerId = settings.useP2P ? generatePeerId() : new ArrayBuffer(0);\n\n        if (this.debug.enabled) {\n            this.debug(\"peer ID\", this.getPeerId(), new TextDecoder().decode(this.peerId));\n        }\n    }\n\n    public getPeers = (): Map<string, MediaPeer> => {\n        return this.peers;\n    };\n\n    public getPeerId = (): string => {\n        return Buffer.from(this.peerId).toString(\"hex\");\n    };\n\n    public setStreamSwarmId = (streamSwarmId: string, masterSwarmId: string): void => {\n        if (this.streamSwarmId === streamSwarmId) {\n            return;\n        }\n\n        this.destroy(true);\n\n        this.streamSwarmId = streamSwarmId;\n        this.masterSwarmId = masterSwarmId;\n        this.debug(\"stream swarm ID\", this.streamSwarmId);\n\n        this.pendingTrackerClient = {\n            isDestroyed: false,\n        };\n\n        const pendingTrackerClient = this.pendingTrackerClient;\n\n        // TODO: native browser 'crypto.subtle' implementation doesn't work in Chrome in insecure pages\n        // TODO: Edge doesn't support SHA-1. Change to SHA-256 once Edge support is required.\n        // const infoHash = await crypto.subtle.digest(\"SHA-1\", new TextEncoder().encode(PEER_PROTOCOL_VERSION + this.streamSwarmId));\n\n        const infoHash = new sha1().update(`${PEER_PROTOCOL_VERSION}${this.streamSwarmId}`).digest();\n\n        // destroy may be called while waiting for the hash to be calculated\n        if (!pendingTrackerClient.isDestroyed) {\n            this.pendingTrackerClient = null;\n            this.createClient(infoHash);\n        } else if (this.trackerClient !== null) {\n            this.trackerClient.destroy();\n            this.trackerClient = null;\n        }\n    };\n\n    private createClient = (infoHash: ArrayBuffer): void => {\n        if (!this.settings.useP2P) {\n            return;\n        }\n\n        const clientOptions = {\n            infoHash: Buffer.from(infoHash, 0, 20),\n            peerId: Buffer.from(this.peerId, 0, 20),\n            announce: this.settings.trackerAnnounce,\n            rtcConfig: this.settings.rtcConfig,\n            port: 6881, // a dummy value allows running in Node.js environment\n            getAnnounceOpts: () => {\n                return { numwant: this.settings.peerRequestsPerAnnounce };\n            },\n        };\n\n        let oldTrackerClient = this.trackerClient;\n\n        this.trackerClient = new Client(clientOptions);\n        this.trackerClient.on(\"error\", this.onTrackerError);\n        this.trackerClient.on(\"warning\", this.onTrackerWarning);\n        this.trackerClient.on(\"update\", this.onTrackerUpdate);\n        this.trackerClient.on(\"peer\", this.onTrackerPeer);\n\n        this.trackerClient.start();\n\n        if (oldTrackerClient !== null) {\n            oldTrackerClient.destroy();\n            oldTrackerClient = null;\n        }\n    };\n\n    private onTrackerError = (error: unknown) => {\n        this.debug(\"tracker error\", error);\n    };\n\n    private onTrackerWarning = (warning: unknown) => {\n        this.debug(\"tracker warning\", warning);\n    };\n\n    private onTrackerUpdate = (data: unknown): void => {\n        this.debug(\"tracker update\", data);\n        this.emit(\"tracker-update\", data);\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private onTrackerPeer = (trackerPeer: any): void => {\n        this.debug(\"tracker peer\", trackerPeer.id, trackerPeer);\n\n        if (this.peers.has(trackerPeer.id)) {\n            this.debug(\"tracker peer already connected\", trackerPeer.id, trackerPeer);\n            trackerPeer.destroy();\n            return;\n        }\n\n        const peer = new MediaPeer(trackerPeer, this.settings);\n\n        peer.on(\"connect\", this.onPeerConnect);\n        peer.on(\"close\", this.onPeerClose);\n        peer.on(\"data-updated\", this.onPeerDataUpdated);\n        peer.on(\"segment-request\", this.onSegmentRequest);\n        peer.on(\"segment-loaded\", this.onSegmentLoaded);\n        peer.on(\"segment-absent\", this.onSegmentAbsent);\n        peer.on(\"segment-error\", this.onSegmentError);\n        peer.on(\"segment-size\", this.onSegmentSize);\n        peer.on(\"segment-start-load\", this.onSegmentStartLoad);\n        peer.on(\"segment-timeout\", this.onSegmentTimeout);\n        peer.on(\"bytes-downloaded\", this.onPieceBytesDownloaded);\n        peer.on(\"bytes-uploaded\", this.onPieceBytesUploaded);\n\n        let peerCandidatesById = this.peerCandidates.get(peer.id);\n\n        if (!peerCandidatesById) {\n            peerCandidatesById = [];\n            this.peerCandidates.set(peer.id, peerCandidatesById);\n        }\n\n        peerCandidatesById.push(peer);\n    };\n\n    public download = (segment: Segment): boolean => {\n        if (this.isDownloading(segment)) {\n            return false;\n        }\n\n        const candidates: MediaPeer[] = [];\n\n        for (const peer of this.peers.values()) {\n            if (\n                peer.getDownloadingSegmentId() === null &&\n                peer.getSegmentsMap().get(segment.id) === MediaPeerSegmentStatus.Loaded\n            ) {\n                candidates.push(peer);\n            }\n        }\n\n        if (candidates.length === 0) {\n            return false;\n        }\n\n        const peer = candidates[Math.floor(Math.random() * candidates.length)];\n        peer.requestSegment(segment.id);\n        this.peerSegmentRequests.set(segment.id, new PeerSegmentRequest(peer.id, segment));\n        return true;\n    };\n\n    public abort = (segment: Segment): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n        const peerSegmentRequest = this.peerSegmentRequests.get(segment.id);\n        if (peerSegmentRequest) {\n            const peer = this.peers.get(peerSegmentRequest.peerId);\n            if (peer) {\n                downloadingSegment = peer.cancelSegmentRequest();\n            }\n            this.peerSegmentRequests.delete(segment.id);\n        }\n        return downloadingSegment;\n    };\n\n    public isDownloading = (segment: Segment): boolean => {\n        return this.peerSegmentRequests.has(segment.id);\n    };\n\n    public getActiveDownloadsCount = (): number => {\n        return this.peerSegmentRequests.size;\n    };\n\n    public destroy = (swarmChange = false): void => {\n        this.streamSwarmId = null;\n\n        if (this.trackerClient) {\n            this.trackerClient.stop();\n            if (swarmChange) {\n                // Don't destroy trackerClient to reuse its WebSocket connection to the tracker server\n                this.trackerClient.removeAllListeners(\"error\");\n                this.trackerClient.removeAllListeners(\"warning\");\n                this.trackerClient.removeAllListeners(\"update\");\n                this.trackerClient.removeAllListeners(\"peer\");\n            } else {\n                this.trackerClient.destroy();\n                this.trackerClient = null;\n            }\n        }\n\n        if (this.pendingTrackerClient) {\n            this.pendingTrackerClient.isDestroyed = true;\n            this.pendingTrackerClient = null;\n        }\n\n        this.peers.forEach((peer) => peer.destroy());\n        this.peers.clear();\n\n        this.peerSegmentRequests.clear();\n\n        for (const peerCandidateById of this.peerCandidates.values()) {\n            for (const peerCandidate of peerCandidateById) {\n                peerCandidate.destroy();\n            }\n        }\n        this.peerCandidates.clear();\n    };\n\n    public sendSegmentsMapToAll = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.peers.forEach((peer) => peer.sendSegmentsMap(segmentsMap));\n    };\n\n    public sendSegmentsMap = (peerId: string, segmentsMap: { [key: string]: [string, number[]] }): void => {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.sendSegmentsMap(segmentsMap);\n        }\n    };\n\n    public getOverallSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        const overallSegmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const peer of this.peers.values()) {\n            for (const [segmentId, segmentStatus] of peer.getSegmentsMap()) {\n                if (segmentStatus === MediaPeerSegmentStatus.Loaded) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.Loaded);\n                } else if (!overallSegmentsMap.get(segmentId)) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.LoadingByHttp);\n                }\n            }\n        }\n\n        return overallSegmentsMap;\n    };\n\n    private onPieceBytesDownloaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"bytes-downloaded\", peerSegmentRequest.segment, bytes, peer.id);\n        }\n    };\n\n    private onPieceBytesUploaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        \n        this.emit(\"bytes-uploaded\", peerSegmentRequest ? peerSegmentRequest.segment : null, bytes, peer.id);\n      \n    };\n\n    private onPeerConnect = (peer: MediaPeer) => {\n        const connectedPeer = this.peers.get(peer.id);\n\n        if (connectedPeer) {\n            this.debug(\"tracker peer already connected (in peer connect)\", peer.id, peer);\n            peer.destroy();\n            return;\n        }\n\n        // First peer with the ID connected\n        this.peers.set(peer.id, peer);\n\n        // Destroy all other peer candidates\n        const peerCandidatesById = this.peerCandidates.get(peer.id);\n        if (peerCandidatesById) {\n            for (const peerCandidate of peerCandidatesById) {\n                if (peerCandidate !== peer) {\n                    peerCandidate.destroy();\n                }\n            }\n\n            this.peerCandidates.delete(peer.id);\n        }\n\n        this.emit(\"peer-connected\", { id: peer.id, remoteAddress: peer.remoteAddress });\n    };\n\n    private onPeerClose = (peer: MediaPeer) => {\n        if (this.peers.get(peer.id) !== peer) {\n            // Try to delete the peer candidate\n\n            const peerCandidatesById = this.peerCandidates.get(peer.id);\n            if (!peerCandidatesById) {\n                return;\n            }\n\n            const index = peerCandidatesById.indexOf(peer);\n            if (index !== -1) {\n                peerCandidatesById.splice(index, 1);\n            }\n\n            if (peerCandidatesById.length === 0) {\n                this.peerCandidates.delete(peer.id);\n            }\n\n            return;\n        }\n\n        for (const [key, value] of this.peerSegmentRequests) {\n            if (value.peerId === peer.id) {\n                this.peerSegmentRequests.delete(key);\n            }\n        }\n\n        this.peers.delete(peer.id);\n        this.emit(\"peer-data-updated\");\n        this.emit(\"peer-closed\", peer.id);\n    };\n\n    private onPeerDataUpdated = () => {\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentRequest = async (peer: MediaPeer, segmentId: string) => {\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        const segment = await this.segmentsStorage.getSegment(segmentId, this.masterSwarmId);\n        if (segment && segment.data) {\n            peer.sendSegmentData(segmentId, segment.data);\n        } else {\n            peer.sendSegmentAbsent(segmentId);\n        }\n    };\n\n    private onSegmentLoaded = async (peer: MediaPeer, segmentId: string, data: ArrayBuffer) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (!peerSegmentRequest) {\n            return;\n        }\n\n        const segment = peerSegmentRequest.segment;\n\n        if (this.settings.segmentValidator) {\n            try {\n                await this.settings.segmentValidator({ ...segment, data: data }, \"p2p\", peer.id);\n            } catch (error) {\n                this.debug(\"segment validator failed\", error);\n                this.peerSegmentRequests.delete(segmentId);\n                this.emit(\"segment-error\", segment, error, peer.id);\n                this.onPeerClose(peer);\n                return;\n            }\n        }\n\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"segment-loaded\", segment, data, peer.id);\n    };\n\n    private onSegmentAbsent = (peer: MediaPeer, segmentId: string) => {\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentError = (peer: MediaPeer, segmentId: string, description: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            this.emit(\"segment-error\", peerSegmentRequest.segment, description, peer.id);\n        }\n    };\n\n    private onSegmentSize = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-size\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentStartLoad = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-start-load\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentTimeout = (peer: MediaPeer, segmentId: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            peer.destroy();\n            if (this.peers.delete(peerSegmentRequest.peerId)) {\n                this.emit(\"peer-data-updated\");\n            }\n        }\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\n\nconst debug = Debug(\"p2pml:bandwidth-approximator\");\n\nconst SMOOTH_INTERVAL = 2 * 1000;\nconst MEASURE_INTERVAL = 40 * 1000;\n\nclass NumberWithTime {\n    constructor(readonly value: number, readonly timeStamp: number) {}\n}\n\nexport class BandwidthApproximator {\n    private lastBytes: NumberWithTime[] = [];\n    private currentBytesSum = 0;\n    private lastBandwidth: NumberWithTime[] = [];\n\n    public addBytes = (bytes: number, timeStamp: number): void => {\n        debug(\"Add %d bytes.\", bytes)\n\n        this.lastBytes.push(new NumberWithTime(bytes, timeStamp));\n        this.currentBytesSum += bytes;\n\n        while (timeStamp - this.lastBytes[0].timeStamp > SMOOTH_INTERVAL) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.currentBytesSum -= this.lastBytes.shift()!.value;\n        }\n\n        const interval = Math.min(SMOOTH_INTERVAL, timeStamp);\n        this.lastBandwidth.push(new NumberWithTime(this.currentBytesSum / interval, timeStamp));\n    };\n\n    // in bytes per millisecond\n    public getBandwidth = (timeStamp: number): number => {\n        while (this.lastBandwidth.length !== 0 && timeStamp - this.lastBandwidth[0].timeStamp > MEASURE_INTERVAL) {\n            this.lastBandwidth.shift();\n        }\n\n        let maxBandwidth = 0;\n        for (const bandwidth of this.lastBandwidth) {\n            if (bandwidth.value > maxBandwidth) {\n                maxBandwidth = bandwidth.value;\n            }\n        }\n\n        debug(\"Max bandwidth: %d.\", maxBandwidth)\n\n        return maxBandwidth;\n    };\n\n    public getSmoothInterval = (): number => {\n        return SMOOTH_INTERVAL;\n    };\n\n    public getMeasureInterval = (): number => {\n        return MEASURE_INTERVAL;\n    };\n}\n","/**\n * Copyright 2019 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Segment } from \"./loader-interface\";\nimport { SegmentsStorage } from \"./hybrid-loader\";\n\nexport class SegmentsMemoryStorage implements SegmentsStorage {\n    private cache = new Map<string, { segment: Segment; lastAccessed: number }>();\n\n    constructor(\n        private settings: {\n            cachedSegmentExpiration: number;\n            cachedSegmentsCount: number;\n        }\n    ) {}\n\n    public storeSegment = async (segment: Segment): Promise<void> => {\n        this.cache.set(segment.id, { segment, lastAccessed: performance.now() });\n    };\n\n    public getSegmentsMap = async (): Promise<Map<string, { segment: Segment }>> => {\n        return this.cache;\n    };\n\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\n        const cacheItem = this.cache.get(id);\n\n        if (cacheItem === undefined) {\n            return undefined;\n        }\n\n        cacheItem.lastAccessed = performance.now();\n        return cacheItem.segment;\n    };\n\n    public hasSegment = async (id: string): Promise<boolean> => {\n        return this.cache.has(id);\n    };\n\n    public clean = async (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean): Promise<boolean> => {\n        const segmentsToDelete: string[] = [];\n        const remainingSegments: { segment: Segment; lastAccessed: number }[] = [];\n\n        // Delete old segments\n        const now = performance.now();\n\n        for (const cachedSegment of this.cache.values()) {\n            if (now - cachedSegment.lastAccessed > this.settings.cachedSegmentExpiration) {\n                segmentsToDelete.push(cachedSegment.segment.id);\n            } else {\n                remainingSegments.push(cachedSegment);\n            }\n        }\n\n        // Delete segments over cached count\n        let countOverhead = remainingSegments.length - this.settings.cachedSegmentsCount;\n        if (countOverhead > 0) {\n            remainingSegments.sort((a, b) => a.lastAccessed - b.lastAccessed);\n\n            for (const cachedSegment of remainingSegments) {\n                if (lockedSegmentsFilter === undefined || !lockedSegmentsFilter(cachedSegment.segment.id)) {\n                    segmentsToDelete.push(cachedSegment.segment.id);\n                    countOverhead--;\n                    if (countOverhead === 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        segmentsToDelete.forEach((id) => this.cache.delete(id));\n        return segmentsToDelete.length > 0;\n    };\n\n    public destroy = async (): Promise<void> => {\n        this.cache.clear();\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\nimport { EventEmitter } from \"events\";\nimport Peer from \"simple-peer\";\n\nimport { LoaderInterface, Events, Segment } from \"./loader-interface\";\nimport { HttpMediaManager } from \"./http-media-manager\";\nimport { P2PMediaManager } from \"./p2p-media-manager\";\nimport { MediaPeerSegmentStatus } from \"./media-peer\";\nimport { BandwidthApproximator } from \"./bandwidth-approximator\";\nimport { SegmentsMemoryStorage } from \"./segments-memory-storage\";\n/*\nconst defaultSettings: HybridLoaderSettings = {\n    cachedSegmentExpiration: 5 * 60 * 1000,\n    cachedSegmentsCount: 30,\n\n    useP2P: true,\n    consumeOnly: false,\n\n    requiredSegmentsPriority: 1,\n\n    simultaneousHttpDownloads: 2,\n    httpDownloadProbability: 0.1,\n    httpDownloadProbabilityInterval: 1000,\n    httpDownloadProbabilitySkipIfNoPeers: false,\n    httpFailedSegmentTimeout: 10000,\n    httpDownloadMaxPriority: 20,\n    httpDownloadInitialTimeout: 0,\n    httpDownloadInitialTimeoutPerSegment: 4000,\n    httpUseRanges: false,\n\n    simultaneousP2PDownloads: 3,\n    p2pDownloadMaxPriority: 20,\n    p2pSegmentDownloadTimeout: 60000,\n\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\n    peerRequestsPerAnnounce: 10,\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\n};*/\n\n\nconst defaultSettings: HybridLoaderSettings & { localTransport?: typeof fetch } = {\n    cachedSegmentExpiration: 10 * 60 * 1000,\n    cachedSegmentsCount: 1000,\n\n    useP2P: true,\n    consumeOnly: false,\n\n    requiredSegmentsPriority: 3,\n\n    simultaneousHttpDownloads: 2,\n    httpDownloadProbability: 0.06,\n    httpDownloadProbabilityInterval: 1000,\n    httpDownloadProbabilitySkipIfNoPeers: false,\n    httpFailedSegmentTimeout: 1500,\n    httpDownloadMaxPriority: 20,\n    httpDownloadInitialTimeout: 0,\n    httpDownloadInitialTimeoutPerSegment: 100, ///segment = 4000\n    httpUseRanges: false,\n\n    simultaneousP2PDownloads: 20,\n    p2pDownloadMaxPriority: 50,\n    p2pSegmentDownloadTimeout: 60000,\n\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\n    peerRequestsPerAnnounce: 10,\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\n};\n\nexport class HybridLoader extends EventEmitter implements LoaderInterface {\n    private readonly debug = Debug(\"p2pml:hybrid-loader\");\n    private readonly debugSegments = Debug(\"p2pml:hybrid-loader-segments\");\n    private readonly httpManager: HttpMediaManager;\n    private readonly p2pManager: P2PMediaManager;\n    private segmentsStorage: SegmentsStorage;\n    private segmentsQueue: Segment[] = [];\n    private readonly bandwidthApproximator = new BandwidthApproximator();\n    private readonly settings: HybridLoaderSettings & { localTransport?: typeof fetch };\n    private httpRandomDownloadInterval: ReturnType<typeof setInterval> | undefined;\n    private httpDownloadInitialTimeoutTimestamp = -Infinity;\n    private masterSwarmId?: string;\n\n    public static isSupported = (): boolean => {\n        return window.RTCPeerConnection.prototype.createDataChannel !== undefined;\n    };\n\n    public constructor(settings: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }> = {}) {\n        super();\n\n        this.settings = { ...defaultSettings, ...settings };\n\n        const { bufferedSegmentsCount } = settings as Record<string, unknown>;\n\n        if (typeof bufferedSegmentsCount === \"number\") {\n            if (settings.p2pDownloadMaxPriority === undefined) {\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\n            }\n\n            if (settings.httpDownloadMaxPriority === undefined) {\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\n            }\n        }\n\n        this.segmentsStorage =\n            this.settings.segmentsStorage === undefined\n                ? new SegmentsMemoryStorage(this.settings)\n                : this.settings.segmentsStorage;\n\n        this.debug(\"loader settings\", this.settings);\n\n        this.httpManager = this.createHttpManager();\n        this.httpManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"http\", segment));\n        this.httpManager.on(\"segment-loaded\", this.onSegmentLoaded);\n        this.httpManager.on(\"segment-error\", this.onSegmentError);\n        this.httpManager.on(\"segment-size\", this.onSegmentSize);\n        this.httpManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number) => {\n            this.onPieceBytesDownloaded(\"http\", segment, bytes)\n        });\n\n        this.p2pManager = this.createP2PManager();\n        this.p2pManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"p2p\", segment));\n        this.p2pManager.on(\"segment-loaded\", this.onSegmentLoaded);\n        this.p2pManager.on(\"segment-error\", this.onSegmentError);\n        this.p2pManager.on(\"segment-size\", this.onSegmentSize);\n        this.p2pManager.on(\"peer-data-updated\", async () => {\n            if (this.masterSwarmId === undefined) {\n                return;\n            }\n\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n            }\n        });\n        this.p2pManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number, peerId: string) =>\n            this.onPieceBytesDownloaded(\"p2p\", segment, bytes, peerId)\n        );\n        this.p2pManager.on(\"bytes-uploaded\", (segment: Segment, bytes: number, peerId: string) =>\n            this.onPieceBytesUploaded(\"p2p\", segment, bytes, peerId)\n        );\n        this.p2pManager.on(\"peer-connected\", this.onPeerConnect);\n        this.p2pManager.on(\"peer-closed\", this.onPeerClose);\n        this.p2pManager.on(\"tracker-update\", this.onTrackerUpdate);\n    }\n\n    private createHttpManager = () => {\n        return new HttpMediaManager(this.settings);\n    };\n\n    private createP2PManager = () => {\n        return new P2PMediaManager(this.segmentsStorage, this.settings);\n    };\n\n    public load = async (segments: Segment[], streamSwarmId: string): Promise<void> => {\n        if (this.httpRandomDownloadInterval === undefined) {\n            // Do once on first call\n            this.httpRandomDownloadInterval = setInterval(\n                this.downloadRandomSegmentOverHttp,\n                this.settings.httpDownloadProbabilityInterval\n            );\n\n            if (\n                this.settings.httpDownloadInitialTimeout > 0 &&\n                this.settings.httpDownloadInitialTimeoutPerSegment > 0\n            ) {\n                // Initialize initial HTTP download timeout (i.e. download initial segments over P2P)\n                this.debugSegments(\n                    \"enable initial HTTP download timeout\",\n                    this.settings.httpDownloadInitialTimeout,\n                    \"per segment\",\n                    this.settings.httpDownloadInitialTimeoutPerSegment\n                );\n                this.httpDownloadInitialTimeoutTimestamp = this.now();\n                setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment + 100);\n            }\n        }\n\n        if (segments.length > 0) {\n            this.masterSwarmId = segments[0].masterSwarmId;\n        }\n\n        if (this.masterSwarmId !== undefined) {\n            this.p2pManager.setStreamSwarmId(streamSwarmId, this.masterSwarmId);\n        }\n\n        this.debug(\"load segments\");\n\n        let updateSegmentsMap = false;\n\n        // stop all http requests and p2p downloads for segments that are not in the new load\n        for (const segment of this.segmentsQueue) {\n            if (!segments.find((f) => f.url === segment.url)) {\n                this.debug(\"remove segment\", segment.url);\n                if (this.httpManager.isDownloading(segment)) {\n                    updateSegmentsMap = true;\n                    this.httpManager.abort(segment);\n                } else {\n                    this.p2pManager.abort(segment);\n                }\n                this.emit(Events.SegmentAbort, segment);\n            }\n        }\n\n        if (this.debug.enabled) {\n            for (const segment of segments) {\n                if (!this.segmentsQueue.find((f) => f.url === segment.url)) {\n                    this.debug(\"add segment\", segment.url);\n                }\n            }\n        }\n\n        this.segmentsQueue = segments;\n\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        let storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n        updateSegmentsMap = this.processSegmentsQueue(storageSegments) || updateSegmentsMap;\n\n        if (await this.cleanSegmentsStorage()) {\n            storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n            updateSegmentsMap = true;\n        }\n\n        if (updateSegmentsMap && !this.settings.consumeOnly) {\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n        }\n    };\n\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\n        return this.masterSwarmId === undefined ? undefined : this.segmentsStorage.getSegment(id, this.masterSwarmId);\n    };\n\n    public getSettings = (): HybridLoaderSettings => {\n        return this.settings;\n    };\n\n    public getDetails = (): { peerId: string } => {\n        return {\n            peerId: this.p2pManager.getPeerId(),\n        };\n    };\n\n    public getBandwidthEstimate = (): number => {\n        return this.bandwidthApproximator.getBandwidth(this.now());\n    };\n\n    public destroy = async (): Promise<void> => {\n        if (this.httpRandomDownloadInterval !== undefined) {\n            clearInterval(this.httpRandomDownloadInterval);\n            this.httpRandomDownloadInterval = undefined;\n        }\n\n        this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n\n        this.segmentsQueue = [];\n        this.httpManager.destroy();\n        this.p2pManager.destroy();\n        this.masterSwarmId = undefined;\n        await this.segmentsStorage.destroy();\n    };\n\n    private processInitialSegmentTimeout = async () => {\n        if (this.httpRandomDownloadInterval === undefined) {\n            return; // Instance destroyed\n        }\n\n        if (this.masterSwarmId !== undefined) {\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n            }\n        }\n\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\n            // Set one more timeout for a next segment\n            setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment);\n        }\n    };\n\n    private processSegmentsQueue = (storageSegments: Map<string, { segment: Segment }>) => {\n        this.debugSegments(\n            \"process segments queue. priority\",\n            this.segmentsQueue.length > 0 ? this.segmentsQueue[0].priority : 0\n        );\n\n        if (this.masterSwarmId === undefined || this.segmentsQueue.length === 0) {\n            return false;\n        }\n\n        let updateSegmentsMap = false;\n        let segmentsMap: Map<string, MediaPeerSegmentStatus> | undefined;\n\n        let httpAllowed = true;\n\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\n            let firstNotDownloadePriority: number | undefined;\n\n            for (const segment of this.segmentsQueue) {\n                if (!storageSegments.has(segment.id)) {\n                    firstNotDownloadePriority = segment.priority;\n                    break;\n                }\n            }\n\n            const httpTimeout = this.now() - this.httpDownloadInitialTimeoutTimestamp;\n            httpAllowed =\n                httpTimeout >= this.settings.httpDownloadInitialTimeout ||\n                (firstNotDownloadePriority !== undefined &&\n                    httpTimeout > this.settings.httpDownloadInitialTimeoutPerSegment &&\n                    firstNotDownloadePriority <= 0);\n\n            if (httpAllowed) {\n                this.debugSegments(\"cancel initial HTTP download timeout - timed out\");\n                this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n            }\n        }\n\n        for (let index = 0; index < this.segmentsQueue.length; index++) {\n            const segment = this.segmentsQueue[index];\n\n            if (storageSegments.has(segment.id)) {\n                continue;\n            }\n\n            // Segment priority changed, notify http manager\n            if (this.httpManager.isDownloading(segment)) {\n                this.httpManager.updatePriority(segment);\n                continue;\n            }\n\n            if (\n                segment.priority <= this.settings.requiredSegmentsPriority &&\n                httpAllowed &&\n                !this.httpManager.isFailed(segment)\n            ) {\n                // Download required segments over HTTP\n                if (this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads) {\n                    // Not enough HTTP download resources. Abort one of the HTTP downloads.\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\n                        const segmentToAbort = this.segmentsQueue[i];\n                        if (this.httpManager.isDownloading(segmentToAbort)) {\n                            this.debugSegments(\"cancel HTTP download\", segmentToAbort.priority, segmentToAbort.url);\n                            this.httpManager.abort(segmentToAbort);\n                            break;\n                        }\n                    }\n                }\n\n                if (this.httpManager.getActiveDownloadsCount() < this.settings.simultaneousHttpDownloads) {\n                    // Abort P2P download of the required segment if any and force HTTP download\n                    const downloadedPieces = this.p2pManager.abort(segment);\n                    void this.httpManager.download(segment, downloadedPieces);\n                    this.debugSegments(\"HTTP download (priority)\", segment.priority, segment.url);\n                    updateSegmentsMap = true;\n                    continue;\n                }\n            }\n\n            if (this.p2pManager.isDownloading(segment)) {\n                continue;\n            }\n\n            if (segment.priority <= this.settings.requiredSegmentsPriority) {\n                // Download required segments over P2P\n                segmentsMap = segmentsMap ? segmentsMap : this.p2pManager.getOverallSegmentsMap();\n\n                if (segmentsMap.get(segment.id) !== MediaPeerSegmentStatus.Loaded) {\n                    continue;\n                }\n\n                if (this.p2pManager.getActiveDownloadsCount() >= this.settings.simultaneousP2PDownloads) {\n                    // Not enough P2P download resources. Abort one of the P2P downloads.\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\n                        const segmentToAbort = this.segmentsQueue[i];\n                        if (this.p2pManager.isDownloading(segmentToAbort)) {\n                            this.debugSegments(\"cancel P2P download\", segmentToAbort.priority, segmentToAbort.url);\n                            this.p2pManager.abort(segmentToAbort);\n                            break;\n                        }\n                    }\n                }\n\n                if (this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads) {\n                    if (this.p2pManager.download(segment)) {\n                        this.debugSegments(\"P2P download (priority)\", segment.priority, segment.url);\n                        continue;\n                    }\n                }\n\n                continue;\n            }\n\n            if (\n                this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads &&\n                segment.priority <= this.settings.p2pDownloadMaxPriority\n            ) {\n                if (this.p2pManager.download(segment)) {\n                    this.debugSegments(\"P2P download\", segment.priority, segment.url);\n                }\n            }\n        }\n\n        return updateSegmentsMap;\n    };\n\n    private downloadRandomSegmentOverHttp = async () => {\n        if (\n            this.masterSwarmId === undefined ||\n            this.httpRandomDownloadInterval === undefined ||\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity ||\n            this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads ||\n            (this.settings.httpDownloadProbabilitySkipIfNoPeers && this.p2pManager.getPeers().size === 0) ||\n            this.settings.consumeOnly\n        ) {\n            return;\n        }\n\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n        const segmentsMap = this.p2pManager.getOverallSegmentsMap();\n\n        const pendingQueue = this.segmentsQueue.filter(\n            (s) =>\n                !this.p2pManager.isDownloading(s) &&\n                !this.httpManager.isDownloading(s) &&\n                !segmentsMap.has(s.id) &&\n                !this.httpManager.isFailed(s) &&\n                s.priority <= this.settings.httpDownloadMaxPriority &&\n                !storageSegments.has(s.id)\n        );\n\n        if (pendingQueue.length === 0) {\n            return;\n        }\n\n        if (Math.random() > this.settings.httpDownloadProbability * pendingQueue.length) {\n            return;\n        }\n\n        const segment = pendingQueue[Math.floor(Math.random() * pendingQueue.length)];\n        this.debugSegments(\"HTTP download (random)\", segment.priority, segment.url);\n        void this.httpManager.download(segment);\n        this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n    };\n\n    private onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\n        this.emit(Events.SegmentStartLoad, method, segment);\n    };\n\n    private onPieceBytesDownloaded = (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\n        this.bandwidthApproximator.addBytes(bytes, this.now());\n        this.emit(Events.PieceBytesDownloaded, method, segment, bytes, peerId);\n\n    };\n\n    private onPieceBytesUploaded = (method: \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\n        this.emit(Events.PieceBytesUploaded, method, segment, bytes, peerId);\n    };\n\n    private onSegmentLoaded = async (segment: Segment, data: ArrayBuffer, peerId?: string) => {\n        this.debugSegments(\"segment loaded\", segment.id, segment.url);\n\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        segment.data = data;\n        segment.downloadBandwidth = this.bandwidthApproximator.getBandwidth(this.now());\n\n        await this.segmentsStorage.storeSegment(segment);\n        this.emit(Events.SegmentLoaded, segment, peerId);\n\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n\n        this.processSegmentsQueue(storageSegments);\n        if (!this.settings.consumeOnly) {\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n        }\n    };\n\n    private onSegmentError = async (segment: Segment, details: unknown, peerId?: string) => {\n        this.debugSegments(\"segment error\", segment.id, segment.url, peerId, details);\n        this.emit(Events.SegmentError, segment, details, peerId);\n        if (this.masterSwarmId !== undefined) {\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n            }\n        }\n    };\n\n    private onSegmentSize = async (segment: Segment, size: number) => {\n        this.debugSegments(\"segment size\", segment.id, size);\n        this.emit(Events.SegmentSize, segment, size);\n    };\n\n    private getStreamSwarmId = (segment: Segment) => {\n        return segment.streamId === undefined ? segment.masterSwarmId : `${segment.masterSwarmId}+${segment.streamId}`;\n    };\n\n    private createSegmentsMap = (storageSegments: Map<string, { segment: Segment }>) => {\n        const segmentsMap: { [key: string]: [string, number[]] } = {};\n\n        const addSegmentToMap = (segment: Segment, status: MediaPeerSegmentStatus) => {\n            const streamSwarmId = this.getStreamSwarmId(segment);\n            const segmentId = segment.sequence;\n\n            let segmentsIdsAndStatuses = segmentsMap[streamSwarmId];\n            if (segmentsIdsAndStatuses === undefined) {\n                segmentsIdsAndStatuses = [\"\", []];\n                segmentsMap[streamSwarmId] = segmentsIdsAndStatuses;\n            }\n            const segmentsStatuses = segmentsIdsAndStatuses[1];\n            segmentsIdsAndStatuses[0] += segmentsStatuses.length === 0 ? segmentId : `|${segmentId}`;\n            segmentsStatuses.push(status);\n        };\n\n        for (const storageSegment of storageSegments.values()) {\n            addSegmentToMap(storageSegment.segment, MediaPeerSegmentStatus.Loaded);\n        }\n\n        for (const download of this.httpManager.getActiveDownloads().values()) {\n            addSegmentToMap(download.segment, MediaPeerSegmentStatus.LoadingByHttp);\n        }\n\n        return segmentsMap;\n    };\n\n    private onPeerConnect = async (peer: { id: string }) => {\n        this.emit(Events.PeerConnect, peer);\n        if (!this.settings.consumeOnly && this.masterSwarmId !== undefined) {\n            this.p2pManager.sendSegmentsMap(\n                peer.id,\n                this.createSegmentsMap(await this.segmentsStorage.getSegmentsMap(this.masterSwarmId))\n            );\n        }\n    };\n\n    private onPeerClose = (peerId: string) => {\n        this.emit(Events.PeerClose, peerId);\n    };\n\n    private onTrackerUpdate = async (data: { incomplete?: number }) => {\n        if (\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity &&\n            data.incomplete !== undefined &&\n            data.incomplete <= 1\n        ) {\n            this.debugSegments(\"cancel initial HTTP download timeout - no peers\");\n\n            this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n\n            if (this.masterSwarmId !== undefined) {\n                const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n\n                if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                    this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n                }\n            }\n        }\n    };\n\n    private cleanSegmentsStorage = async (): Promise<boolean> => {\n        if (this.masterSwarmId === undefined) {\n            return false;\n        }\n\n        return this.segmentsStorage.clean(\n            this.masterSwarmId,\n            (id: string) => this.segmentsQueue.find((queueSegment) => queueSegment.id === id) !== undefined\n        );\n    };\n\n    private now = () => {\n        return performance.now();\n    };\n}\n\nexport interface SegmentsStorage {\n    storeSegment: (segment: Segment) => Promise<void>;\n    getSegmentsMap: (masterSwarmId: string) => Promise<Map<string, { segment: Segment }>>;\n    getSegment: (id: string, masterSwarmId: string) => Promise<Segment | undefined>;\n    clean: (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean) => Promise<boolean>;\n    destroy: () => Promise<void>;\n}\n\nexport type SegmentValidatorCallback = (segment: Segment, method: \"http\" | \"p2p\", peerId?: string) => Promise<void>;\n/* export type XhrSetupCallback = (xhr: XMLHttpRequest, url: string) => void; */\nexport type SegmentUrlBuilder = (segment: Segment) => string;\n\nexport type HybridLoaderSettings = {\n    /**\n     * Segment lifetime in cache. The segment is deleted from the cache if the last access time is greater than this value (in milliseconds).\n     */\n    cachedSegmentExpiration: number;\n\n    /**\n     * Max number of segments that can be stored in the cache.\n     */\n    cachedSegmentsCount: number;\n\n    /**\n     * Enable/Disable peers interaction.\n     */\n    useP2P: boolean;\n\n    /**\n     * The peer will not upload segments data to the P2P network but still download from others.\n     */\n    consumeOnly: boolean;\n\n    /**\n     * The maximum priority of the segments to be downloaded (if not available) as quickly as possible (i.e. via HTTP method).\n     */\n    requiredSegmentsPriority: number;\n\n    /**\n     * Max number of simultaneous downloads from HTTP source.\n     */\n    simultaneousHttpDownloads: number;\n\n    /**\n     * Probability of downloading remaining not downloaded segment in the segments queue via HTTP.\n     */\n    httpDownloadProbability: number;\n\n    /**\n     * Interval of the httpDownloadProbability check (in milliseconds).\n     */\n    httpDownloadProbabilityInterval: number;\n\n    /**\n     * Don't download segments over HTTP randomly when there is no peers.\n     */\n    httpDownloadProbabilitySkipIfNoPeers: boolean;\n\n    /**\n     * Timeout before trying to load segment again via HTTP after failed attempt (in milliseconds).\n     */\n    httpFailedSegmentTimeout: number;\n\n    /**\n     * Segments with higher priority will not be downloaded over HTTP.\n     */\n    httpDownloadMaxPriority: number;\n\n    /**\n     * Try to download initial segments over P2P if the value is > 0.\n     * But HTTP download will be forcibly enabled if there is no peers on tracker or\n     * single sequential segment P2P download is timed out (see httpDownloadInitialTimeoutPerSegment).\n     */\n    httpDownloadInitialTimeout: number;\n\n    /**\n     * Use HTTP ranges requests where it is possible.\n     * Allows to continue (and not start over) aborted P2P downloads over HTTP.\n     */\n    httpUseRanges: boolean;\n\n    /**\n     * If initial HTTP download timeout is enabled (see httpDownloadInitialTimeout)\n     * this parameter sets additional timeout for a single sequential segment download\n     * over P2P. It will cancel initial HTTP download timeout mode if a segment download is timed out.\n     */\n    httpDownloadInitialTimeoutPerSegment: number;\n\n    /**\n     * Max number of simultaneous downloads from peers.\n     */\n    simultaneousP2PDownloads: number;\n\n    /**\n     * Segments with higher priority will not be downloaded over P2P.\n     */\n    p2pDownloadMaxPriority: number;\n\n    /**\n     * Timeout to download a segment from a peer. If exceeded the peer is dropped.\n     */\n    p2pSegmentDownloadTimeout: number;\n\n    /**\n     * Max WebRTC message size. 64KiB - 1B should work with most of recent browsers. Set it to 16KiB for older browsers support.\n     */\n    webRtcMaxMessageSize: number;\n\n    /**\n     * Torrent trackers (announcers) to use.\n     */\n    trackerAnnounce: string[];\n\n    /**\n     * Number of requested peers in each announce for each tracker. Maximum is 10.\n     */\n    peerRequestsPerAnnounce: number;\n\n    /**\n     * An RTCConfiguration dictionary providing options to configure WebRTC connections.\n     */\n    rtcConfig: RTCConfiguration;\n\n    /**\n     * Segment validation callback - validates the data after it has been downloaded.\n     */\n    segmentValidator?: SegmentValidatorCallback;\n\n    /**\n     * XMLHttpRequest setup callback. Handle it when you need additional setup for requests made by the library.\n     */\n    /* xhrSetup?: unknown; */\n\n    /**\n     * Allow to modify the segment URL before HTTP request.\n     */\n    segmentUrlBuilder?: SegmentUrlBuilder;\n\n    /**\n     * A storage for the downloaded segments.\n     * By default the segments are stored in JavaScript memory.\n     */\n    segmentsStorage?: SegmentsStorage;\n};\n","import { LoaderContext } from \"hls.js\"\n\nexport type ByteRange = { length: number; offset: number } | undefined;\n\nexport function getByteRange(context: LoaderContext): { offset: number, length: number } | undefined {\n  return context.rangeEnd && context.rangeStart !== undefined\n      ? { offset: context.rangeStart, length: context.rangeEnd - context.rangeStart }\n      : undefined;\n}\n\nexport function compareByteRanges(b1: ByteRange, b2: ByteRange): boolean {\n  return b1 === undefined ? b2 === undefined : b2 !== undefined && b1.length === b2.length && b1.offset === b2.offset;\n}\n\nexport function byteRangeToString(byteRange: ByteRange): string | undefined {\n  if (byteRange === undefined) {\n      return undefined;\n  }\n\n  const end = byteRange.offset + byteRange.length - 1;\n\n  return `bytes=${byteRange.offset}-${end}`;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Events, Segment, LoaderInterface } from \"../../p2p-media-loader-core/lib\";\nimport { Manifest, Parser } from \"m3u8-parser\";\nimport { ByteRange, byteRangeToString, compareByteRanges } from \"./byte-range\"\nimport { AssetsStorage, HlsJsEngineSettings } from \"./engine\";\n\nconst defaultSettings: SegmentManagerSettings = {\n    forwardSegmentCount: 20,\n    swarmId: undefined,\n    assetsStorage: undefined,\n};\n\nexport class SegmentManager {\n    public readonly loader: LoaderInterface;\n    private masterPlaylist: Playlist | null = null;\n    private readonly variantPlaylists = new Map<string, Playlist>();\n    private segmentRequest: SegmentRequest | null = null;\n    private readonly fetch: typeof fetch = (...args) => fetch(...args);\n    private playQueue: {\n        segmentSequence: number;\n        segmentUrl: string;\n        segmentByteRange: ByteRange;\n        playPosition?: {\n            start: number;\n            duration: number;\n        };\n    }[] = [];\n    private readonly settings: SegmentManagerSettings;\n\n    public constructor(loader: LoaderInterface, settings: Partial<HlsJsEngineSettings> = {}) {\n        this.settings = { ...defaultSettings, ...settings.segments };\n\n        this.loader = loader;\n        this.loader.on(Events.SegmentLoaded, this.onSegmentLoaded);\n        this.loader.on(Events.SegmentError, this.onSegmentError);\n        this.loader.on(Events.SegmentAbort, this.onSegmentAbort);\n\n        if (settings.loader && settings.loader.localTransport) {\n            this.fetch = settings.loader.localTransport;\n        }\n    }\n\n    public getSettings(): SegmentManagerSettings {\n        return this.settings;\n    }\n\n    public processPlaylist(requestUrl: string, content: string, responseUrl: string): void {\n        const parser = new Parser();\n        parser.push(content);\n        parser.end();\n\n        const playlist = new Playlist(requestUrl, responseUrl, parser.manifest);\n\n        if (playlist.manifest.playlists) {\n            this.masterPlaylist = playlist;\n\n            for (const [key, variantPlaylist] of this.variantPlaylists) {\n                const { streamSwarmId, found, index } = this.getStreamSwarmId(variantPlaylist.requestUrl);\n                if (!found) {\n                    this.variantPlaylists.delete(key);\n                } else {\n                    variantPlaylist.streamSwarmId = streamSwarmId;\n                    variantPlaylist.streamId = \"V\" + index.toString();\n                }\n            }\n        } else {\n            const { streamSwarmId, found, index } = this.getStreamSwarmId(requestUrl);\n\n            if (found || this.masterPlaylist === null) {\n                // do not add audio and subtitles to variants\n                playlist.streamSwarmId = streamSwarmId;\n                playlist.streamId = this.masterPlaylist === null ? undefined : \"V\" + index.toString();\n                this.variantPlaylists.set(requestUrl, playlist);\n                this.updateSegments();\n            }\n        }\n    }\n\n    public async loadPlaylist(url: string): Promise<{ response: string; responseURL: string }> {\n        const assetsStorage = this.settings.assetsStorage;\n        let res: { response: string; responseURL: string } | undefined;\n\n        if (assetsStorage !== undefined) {\n            let masterSwarmId: string | undefined;\n            masterSwarmId = this.getMasterSwarmId();\n            if (masterSwarmId === undefined) {\n                masterSwarmId = url.split(\"?\")[0];\n            }\n            const asset = await assetsStorage.getAsset(url, undefined, masterSwarmId);\n\n            if (asset !== undefined) {\n                res = {\n                    responseURL: asset.responseUri,\n                    response: asset.data as string,\n                };\n            } else {\n                const fetch = await this.loadContent(url);\n\n                res = {\n                    responseURL: fetch.url,\n                    response: await fetch.text(),\n                };\n\n                void assetsStorage.storeAsset({\n                    masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : url,\n                    masterSwarmId: masterSwarmId,\n                    requestUri: url,\n                    responseUri: res.responseURL,\n                    data: await res.response,\n                });\n            }\n        } else {\n            const fetch = await this.loadContent(url);\n\n            res = {\n                responseURL: fetch.url,\n                response: await fetch.text(),\n            };\n        }\n\n        this.processPlaylist(url, res.response, res.responseURL);\n        return res;\n    }\n\n    \n\n    public async loadSegment(\n        url: string,\n        byteRange: ByteRange\n    ): Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }> {\n        const segmentLocation = this.getSegmentLocation(url, byteRange);\n        const byteRangeString = byteRangeToString(byteRange);\n\n        if (!segmentLocation) {\n            let content: ArrayBuffer | undefined;\n\n            // Not a segment from variants; usually can be: init, audio or subtitles segment, encryption key etc.\n            const assetsStorage = this.settings.assetsStorage;\n            if (assetsStorage !== undefined) {\n                let masterManifestUri = this.masterPlaylist?.requestUrl;\n\n                let masterSwarmId: string | undefined;\n                masterSwarmId = this.getMasterSwarmId();\n\n                if (masterSwarmId === undefined && this.variantPlaylists.size === 1) {\n                    const result = this.variantPlaylists.values().next();\n                    if (!result.done) {\n                        // always true\n                        masterSwarmId = result.value.requestUrl.split(\"?\")[0];\n                    }\n                }\n\n                if (masterManifestUri === undefined && this.variantPlaylists.size === 1) {\n                    const result = this.variantPlaylists.values().next();\n                    if (!result.done) {\n                        // always true\n                        masterManifestUri = result.value.requestUrl;\n                    }\n                }\n\n                if (masterSwarmId !== undefined && masterManifestUri !== undefined) {\n                    const asset = await assetsStorage.getAsset(url, byteRangeString, masterSwarmId);\n                    if (asset !== undefined) {\n                        content = asset.data as ArrayBuffer;\n                    } else {\n                        const fetch = await this.loadContent(url, byteRangeString);\n                        content = await fetch.arrayBuffer();\n                        void assetsStorage.storeAsset({\n                            masterManifestUri: masterManifestUri,\n                            masterSwarmId: masterSwarmId,\n                            requestUri: url,\n                            requestRange: byteRangeString,\n                            responseUri: fetch.url,\n                            data: content,\n                        });\n                    }\n                }\n            }\n\n            if (content === undefined) {\n                const fetch = await this.loadContent(url, byteRangeString);\n                content = await fetch.arrayBuffer();\n            }\n\n            return { content, downloadBandwidth: 0 };\n        }\n\n        const segmentSequence =\n            (segmentLocation.playlist.manifest.mediaSequence ? segmentLocation.playlist.manifest.mediaSequence : 0) +\n            segmentLocation.segmentIndex;\n\n        if (this.playQueue.length > 0) {\n            const previousSegment = this.playQueue[this.playQueue.length - 1];\n            if (previousSegment.segmentSequence !== segmentSequence - 1) {\n                // Reset play queue in case of segment loading out of sequence\n                this.playQueue = [];\n            }\n        }\n\n        if (this.segmentRequest) {\n            this.segmentRequest.onError(\"Cancel segment request: simultaneous segment requests are not supported\");\n        }\n\n        const promise = new Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }>(\n            (resolve, reject) => {\n\n                this.segmentRequest = new SegmentRequest(\n                    url,\n                    byteRange,\n                    segmentSequence,\n                    segmentLocation.playlist.requestUrl,\n                    (content: ArrayBuffer | undefined, downloadBandwidth?: number) =>\n                        resolve({ content, downloadBandwidth }),\n                    (error) => reject(error)\n                );\n                \n            }\n        );\n\n        this.playQueue.push({ segmentUrl: url, segmentByteRange: byteRange, segmentSequence: segmentSequence });\n        void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, true);\n\n        return promise;\n    }\n\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\n        const urlIndex = this.playQueue.findIndex(\n            (segment) => segment.segmentUrl === url && compareByteRanges(segment.segmentByteRange, byteRange)\n        );\n\n        if (urlIndex >= 0) {\n            this.playQueue = this.playQueue.slice(urlIndex);\n            this.playQueue[0].playPosition = { start, duration };\n            this.updateSegments();\n        }\n    }\n\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\n        if (this.playQueue.length === 0 || !this.playQueue[0].playPosition) {\n            return;\n        }\n\n        const currentSegmentPosition = this.playQueue[0].playPosition;\n        const segmentEndTime = currentSegmentPosition.start + currentSegmentPosition.duration;\n\n        if (segmentEndTime - playheadPosition < 0.2) {\n            // means that current segment is (almost) finished playing\n            // remove it from queue\n\n            this.playQueue = this.playQueue.slice(1);\n            this.updateSegments();\n        }\n    }\n\n    public abortSegment(url: string, byteRange: ByteRange): void {\n        if (\n            this.segmentRequest &&\n            this.segmentRequest.segmentUrl === url &&\n            compareByteRanges(this.segmentRequest.segmentByteRange, byteRange)\n        ) {\n            this.segmentRequest.onSuccess(undefined, 0);\n            this.segmentRequest = null;\n        }\n    }\n\n    public async destroy(): Promise<void> {\n        if (this.segmentRequest) {\n            this.segmentRequest.onError(\"Loading aborted: object destroyed\");\n            this.segmentRequest = null;\n        }\n\n        this.masterPlaylist = null;\n        this.variantPlaylists.clear();\n        this.playQueue = [];\n\n        if (this.settings.assetsStorage !== undefined) {\n            await this.settings.assetsStorage.destroy();\n        }\n\n        await this.loader.destroy();\n    }\n\n    private updateSegments(): void {\n        if (!this.segmentRequest) {\n            return;\n        }\n\n        const segmentLocation = this.getSegmentLocation(\n            this.segmentRequest.segmentUrl,\n            this.segmentRequest.segmentByteRange\n        );\n        if (segmentLocation) {\n            void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, false);\n        }\n    }\n\n    private onSegmentLoaded = (segment: Segment) => {\n        if (\n            this.segmentRequest &&\n            this.segmentRequest.segmentUrl === segment.url &&\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\n        ) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.segmentRequest.onSuccess(segment.data!.slice(0), segment.downloadBandwidth);\n            this.segmentRequest = null;\n        }\n    };\n\n    private onSegmentError = (segment: Segment, error: unknown) => {\n        if (\n            this.segmentRequest &&\n            this.segmentRequest.segmentUrl === segment.url &&\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\n        ) {\n            this.segmentRequest.onError(error);\n            this.segmentRequest = null;\n        }\n    };\n\n    private onSegmentAbort = (segment: Segment) => {\n        if (\n            this.segmentRequest &&\n            this.segmentRequest.segmentUrl === segment.url &&\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\n        ) {\n            this.segmentRequest.onError(\"Loading aborted: internal abort\");\n            this.segmentRequest = null;\n        }\n    };\n\n    private getSegmentLocation(\n        url: string,\n        byteRange: ByteRange\n    ): { playlist: Playlist; segmentIndex: number } | undefined {\n        for (const playlist of this.variantPlaylists.values()) {\n            const segmentIndex = playlist.getSegmentIndex(url, byteRange);\n            if (segmentIndex >= 0) {\n                return { playlist: playlist, segmentIndex: segmentIndex };\n            }\n        }\n\n        return undefined;\n    }\n\n    private async loadSegments(playlist: Playlist, segmentIndex: number, requestFirstSegment: boolean) {\n        const segments: Segment[] = [];\n        const playlistSegments = playlist.manifest.segments;\n        const initialSequence = playlist.manifest.mediaSequence ?? 0;\n        let loadSegmentId: string | null = null;\n\n        let priority = Math.max(0, this.playQueue.length - 1);\n\n        const masterSwarmId = this.getMasterSwarmId();\n\n        for (\n            let i = segmentIndex;\n            i < playlistSegments.length && segments.length < this.settings.forwardSegmentCount;\n            ++i\n        ) {\n            const segment = playlist.manifest.segments[i];\n\n            const url = playlist.getSegmentAbsoluteUrl(segment.uri);\n            const byteRange: ByteRange = segment.byterange;\n            const id = this.getSegmentId(playlist, initialSequence + i);\n\n            segments.push({\n                id: id,\n                url: url,\n                masterSwarmId: masterSwarmId !== undefined ? masterSwarmId : playlist.streamSwarmId,\n                masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : playlist.requestUrl,\n                streamId: playlist.streamId,\n                sequence: (initialSequence + i).toString(),\n                range: byteRangeToString(byteRange),\n                priority: priority++,\n            });\n            if (requestFirstSegment && !loadSegmentId) {\n                loadSegmentId = id;\n            }\n        }\n\n        this.loader.load(segments, playlist.streamSwarmId);\n\n        if (loadSegmentId) {\n            const segment = await this.loader.getSegment(loadSegmentId);\n\n\n\n            if (segment) {\n                // Segment already loaded by loader\n                this.onSegmentLoaded(segment);\n            }\n        }\n    }\n\n    private getSegmentId(playlist: Playlist, segmentSequence: number): string {\n        return `${playlist.streamSwarmId}+${segmentSequence}`;\n    }\n\n    private getMasterSwarmId() {\n        const settingsSwarmId =\n            this.settings.swarmId && this.settings.swarmId.length !== 0 ? this.settings.swarmId : undefined;\n        if (settingsSwarmId !== undefined) {\n            return settingsSwarmId;\n        }\n\n        return this.masterPlaylist !== null ? this.masterPlaylist.requestUrl.split(\"?\")[0] : undefined;\n    }\n\n    private getStreamSwarmId(playlistUrl: string): { streamSwarmId: string; found: boolean; index: number } {\n        const masterSwarmId = this.getMasterSwarmId();\n\n        if (this.masterPlaylist && this.masterPlaylist.manifest.playlists && masterSwarmId) {\n            for (let i = 0; i < this.masterPlaylist.manifest.playlists.length; ++i) {\n                const url = new URL(\n                    this.masterPlaylist.manifest.playlists[i].uri,\n                    this.masterPlaylist.responseUrl\n                ).toString();\n                if (url === playlistUrl) {\n                    return { streamSwarmId: `${masterSwarmId}+V${i}`, found: true, index: i };\n                }\n            }\n        }\n\n        return {\n            streamSwarmId: masterSwarmId ?? playlistUrl.split(\"?\")[0],\n            found: false,\n            index: -1,\n        };\n    }\n\n    private async loadContent(\n        url: string,\n        range?: string\n    ): Promise<Response> {\n        const headers = new Headers();\n\n        if (range) {\n            headers.append('Range', range);\n        }\n\n        return this.fetch(url, { headers });\n    }\n}\n\nclass Playlist {\n    public streamSwarmId = \"\";\n    public streamId?: string;\n\n    public constructor(readonly requestUrl: string, readonly responseUrl: string, readonly manifest: Manifest) {}\n\n    public getSegmentIndex(url: string, byteRange: ByteRange): number {\n        for (let i = 0; i < this.manifest.segments.length; ++i) {\n            const segment = this.manifest.segments[i];\n            const segmentUrl = this.getSegmentAbsoluteUrl(segment.uri);\n\n            if (url === segmentUrl && compareByteRanges(segment.byterange, byteRange)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    public getSegmentAbsoluteUrl(segmentUrl: string): string {\n        return new URL(segmentUrl, this.responseUrl).toString();\n    }\n}\n\nclass SegmentRequest {\n    public constructor(\n        readonly segmentUrl: string,\n        readonly segmentByteRange: ByteRange,\n        readonly segmentSequence: number,\n        readonly playlistRequestUrl: string,\n        readonly onSuccess: (content: ArrayBuffer | undefined, downloadBandwidth: number | undefined) => void,\n        readonly onError: (error: unknown) => void\n    ) {}\n}\n\nexport interface SegmentManagerSettings {\n    /**\n     * Number of segments for building up predicted forward segments sequence; used to predownload and share via P2P\n     */\n    forwardSegmentCount: number;\n\n    /**\n     * Override default swarm ID that is used to identify unique media stream with trackers (manifest URL without\n     * query parameters is used as the swarm ID if the parameter is not specified)\n     */\n    swarmId?: string;\n\n    /**\n     * A storage for the downloaded assets: manifests, subtitles, init segments, DRM assets etc. By default the assets are not stored.\n     */\n    assetsStorage?: AssetsStorage;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SegmentManager } from \"./segment-manager\";\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\nimport { Events, Segment } from \"../../p2p-media-loader-core/lib\";\nimport { byteRangeToString, getByteRange } from \"./byte-range\"\n\nexport class HlsJsLoader {\n    private isLoaded = false;\n    private segmentManager: SegmentManager;\n    public stats: LoaderStats = {\n        loaded: 0,\n        total: 0,\n        aborted: false,\n        retry: 0,\n        chunkCount: 0,\n        bwEstimate: 0,\n        loading: {\n            start: 0,\n            end: 0,\n            first: 0,\n        },\n        parsing: {\n            start: 0,\n            end: 0,\n        },\n        buffering: {\n            start: 0,\n            end: 0,\n            first: 0,\n        },\n    };\n\n    public constructor(segmentManager: SegmentManager) {\n        this.segmentManager = segmentManager;\n    }\n\n    public async load(\n        context: LoaderContext,\n        _config: LoaderConfiguration,\n        callbacks: LoaderCallbacks<LoaderContext>\n    ): Promise<void> {\n        HlsJsLoader.updateStatsToStartLoading(this.stats)\n\n        if (((context as unknown) as { type: unknown }).type) {\n            try {\n                const result = await this.segmentManager.loadPlaylist(context.url);\n                this.isLoaded = true;\n                this.successPlaylist(result, context, callbacks);\n            } catch (e : any) {\n                this.error(e, context, callbacks);\n            }\n        } else if (((context as unknown) as { frag: unknown }).frag) {\n            const { loader } = this.segmentManager;\n            const byteRange = getByteRange(context)\n\n            const isSegment = (segment: Segment) => {\n                return segment.url === context.url && segment.range === byteRangeToString(byteRange)\n            }\n\n            // We may be downloading the segment by P2P, so we don't care about the stats sent to HLS ABR\n            let updateStart: NodeJS.Timeout | undefined = setInterval(() => {\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\n            }, 200)\n\n            const onUpdateSegmentSize = (segment: Segment, size: number) => {\n                if (!isSegment(segment)) return\n\n                this.stats.total = size\n            };\n            loader.on(Events.SegmentSize, onUpdateSegmentSize)\n\n            const onUpdateLoaded = (_type: unknown, segment: Segment, bytes: number) => {\n                if (!isSegment(segment)) return\n\n                this.stats.loaded += bytes\n            };\n\n            const onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\n                if (!updateStart || method !== \"http\" || !isSegment(segment)) return\n\n                clearInterval(updateStart)\n                updateStart = undefined\n\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\n\n                loader.on(Events.PieceBytesDownloaded, onUpdateLoaded)\n            };\n\n            loader.on(Events.SegmentStartLoad, onSegmentStartLoad)\n\n\n            try {\n                const result = await this.segmentManager.loadSegment(context.url, byteRange);\n                const { content } = result;\n                if (content) {\n                    this.isLoaded = true;\n                    setTimeout(() => this.successSegment(content, context, callbacks), 0);\n                }\n\n            } catch (e : any) {\n                setTimeout(() => this.error(e, context, callbacks), 0);\n            } finally {\n\n                clearInterval(updateStart)\n                loader.off(Events.SegmentStartLoad, onSegmentStartLoad)\n                loader.off(Events.SegmentSize, onUpdateSegmentSize)\n                loader.off(Events.PieceBytesDownloaded, onUpdateLoaded)\n            }\n\n\n\n\n        } else {\n            console.warn(\"Unknown load request\", context);\n        }\n    }\n\n    public abort(context: LoaderContext, callbacks?: LoaderCallbacks<LoaderContext>): void {\n        if (this.isLoaded) return;\n\n        this.segmentManager.abortSegment(context.url, getByteRange(context));\n        this.stats.aborted = true;\n\n        const onAbort = callbacks?.onAbort;\n        if (onAbort) {\n            onAbort(this.stats, context, undefined);\n        }\n    }\n\n    private successPlaylist(\n        xhr: { response: string; responseURL: string },\n        context: LoaderContext,\n        callbacks: LoaderCallbacks<LoaderContext>\n    ): void {\n        const now = performance.now();\n\n        this.stats.loading.end = now;\n        this.stats.loaded = xhr.response.length;\n        this.stats.total = xhr.response.length;\n\n        callbacks.onSuccess(\n            {\n                url: xhr.responseURL,\n                data: xhr.response,\n            },\n            this.stats,\n            context,\n            undefined\n        );\n    }\n\n    private successSegment(\n        content: ArrayBuffer,\n        context: LoaderContext,\n        callbacks: LoaderCallbacks<LoaderContext>\n    ): void {\n        const now = performance.now();\n\n        this.stats.loading.end = now;\n        this.stats.loaded = content.byteLength;\n        this.stats.total = content.byteLength;\n\n        if (callbacks.onProgress) {\n            callbacks.onProgress(this.stats, context, content, undefined);\n        }\n\n        callbacks.onSuccess(\n            {\n                url: context.url,\n                data: content,\n            },\n            this.stats,\n            context,\n            undefined\n        );\n    }\n\n    private error(\n        error: { code: number; text: string },\n        context: LoaderContext,\n        callbacks: LoaderCallbacks<LoaderContext>\n    ): void {\n        callbacks.onError(error, context, undefined);\n    }\n\n    private static updateStatsToStartLoading (stats: LoaderStats) {\n        const start = performance.now();\n        stats.loading.start = start;\n        stats.loading.first = start;\n    }\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EventEmitter } from \"events\";\nimport { Events, LoaderInterface, HybridLoader, HybridLoaderSettings } from \"../../p2p-media-loader-core/lib\";\nimport { SegmentManager, SegmentManagerSettings } from \"./segment-manager\";\nimport { HlsJsLoader } from \"./hlsjs-loader\";\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\nimport { ByteRange } from \"./byte-range\"\n\nexport interface HlsJsEngineSettings {\n    loader: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }>;\n    segments: Partial<SegmentManagerSettings>;\n}\n\nexport class Engine extends EventEmitter {\n    public static isSupported(): boolean {\n        return HybridLoader.isSupported();\n    }\n\n    private readonly loader: LoaderInterface;\n    private readonly segmentManager: SegmentManager;\n\n    public constructor(settings: Partial<HlsJsEngineSettings> = {}) {\n        super();\n\n        this.loader = new HybridLoader(settings.loader);\n        this.segmentManager = new SegmentManager(this.loader, settings);\n\n        Object.keys(Events)\n            .map((eventKey) => Events[eventKey as keyof typeof Events])\n            .forEach((event) => this.loader.on(event, (...args: unknown[]) => this.emit(event, ...args)));\n    }\n\n    public createLoaderClass(): new () => unknown {\n        const engine = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        return class {\n            private impl: HlsJsLoader;\n            private context?: LoaderContext;\n            private callbacks?: LoaderCallbacks<LoaderContext>;\n            public stats: LoaderStats;\n\n            constructor() {\n                this.impl = new HlsJsLoader(engine.segmentManager);\n                this.stats = this.impl.stats;\n            }\n\n            load = async (\n                context: LoaderContext,\n                config: LoaderConfiguration,\n                callbacks: LoaderCallbacks<LoaderContext>\n            ) => {\n                this.context = context;\n                this.callbacks = callbacks;\n                this.impl.load(context, config, callbacks);\n\n            };\n\n            abort = () => {\n                if (this.context) {\n                    this.impl.abort(this.context, this.callbacks);\n                }\n            };\n\n            destroy = () => {\n                if (this.context) {\n                    this.impl.abort(this.context);\n                }\n            };\n\n            getResponseHeader = () => undefined;\n\n            static getEngine = () => {\n                return engine;\n            };\n        };\n    }\n\n    public async destroy(): Promise<void> {\n        await this.segmentManager.destroy();\n    }\n\n    public getSettings(): {\n        segments: SegmentManagerSettings;\n        loader: unknown;\n    } {\n        return {\n            segments: this.segmentManager.getSettings(),\n            loader: this.loader.getSettings(),\n        };\n    }\n\n    public getDetails(): unknown {\n        return {\n            loader: this.loader.getDetails(),\n        };\n    }\n\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\n        this.segmentManager.setPlayingSegment(url, byteRange, start, duration);\n    }\n\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\n        this.segmentManager.setPlayingSegmentByCurrentTime(playheadPosition);\n    }\n\n}\n\nexport interface Asset {\n    masterSwarmId: string;\n    masterManifestUri: string;\n    requestUri: string;\n    requestRange?: string;\n    responseUri: string;\n    data: ArrayBuffer | string;\n}\n\nexport interface AssetsStorage {\n    storeAsset(asset: Asset): Promise<void>;\n    getAsset(requestUri: string, requestRange: string | undefined, masterSwarmId: string): Promise<Asset | undefined>;\n    destroy(): Promise<void>;\n}\n","/**\n * @license Apache-2.0\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable */\n\nexport const version = \"0.6.2\";\nexport * from \"./engine\";\nexport * from \"./segment-manager\";\n\nimport { Engine } from \"./engine\";\n\ndeclare const videojs: any;\n\ndeclare global {\n    interface Window {\n        p2pml: Record<string, unknown>;\n    }\n}\n\nexport function initHlsJsPlayer(player: any): void {\n    if (player && player.config && player.config.loader && typeof player.config.loader.getEngine === \"function\") {\n        initHlsJsEvents(player, player.config.loader.getEngine());\n    }\n}\n\nexport function initClapprPlayer(player: any): void {\n    player.on(\"play\", () => {\n        const playback = player.core.getCurrentPlayback();\n        if (playback._hls && !playback._hls._p2pm_linitialized) {\n            playback._hls._p2pm_linitialized = true;\n            initHlsJsPlayer(player.core.getCurrentPlayback()._hls);\n        }\n    });\n}\n\nexport function initFlowplayerHlsJsPlayer(player: any): void {\n    player.on(\"ready\", () => initHlsJsPlayer(player.engine.hlsjs ?? player.engine.hls));\n}\n\nexport function initVideoJsContribHlsJsPlayer(player: any): void {\n    player.ready(() => {\n        const options = player.tech_.options_;\n        if (\n            options &&\n            options.hlsjsConfig &&\n            options.hlsjsConfig.loader &&\n            typeof options.hlsjsConfig.loader.getEngine === \"function\"\n        ) {\n            initHlsJsEvents(player.tech_, options.hlsjsConfig.loader.getEngine());\n        }\n    });\n}\n\nexport function initVideoJsHlsJsPlugin(): void {\n    if (videojs == undefined || videojs.Html5Hlsjs == undefined) {\n        return;\n    }\n\n    videojs.Html5Hlsjs.addHook(\"beforeinitialize\", (videojsPlayer: any, hlsjs: any) => {\n        if (hlsjs.config && hlsjs.config.loader && typeof hlsjs.config.loader.getEngine === \"function\") {\n            initHlsJsEvents(hlsjs, hlsjs.config.loader.getEngine());\n        }\n    });\n}\n\nexport function initMediaElementJsPlayer(mediaElement: any): void {\n\n\n    mediaElement.addEventListener(\"hlsFragChanged\", (event: any) => {\n        const hls = mediaElement.hlsPlayer;\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\n            const engine: Engine = hls.config.loader.getEngine();\n\n            if (event.data && event.data.length > 1) {\n                const frag = event.data[1].frag;\n                const byteRange =\n                    frag.byteRange.length !== 2\n                        ? undefined\n                        : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\n                engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\n            }\n        }\n    });\n    mediaElement.addEventListener(\"hlsDestroying\", async () => {\n        const hls = mediaElement.hlsPlayer;\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\n            const engine: Engine = hls.config.loader.getEngine();\n            await engine.destroy();\n        }\n    });\n    mediaElement.addEventListener(\"hlsError\", (event: any) => {\n        const hls = mediaElement.hlsPlayer;\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\n            if (event.data !== undefined && event.data.details === \"bufferStalledError\") {\n                const engine: Engine = hls.config.loader.getEngine();\n                engine.setPlayingSegmentByCurrentTime(hls.media.currentTime);\n            }\n        }\n    });\n}\n\nexport function initJwPlayer(player: any, hlsjsConfig: any): void {\n    const iid = setInterval(() => {\n        if (player.hls && player.hls.config) {\n            clearInterval(iid);\n            Object.assign(player.hls.config, hlsjsConfig);\n            initHlsJsPlayer(player.hls);\n        }\n    }, 200);\n}\n\nfunction initHlsJsEvents(player: any, engine: Engine): void {\n    player.on(\"hlsFragChanged\", (_event: string, data: any) => {\n        const frag = data.frag;\n        const byteRange =\n            frag.byteRange.length !== 2\n                ? undefined\n                : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\n        engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\n    });\n    player.on(\"hlsDestroying\", async () => {\n        await engine.destroy();\n    });\n    player.on(\"hlsError\", (_event: string, errorData: { details: string }) => {\n        if (errorData.details === \"bufferStalledError\") {\n            const htmlMediaElement = (player.media === undefined\n                ? player.el_ // videojs-contrib-hlsjs\n                : player.media) as HTMLMediaElement | undefined; // all others\n            if (htmlMediaElement) {\n                engine.setPlayingSegmentByCurrentTime(htmlMediaElement.currentTime);\n            }\n        }\n    });\n}\n"],"sourceRoot":""}