{"version":3,"sources":["webpack:///../../src/rust-crypto/rust-crypto.ts","webpack:///../../src/rust-crypto/backup.ts","webpack:///../../src/rust-crypto/KeyClaimManager.ts","webpack:///../../src/rust-crypto/RoomEncryptor.ts","webpack:///../../src/rust-crypto/PerSessionKeyBackupDownloader.ts","webpack:///../../src/rust-crypto/device-converter.ts","webpack:///../../src/rust-crypto/libolm_migration.ts","webpack:///../../src/rust-crypto/index.ts","webpack:///../../src/rust-crypto/OutgoingRequestProcessor.ts","webpack:///../../src/rust-crypto/verification.ts","webpack:///../../src/rust-crypto/OutgoingRequestsManager.ts","webpack:///../../src/rust-crypto/CrossSigningIdentity.ts","webpack:///../../src/rust-crypto/secret-storage.ts","webpack:///../../src/rust-crypto/DehydratedDeviceManager.ts"],"names":["ALL_VERIFICATION_METHODS","VerificationMethod","Sas","ScanQrCode","ShowQrCode","Reciprocate","RustCrypto","TypedEventEmitter","constructor","logger","olmMachine","http","userId","_deviceId","secretStorage","cryptoCallbacks","super","_defineProperty","TypedReEmitter","this","outgoingRequestProcessor","OutgoingRequestProcessor","outgoingRequestsManager","OutgoingRequestsManager","keyClaimManager","KeyClaimManager","backupManager","RustBackupManager","perSessionBackupDownloader","PerSessionKeyBackupDownloader","dehydratedDeviceManager","DehydratedDeviceManager","eventDecryptor","EventDecryptor","reemitter","reEmit","CryptoEvent","KeyBackupStatus","KeyBackupSessionsRemaining","KeyBackupFailed","KeyBackupDecryptionKeyCached","crossSigningIdentity","CrossSigningIdentity","checkKeyBackupAndEnable","getOlmMachineOrThrow","stopped","ClientStoppedError","_v","stop","close","encryptEvent","event","_room","_this","_asyncToGenerator","roomId","getRoomId","encryptor","roomEncryptors","Error","concat","globalBlacklistUnverifiedDevices","decryptEvent","_this2","attemptEventDecryption","getEventEncryptionInfo","_event$getSenderKey","ret","senderKey","getSenderKey","undefined","algorithm","getWireContent","encrypted","authenticated","mismatchedSender","checkUserTrust","UserVerificationStatus","getStoredCrossSigningForUser","checkOwnCrossSigningTrust","getBackupDecryptor","backupInfo","privKey","_this3","authData","auth_data","Uint8Array","backupDecryptionKey","RustSdkCryptoJs","fromBase64","encodeBase64","public_key","megolmV1PublicKey","publicKeyBase64","createBackupDecryptor","importBackedUpRoomKeys","keys","backupVersion","opts","_this4","getVersion","versions","matrix_sdk_crypto","git_sha","vodozemac","isEncryptionEnabledInRoom","_this5","roomSettings","getRoomSettings","Boolean","getOwnDeviceKeys","_this6","identityKeys","ed25519","toBase64","curve25519","prepareToEncrypt","room","prepareForEncryption","forceDiscardSession","_this$roomEncryptors$","exportRoomKeys","_this7","raw","JSON","parse","exportRoomKeysAsJson","_this8","importRoomKeys","_this9","importRoomKeysAsJson","_this10","userHasCrossSigningKeys","_arguments","arguments","_this11","rustTrackedUser","length","downloadUncached","rustTrackedUsers","trackedUsers","u","toString","request","queryKeysForUsers","clone","makeOutgoingRequest","userIdentity","getIdentity","free","_keyResult$master_key","keyResult","downloadDeviceList","Set","master_keys","Object","values","getUserDeviceInfo","userIds","_arguments2","_this12","deviceMapByUserId","Map","forEach","rustUserId","add","untrackedUsers","_userId","has","set","getUserDevices","size","queryResult","entries","device_keys","_ref","deviceKeys","deviceKeysToDeviceMap","_this13","userDevices","deviceArray","devices","map","device","deviceId","rustDeviceToJsDevice","d","_this14","queryBody","user","authedRequest","Method","Post","prefix","getTrustCrossSignedDevices","_trustCrossSignedDevices","setTrustCrossSignedDevices","val","setDeviceVerified","_arguments3","_this15","verified","getDevice","setLocalTrust","Verified","Unset","crossSignDevice","_this16","outgoingRequest","verify","getDeviceVerificationStatus","_this17","DeviceVerificationStatus","signedByOwner","isCrossSignedByOwner","crossSigningVerified","isCrossSigningTrusted","localVerified","isLocallyTrusted","trustCrossSignedDevices","getUserVerificationStatus","_this18","isVerified","isCrossSigningReady","_this19","privateKeysInSecretStorage","privateKeysCachedLocally","getCrossSigningStatus","hasKeysInCache","masterKey","selfSigningKey","userSigningKey","identity","getOwnIdentity","getCrossSigningKeyId","_arguments4","_this20","type","CrossSigningKey","Master","key","crossSigningStatus","privateKeysOnDevice","hasMaster","hasUserSigning","hasSelfSigning","SelfSigning","UserSigning","parsedKey","bootstrapCrossSigning","_this21","isSecretStorageReady","_this22","secretsToCheck","keyBackupEnabled","getActiveBackupVersion","push","secretStorageCanAccessSecrets","bootstrapSecretStorage","_arguments5","_this23","createSecretStorageKey","setupNewSecretStorage","setupNewKeyBackup","isNewSecretStorageKeyNeeded","secretStorageHasAESKey","info","recoveryKey","addSecretStorageKeyToSecretStorage","hasPrivateKeys","secretStorageContainsCrossSigningKeys","crossSigningPrivateKeys","exportCrossSigningKeys","self_signing_key","store","resetKeyBackup","secretStorageKey","_this24","_secretStorageKey$key","_secretStorageKey$key2","_this24$cryptoCallbac","_this24$cryptoCallbac2","secretStorageKeyObject","addKey","SECRET_STORAGE_ALGORITHM_V1_AES","passphrase","keyInfo","name","privateKey","setDefaultKeyId","keyId","cacheSecretStorageKey","call","_this25","secretStorageKeyTuple","getKey","_this26","publicKeysOnDevice","createRecoveryKeyFromPassphrase","password","derivation","keyFromPassphrase","iterations","salt","encodedPrivateKey","encodeRecoveryKey","globalThis","crypto","getRandomValues","getEncryptionInfoForEvent","_this27","getVerificationRequestsToDeviceInProgress","requests","getVerificationRequests","filter","RustVerificationRequest","_supportedVerificationMethods","findVerificationRequestDMInProgress","find","_request$roomId","requestVerificationDM","_this28","methods","method","verificationMethodIdentifierToMethod","verificationEventContent","verificationRequestContent","eventId","sendVerificationRequestContent","requestVerification","_this29","txId","randomString","event_id","Put","encodeURIComponent","setSupportedVerificationMethods","requestOwnUserVerification","_this30","requestDeviceVerification","_this31","getSessionBackupPrivateKey","_this32","backupKeys","getBackupKeys","decryptionKey","Buffer","from","storeSessionBackupPrivateKey","version","_this33","base64Key","saveBackupDecryptionKey","getActiveSessionBackupVersion","_this34","isKeyBackupTrusted","_this35","_this36","deleteKeyBackupVersion","_this37","_this38","setupKeyBackup","o","signObject","obj","_this39","sigs","signatures","unsigned","userSignatures","get","canonalizedJson","anotherjson","stringify","sign","asJSON","_objectSpread","fromEntries","isDehydrationSupported","_this40","isSupported","startDehydration","createNewKey","_this41","start","importSecretsBundle","secrets","_this42","secretsBundle","from_json","exportSecretsBundle","_this43","to_json","receiveSyncChanges","_ref2","_this44","events","oneTimeKeysCounts","unusedFallbackKeys","result","logDuration","preprocessToDeviceMessages","_this45","processed","message","EventType","KeyVerificationRequest","sender","transactionId","content","transaction_id","onIncomingKeyVerificationRequest","processKeyCounts","_this46","mapOneTimeKeysCount","setUnusedFallbackKeys","processDeviceLists","deviceLists","_this47","_deviceLists$changed","_deviceLists$left","changed","left","onCryptoEvent","_this48","config","getContent","settings","MegolmV1AesSha2","sessionRotationPeriodMs","rotation_period_ms","sessionRotationPeriodMessages","rotation_period_msgs","setRoomSettings","e","warn","existingEncryptor","RoomEncryptor","onSyncCompleted","syncState","doProcessOutgoingRequests","catch","getVerificationRequest","emit","VerificationRequestReceived","onRoomMembership","member","oldMembership","enc","onRoomKeysUpdated","_this49","onRoomKeyUpdated","maybeUploadKey","_this50","debug","sessionId","pendingList","getEventsPendingRoomKey","getId","_loop","ev","attemptDecryption","isRetry","_e","onRoomKeysWithheld","withheld","_this51","session","onUserIdentityUpdated","_this52","newVerification","UserTrustStatusChanged","KeysChanged","onDevicesUpdated","_this53","WillUpdateDevices","DevicesUpdated","handleSecretReceived","value","_this54","handleBackupSecretReceived","checkSecrets","_this55","pendingValues","getSecretsFromInbox","deleteSecretsFromInbox","onLiveEventFromSync","_this56","isState","getUnsigned","processEvent","_ref4","evt","isVerificationEvent","onKeyVerificationEvent","_x","apply","isDecryptionFailure","isEncrypted","TIMEOUT_DELAY","timeoutId","setTimeout","off","MatrixEventEvent","Decrypted","onDecrypted","decryptedEvent","error","clearTimeout","on","_this57","getType","getSender","receiveVerificationEvent","state_key","getStateKey","origin_server_ts","getTs","RoomMessage","msgtype","MsgType","_this58","MapWithDefault","_this59","addEventToPendingList","res","decryptRoomEvent","stringifyEvent","removeEventFromPendingList","clearEvent","claimedEd25519Key","senderClaimedEd25519Key","senderCurve25519Key","forwardingCurve25519KeyChain","err","DecryptionError","DecryptionFailureCode","UNKNOWN_ERROR","onMegolmDecryptionError","getServerBackupInfo","serverBackupInfo","errorDetails","sender_key","session_id","code","MissingRoomKey","UnknownMessageIndex","onDecryptionKeyMissingError","membership","getMembershipAtEvent","KnownMembership","Join","Invite","HISTORICAL_MESSAGE_USER_NOT_JOINED","deviceCreationTimeMs","HISTORICAL_MESSAGE_NO_KEY_BACKUP","isKeyBackupDownloadConfigured","HISTORICAL_MESSAGE_WORKING_BACKUP","HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED","maybe_withheld","failureCode","MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE","MEGOLM_KEY_WITHHELD","MEGOLM_UNKNOWN_INBOUND_SESSION_ID","OLM_UNKNOWN_MESSAGE_INDEX","description","_this60","getClearContent","status","shieldColour","EventShieldColour","NONE","shieldReason","encryptionInfo","getRoomEventEncryptionInfo","rustEncryptionInfoToJsEncryptionInfo","roomPendingEvents","eventsPendingKey","sessionPendingEvents","getOrCreate","delete","getWireType","shieldState","color","Grey","GREY","None","RED","EventShieldReason","UNVERIFIED_IDENTITY","UNSIGNED_DEVICE","AUTHENTICITY_NOT_GUARANTEED","UNKNOWN_DEVICE","UNKNOWN","isBackupEnabled","activeBackupVersion","signatureVerification","verifyBackup","backupMatchesSavedPrivateKey","backupInfoMatchesBackupDecryptionKey","matchesDecryptionKey","trusted","force","checkedForBackup","Promise","resolve","keyBackupCheckInProgress","doCheckKeyBackup","finally","secret","_backupCheck$backupIn","backupCheck","trustInfo","privateKeyMatches","jsonKeys","importExportedRoomKeys","progress","total","_opts$progressCallbac","importOpt","Number","successes","stage","failures","progressCallback","keysByRoom","room_id","_opts$progressCallbac2","log","requestKeyBackupVersion","activeVersion","disableKeyBackup","enableKeyBackup","enableBackupV1","backupKeysLoop","disableBackup","maxDelay","backupKeysLoopRunning","delay","Math","random","sleep","numFailures","remainingToUploadCount","isFirstIteration","backupRoomKeys","keyCount","roomKeyCounts","backedUp","keysCountInBatch","max","MatrixError","errCode","data","errcode","waitTime","retry_after_ms","pow","min","batch","parsedBody","body","count","sessions","rooms","deleteAllKeyBackupVersions","randomKey","createRandomKey","pubKey","ClientPrefix","V3","_yield$_this16$reques","_yield$_this16$reques2","current","_yield$_this16$reques3","_yield$_this16$reques4","path","encodeUri","$version","Delete","RustBackupDecryptor","_info$auth_data","sourceTrusted","decryptSessions","ciphertexts","sessionData","decrypted","decryptV1","session_data","ephemeral","mac","ciphertext","_requestKeyBackupVersion","Get","currentClaimPromise","ensureSessionsForUsers","userList","prom","then","ensureSessionsForUsersInner","claimRequest","getMissingSessions","outgoingRequestManager","encryptionSettings","prefixedLogger","getChild","members","getJoinedMembers","updateTrackedUsers","shouldEncryptForInvitedMembers","UserId","_event$getTxnId","LogSpan","getTxnId","currentEncryptionPromise","ensureEncryptionSession","encryptEventInner","_this3$room$getBlackl","getEncryptionTargetMembers","lazyLoadedMembersResolved","rustEncryptionSettings","EncryptionSettings","historyVisibility","toRustHistoryVisibility","getHistoryVisibility","EncryptionAlgorithm","rotationPeriod","BigInt","rotationPeriodMessages","getBlacklistUnverifiedDevices","sharingStrategy","CollectStrategy","DeviceBasedStrategyOnlyTrustedDevices","DeviceBasedStrategyAllDevices","shareMessages","shareRoomKey","RoomId","m","r","invalidateGroupSession","encryptedContent","encryptRoomEvent","makeEncrypted","RoomMessageEncrypted","visibility","HistoryVisibility","Invited","RustHistoryVisibility","Joined","Shared","WorldReadable","KeyDownloadErrorCode","KEY_BACKUP_BACKOFF","KeyDownloadError","KeyDownloadRateLimitError","retryMillis","hasConfigurationProblem","configuration","getOrCreateBackupConfiguration","downloadKeysLoop","onBackupStatusChanged","megolmSessionId","isAlreadyInQueue","trace","wasRequestedRecently","queuedRequests","some","markAsNotFoundInBackup","now","Date","sessionLastCheckAttemptedTime","Array","sid","ts","lastCheck","getBackupDecryptionKey","requestRoomKeyFromBackup","$roomId","$sessionId","downloadLoopRunning","queryKeyBackup","decryptAndImport","shift","MISSING_DECRYPTION_KEY","NETWORK_ERROR","STOPPED","targetRoomId","targetSessionId","sessionInfo","sessionsToImport","decryptor","k","currentBackupVersionCheck","internalCheckFromServer","_currentServerVersion","_currentServerVersion2","_currentServerVersion4","_currentServerVersion3","currentServerVersion","backupDecryptor","DeviceVerification","Unverified","isBlacklisted","Blocked","mayBeSignatureMap","convertedSignatures","_key","isValid","signature","rustAlgorithms","algorithms","OlmV1Curve25519AesSha2","Device","displayName","dehydrated","isDehydrated","downloadDeviceToJsDevice","_device$unsigned","device_display_name","device_id","user_id","migrateFromLegacyCrypto","_migrateFromLegacyCrypto","args","_args$legacyMigration2","legacyStore","Debug","turnOn","containsData","startup","accountPickle","doTxn","IndexedDBCryptoStore","STORE_ACCOUNT","txn","getAccount","acctPickle","migrationState","getMigrationState","MigrationState","MEGOLM_SESSIONS_MIGRATED","nOlmSessions","countOlmSessions","nMegolmSessions","countMegolmSessions","totalSteps","stepsDone","onProgress","pickleKey","TextEncoder","encode","legacyPickleKey","NOT_STARTED","migrateBaseData","storeHandle","INITIAL_DATA_MIGRATED","setMigrationState","migrateOlmSessions","OLM_SESSIONS_MIGRATED","migrateMegolmSessions","legacyMigrationProgressListener","steps","_args$legacyMigration","_x2","_x3","_x4","_x5","_x6","_x7","_x8","_migrateBaseData","migrationData","a","pickledAccount","getAndDecryptCachedSecretKey","backupCallDone","_backupInfo$auth_data","publicKey","backupRecoveryKey","privateCrossSigningMasterKey","privateCrossSigningSelfSigningKey","privateCrossSigningUserSigningKey","_x9","_x10","_countOlmSessions","nSessions","STORE_SESSIONS","countEndToEndSessions","n","_x11","_x12","_countMegolmSessions","countEndToEndInboundGroupSessions","_x13","_x14","_x15","_x16","_x17","_migrateOlmSessions","onBatchDone","getEndToEndSessionsBatch","pickledSession","deviceKey","pickle","lastUseTime","creationTime","lastReceivedMessageTs","deleteEndToEndSessionsBatch","_x18","_x19","_x20","_x21","_x22","_migrateMegolmSessions","getEndToEndInboundGroupSessionsBatch","_sessionData$keysClai","senderSigningKey","keysClaimed","needsBackup","imported","untrusted","deleteEndToEndInboundGroupSessionsBatch","migrateRoomSettingsFromLegacyCrypto","_x23","_migrateRoomSettingsFromLegacyCrypto","ROOM_SETTINGS_MIGRATED","legacySettings","STORE_ROOMS","getEndToEndRooms","rustSettings","_x24","_x25","_x26","_getAndDecryptCachedSecretKey","getSecretStorePrivateKey","iv","decryptAES","migrateLegacyLocalTrustIfNeeded","_x27","_migrateLegacyLocalTrustIfNeeded","legacyCryptoStore","rustCrypto","rustOwnIdentity","legacyLocallyTrustedMSK","getLegacyTrustedPublicMasterKeyBase64","mskInfo","rustSeenMSK","_x28","_getLegacyTrustedPublicMasterKeyBase","maybeTrustedKeys","getCrossSigningKeys","msk","master","initRustCrypto","_initRustCrypto","storePrefix","storeKey","StoreHandle","openWithKey","open","storePassphrase","initOlmMachine","_initOlmMachine","initFromStore","roomKeyRequestsEnabled","registerRoomKeyUpdatedCallback","registerRoomKeysWithheldCallback","registerUserIdentityUpdatedCallback","registerDevicesUpdatedCallback","registerReceiveSecretCallback","_value","outgoingRequests","INITIAL_OWN_KEY_QUERY_DONE","initialKeyQueryDone","msg","uiaCallback","resp","KeysUploadRequest","requestWithRetry","KeysQueryRequest","KeysClaimRequest","SignatureUploadRequest","KeysBackupRequest","ToDeviceRequest","sendToDeviceRequest","RoomMessageRequest","event_type","txn_id","UploadSigningKeysRequest","makeRequestWithUIA","PutDehydratedDeviceRequest","_path","DehydrationUnstablePrefix","rawJsonRequest","getPrototypeOf","id","markRequestAsSent","messageList","perUserMessages","messages","ToDeviceMessageId","queryParams","makeRequest","auth","newBody","currentRetryCount","backoff","calculateRetryBackoff","json","headers","inner","supportedVerificationMethods","reEmitter","weakThis","WeakRef","registerChangesCallback","_weakThis$deref","deref","onChange","verification","getVerification","_verifier","RustQrCodeVerifier","setVerifier","RustSASVerifier","replaceInner","VerificationRequestEvent","Change","verifier","stopReEmitting","flowId","_this$inner$roomId","weStarted","otherUserId","_this$inner$otherDevi","otherDeviceId","getOtherDevice","isSelfVerification","phase","Created","Requested","VerificationPhase","Ready","_accepting","Transitioned","verificationPhase","Done","Cancelled","isPassive","_cancelling","timeRemainingMillis","Started","otherPartySupportsMethod","theirMethods","theirSupportedMethods","requiredMethod","verificationMethodsByIdentifier","accept","req","acceptWithMethods","cancel","params","beginKeyVerification","targetDevice","startVerification","startSas","scanQRCode","uint8Array","scan","fromBytes","Uint8ClampedArray","scanQrCode","reciprocate","getQRCodeBytes","generateQRCode","innerVerifier","generateQrCode","toBytes","_this$inner$cancelInf","_this$inner$cancelInf2","cancelInfo","cancelCode","cancelledbyUs","BaseRustVerifer","completionDeferred","defer","_weakThis$deref2","promise","isDone","isCancelled","reject","reason","getShowSasCallbacks","getReciprocateQrCodeCallbacks","callbacks","hasBeenScanned","confirm","confirmScanning","VerifierEvent","ShowReciprocateQr","state","QrState","Scanned","Confirmed","Reciprocated","_verificationRequest","sendAccept","emoji","decimal","decimals","sas","symbol","_confirm","mismatch","cancelWithCode","ShowSas","_weakThis$deref3","SasV1","QrCodeScanV1","QrCodeShowV1","ReciprocateV1","meth","KeyVerificationCancel","KeyVerificationDone","KeyVerificationMac","KeyVerificationStart","KeyVerificationKey","KeyVerificationReady","KeyVerificationAccept","nextLoopDeferred","outgoingRequestLoopRunning","outgoingRequestLoop","deferred","processOutgoingRequests","v","_ret","setupNewCrossSigning","resetCrossSigning","authUploadDeviceSigningKeys","olmDeviceStatus","masterKeyFromSecretStorage","selfSigningKeyFromSecretStorage","userSigningKeyFromSecretStorage","olmDeviceHasKeys","olmDeviceHasMaster","olmDeviceHasUserSigning","olmDeviceHasSelfSigning","hasKey","exportCrossSigningKeysToStorage","importCrossSigningKeys","uploadKeysRequest","uploadSigningKeysRequest","uploadSignaturesRequest","exported","_secretStorageContainsCrossSigningKeys","_secretStorageCanAccessSecrets","secretNames","defaultKeyId","getDefaultKeyId","secretName","record","isStored","UnstablePrefix","SECRET_STORAGE_NAME","DEHYDRATION_INTERVAL","rehydrateDeviceIfAvailable","resetKey","scheduleDeviceDehydration","isKeyStored","encodeUnpaddedBase64","create","keyB64","decodeBase64","dehydratedDeviceResp","rehydratedDevice","dehydratedDevices","rehydrate","device_data","nextBatch","toDeviceCount","roomKeyCount","$device_id","eventResp","next_batch","roomKeyInfos","receiveEvents","createAndUploadDehydratedDevice","dehydratedDevice","keysForUpload","intervalId","setInterval","clearInterval"],"mappings":"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","file":"matrix-element.16.min.js","sourcesContent":["/*\r\nCopyright 2022-2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport anotherjson from \"another-json\";\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport type { IEventDecryptionResult, IMegolmSessionData } from \"../@types/crypto\";\r\nimport { KnownMembership } from \"../@types/membership\";\r\nimport type { IDeviceLists, IToDeviceEvent } from \"../sync-accumulator\";\r\nimport type { IEncryptedEventInfo } from \"../crypto/api\";\r\nimport { MatrixEvent, MatrixEventEvent } from \"../models/event\";\r\nimport { Room } from \"../models/room\";\r\nimport { RoomMember } from \"../models/room-member\";\r\nimport { BackupDecryptor, CryptoBackend, DecryptionError, OnSyncCompletedData } from \"../common-crypto/CryptoBackend\";\r\nimport { logger, Logger } from \"../logger\";\r\nimport { IHttpOpts, MatrixHttpApi, Method } from \"../http-api\";\r\nimport { RoomEncryptor } from \"./RoomEncryptor\";\r\nimport { OutgoingRequestProcessor } from \"./OutgoingRequestProcessor\";\r\nimport { KeyClaimManager } from \"./KeyClaimManager\";\r\nimport { logDuration, MapWithDefault } from \"../utils\";\r\nimport {\r\n    BackupTrustInfo,\r\n    BootstrapCrossSigningOpts,\r\n    CreateSecretStorageOpts,\r\n    CrossSigningKey,\r\n    CrossSigningKeyInfo,\r\n    CrossSigningStatus,\r\n    CryptoApi,\r\n    CryptoCallbacks,\r\n    Curve25519AuthData,\r\n    DecryptionFailureCode,\r\n    DeviceVerificationStatus,\r\n    EventEncryptionInfo,\r\n    EventShieldColour,\r\n    EventShieldReason,\r\n    GeneratedSecretStorageKey,\r\n    ImportRoomKeysOpts,\r\n    KeyBackupCheck,\r\n    KeyBackupInfo,\r\n    OwnDeviceKeys,\r\n    UserVerificationStatus,\r\n    VerificationRequest,\r\n} from \"../crypto-api\";\r\nimport { deviceKeysToDeviceMap, rustDeviceToJsDevice } from \"./device-converter\";\r\nimport { IDownloadKeyResult, IQueryKeysRequest } from \"../client\";\r\nimport { Device, DeviceMap } from \"../models/device\";\r\nimport { SECRET_STORAGE_ALGORITHM_V1_AES, ServerSideSecretStorage } from \"../secret-storage\";\r\nimport { CrossSigningIdentity } from \"./CrossSigningIdentity\";\r\nimport { secretStorageCanAccessSecrets, secretStorageContainsCrossSigningKeys } from \"./secret-storage\";\r\nimport { keyFromPassphrase } from \"../crypto/key_passphrase\";\r\nimport { encodeRecoveryKey } from \"../crypto/recoverykey\";\r\nimport { isVerificationEvent, RustVerificationRequest, verificationMethodIdentifierToMethod } from \"./verification\";\r\nimport { EventType, MsgType } from \"../@types/event\";\r\nimport { CryptoEvent } from \"../crypto\";\r\nimport { TypedEventEmitter } from \"../models/typed-event-emitter\";\r\nimport { RustBackupCryptoEventMap, RustBackupCryptoEvents, RustBackupManager } from \"./backup\";\r\nimport { TypedReEmitter } from \"../ReEmitter\";\r\nimport { randomString } from \"../randomstring\";\r\nimport { ClientStoppedError } from \"../errors\";\r\nimport { ISignatures } from \"../@types/signed\";\r\nimport { encodeBase64 } from \"../base64\";\r\nimport { OutgoingRequestsManager } from \"./OutgoingRequestsManager\";\r\nimport { PerSessionKeyBackupDownloader } from \"./PerSessionKeyBackupDownloader\";\r\nimport { DehydratedDeviceManager } from \"./DehydratedDeviceManager\";\r\nimport { VerificationMethod } from \"../types\";\r\n\r\nconst ALL_VERIFICATION_METHODS = [\r\n    VerificationMethod.Sas,\r\n    VerificationMethod.ScanQrCode,\r\n    VerificationMethod.ShowQrCode,\r\n    VerificationMethod.Reciprocate,\r\n];\r\n\r\ninterface ISignableObject {\r\n    signatures?: ISignatures;\r\n    unsigned?: object;\r\n}\r\n\r\n/**\r\n * An implementation of {@link CryptoBackend} using the Rust matrix-sdk-crypto.\r\n *\r\n * @internal\r\n */\r\nexport class RustCrypto extends TypedEventEmitter<RustCryptoEvents, RustCryptoEventMap> implements CryptoBackend {\r\n    private _trustCrossSignedDevices = true;\r\n\r\n    /** whether {@link stop} has been called */\r\n    private stopped = false;\r\n\r\n    /** mapping of roomId  encryptor class */\r\n    private roomEncryptors: Record<string, RoomEncryptor> = {};\r\n\r\n    private eventDecryptor: EventDecryptor;\r\n    private keyClaimManager: KeyClaimManager;\r\n    private outgoingRequestProcessor: OutgoingRequestProcessor;\r\n    private crossSigningIdentity: CrossSigningIdentity;\r\n    private readonly backupManager: RustBackupManager;\r\n    private outgoingRequestsManager: OutgoingRequestsManager;\r\n    private readonly perSessionBackupDownloader: PerSessionKeyBackupDownloader;\r\n    private readonly dehydratedDeviceManager: DehydratedDeviceManager;\r\n    private readonly reemitter = new TypedReEmitter<RustCryptoEvents, RustCryptoEventMap>(this);\r\n\r\n    public constructor(\r\n        private readonly logger: Logger,\r\n\r\n        /** The `OlmMachine` from the underlying rust crypto sdk. */\r\n        private readonly olmMachine: RustSdkCryptoJs.OlmMachine,\r\n\r\n        /**\r\n         * Low-level HTTP interface: used to make outgoing requests required by the rust SDK.\r\n         *\r\n         * We expect it to set the access token, etc.\r\n         */\r\n        private readonly http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\r\n\r\n        /** The local user's User ID. */\r\n        private readonly userId: string,\r\n\r\n        /** The local user's Device ID. */\r\n        _deviceId: string,\r\n\r\n        /** Interface to server-side secret storage */\r\n        private readonly secretStorage: ServerSideSecretStorage,\r\n\r\n        /** Crypto callbacks provided by the application */\r\n        private readonly cryptoCallbacks: CryptoCallbacks,\r\n    ) {\r\n        super();\r\n        this.outgoingRequestProcessor = new OutgoingRequestProcessor(olmMachine, http);\r\n        this.outgoingRequestsManager = new OutgoingRequestsManager(\r\n            this.logger,\r\n            olmMachine,\r\n            this.outgoingRequestProcessor,\r\n        );\r\n\r\n        this.keyClaimManager = new KeyClaimManager(olmMachine, this.outgoingRequestProcessor);\r\n\r\n        this.backupManager = new RustBackupManager(olmMachine, http, this.outgoingRequestProcessor);\r\n        this.perSessionBackupDownloader = new PerSessionKeyBackupDownloader(\r\n            this.logger,\r\n            this.olmMachine,\r\n            this.http,\r\n            this.backupManager,\r\n        );\r\n        this.dehydratedDeviceManager = new DehydratedDeviceManager(\r\n            this.logger,\r\n            olmMachine,\r\n            http,\r\n            this.outgoingRequestProcessor,\r\n            secretStorage,\r\n        );\r\n        this.eventDecryptor = new EventDecryptor(this.logger, olmMachine, this.perSessionBackupDownloader);\r\n\r\n        this.reemitter.reEmit(this.backupManager, [\r\n            CryptoEvent.KeyBackupStatus,\r\n            CryptoEvent.KeyBackupSessionsRemaining,\r\n            CryptoEvent.KeyBackupFailed,\r\n            CryptoEvent.KeyBackupDecryptionKeyCached,\r\n        ]);\r\n\r\n        this.crossSigningIdentity = new CrossSigningIdentity(olmMachine, this.outgoingRequestProcessor, secretStorage);\r\n\r\n        // Check and start in background the key backup connection\r\n        this.checkKeyBackupAndEnable();\r\n    }\r\n\r\n    /**\r\n     * Return the OlmMachine only if {@link RustCrypto#stop} has not been called.\r\n     *\r\n     * This allows us to better handle race conditions where the client is stopped before or during a crypto API call.\r\n     *\r\n     * @throws ClientStoppedError if {@link RustCrypto#stop} has been called.\r\n     */\r\n    private getOlmMachineOrThrow(): RustSdkCryptoJs.OlmMachine {\r\n        if (this.stopped) {\r\n            throw new ClientStoppedError();\r\n        }\r\n        return this.olmMachine;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // CryptoBackend implementation\r\n    //\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    public set globalErrorOnUnknownDevices(_v: boolean) {\r\n        // Not implemented for rust crypto.\r\n    }\r\n\r\n    public get globalErrorOnUnknownDevices(): boolean {\r\n        // Not implemented for rust crypto.\r\n        return false;\r\n    }\r\n\r\n    public stop(): void {\r\n        // stop() may be called multiple times, but attempting to close() the OlmMachine twice\r\n        // will cause an error.\r\n        if (this.stopped) {\r\n            return;\r\n        }\r\n        this.stopped = true;\r\n\r\n        this.keyClaimManager.stop();\r\n        this.backupManager.stop();\r\n        this.outgoingRequestsManager.stop();\r\n        this.perSessionBackupDownloader.stop();\r\n        this.dehydratedDeviceManager.stop();\r\n\r\n        // make sure we close() the OlmMachine; doing so means that all the Rust objects will be\r\n        // cleaned up; in particular, the indexeddb connections will be closed, which means they\r\n        // can then be deleted.\r\n        this.olmMachine.close();\r\n    }\r\n\r\n    public async encryptEvent(event: MatrixEvent, _room: Room): Promise<void> {\r\n        const roomId = event.getRoomId()!;\r\n        const encryptor = this.roomEncryptors[roomId];\r\n\r\n        if (!encryptor) {\r\n            throw new Error(`Cannot encrypt event in unconfigured room ${roomId}`);\r\n        }\r\n\r\n        await encryptor.encryptEvent(event, this.globalBlacklistUnverifiedDevices);\r\n    }\r\n\r\n    public async decryptEvent(event: MatrixEvent): Promise<IEventDecryptionResult> {\r\n        const roomId = event.getRoomId();\r\n        if (!roomId) {\r\n            // presumably, a to-device message. These are normally decrypted in preprocessToDeviceMessages\r\n            // so the fact it has come back here suggests that decryption failed.\r\n            //\r\n            // once we drop support for the libolm crypto implementation, we can stop passing to-device messages\r\n            // through decryptEvent and hence get rid of this case.\r\n            throw new Error(\"to-device event was not decrypted in preprocessToDeviceMessages\");\r\n        }\r\n        return await this.eventDecryptor.attemptEventDecryption(event);\r\n    }\r\n\r\n    /**\r\n     * Implementation of (deprecated) {@link MatrixClient#getEventEncryptionInfo}.\r\n     *\r\n     * @param event - event to inspect\r\n     */\r\n    public getEventEncryptionInfo(event: MatrixEvent): IEncryptedEventInfo {\r\n        const ret: Partial<IEncryptedEventInfo> = {};\r\n\r\n        ret.senderKey = event.getSenderKey() ?? undefined;\r\n        ret.algorithm = event.getWireContent().algorithm;\r\n\r\n        if (!ret.senderKey || !ret.algorithm) {\r\n            ret.encrypted = false;\r\n            return ret as IEncryptedEventInfo;\r\n        }\r\n        ret.encrypted = true;\r\n        ret.authenticated = true;\r\n        ret.mismatchedSender = true;\r\n        return ret as IEncryptedEventInfo;\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoBackend#checkUserTrust}.\r\n     *\r\n     * Stub for backwards compatibility.\r\n     *\r\n     */\r\n    public checkUserTrust(userId: string): UserVerificationStatus {\r\n        return new UserVerificationStatus(false, false, false);\r\n    }\r\n\r\n    /**\r\n     * Get the cross signing information for a given user.\r\n     *\r\n     * The cross-signing API is currently UNSTABLE and may change without notice.\r\n     *\r\n     * @param userId - the user ID to get the cross-signing info for.\r\n     *\r\n     * @returns the cross signing information for the user.\r\n     */\r\n    public getStoredCrossSigningForUser(userId: string): null {\r\n        // TODO\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This function is unneeded for the rust-crypto.\r\n     * The cross signing key import and the device verification are done in {@link CryptoApi#bootstrapCrossSigning}\r\n     *\r\n     * The function is stub to keep the compatibility with the old crypto.\r\n     * More information: https://github.com/vector-im/element-web/issues/25648\r\n     *\r\n     * Implementation of {@link CryptoBackend#checkOwnCrossSigningTrust}\r\n     */\r\n    public async checkOwnCrossSigningTrust(): Promise<void> {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoBackend#getBackupDecryptor}.\r\n     */\r\n    public async getBackupDecryptor(backupInfo: KeyBackupInfo, privKey: ArrayLike<number>): Promise<BackupDecryptor> {\r\n        if (backupInfo.algorithm != \"m.megolm_backup.v1.curve25519-aes-sha2\") {\r\n            throw new Error(`getBackupDecryptor Unsupported algorithm ${backupInfo.algorithm}`);\r\n        }\r\n\r\n        const authData = <Curve25519AuthData>backupInfo.auth_data;\r\n\r\n        if (!(privKey instanceof Uint8Array)) {\r\n            throw new Error(`getBackupDecryptor expects Uint8Array`);\r\n        }\r\n\r\n        const backupDecryptionKey = RustSdkCryptoJs.BackupDecryptionKey.fromBase64(encodeBase64(privKey));\r\n\r\n        if (authData.public_key != backupDecryptionKey.megolmV1PublicKey.publicKeyBase64) {\r\n            throw new Error(`getBackupDecryptor key mismatch error`);\r\n        }\r\n\r\n        return this.backupManager.createBackupDecryptor(backupDecryptionKey);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoBackend#importBackedUpRoomKeys}.\r\n     */\r\n    public async importBackedUpRoomKeys(\r\n        keys: IMegolmSessionData[],\r\n        backupVersion: string,\r\n        opts?: ImportRoomKeysOpts,\r\n    ): Promise<void> {\r\n        return await this.backupManager.importBackedUpRoomKeys(keys, backupVersion, opts);\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // CryptoApi implementation\r\n    //\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    public globalBlacklistUnverifiedDevices = false;\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#getVersion}.\r\n     */\r\n    public getVersion(): string {\r\n        const versions = RustSdkCryptoJs.getVersions();\r\n        return `Rust SDK ${versions.matrix_sdk_crypto} (${versions.git_sha}), Vodozemac ${versions.vodozemac}`;\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#isEncryptionEnabledInRoom}.\r\n     */\r\n    public async isEncryptionEnabledInRoom(roomId: string): Promise<boolean> {\r\n        const roomSettings: RustSdkCryptoJs.RoomSettings | undefined = await this.olmMachine.getRoomSettings(\r\n            new RustSdkCryptoJs.RoomId(roomId),\r\n        );\r\n        return Boolean(roomSettings?.algorithm);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#getOwnDeviceKeys}.\r\n     */\r\n    public async getOwnDeviceKeys(): Promise<OwnDeviceKeys> {\r\n        const keys = this.olmMachine.identityKeys;\r\n        return { ed25519: keys.ed25519.toBase64(), curve25519: keys.curve25519.toBase64() };\r\n    }\r\n\r\n    public prepareToEncrypt(room: Room): void {\r\n        const encryptor = this.roomEncryptors[room.roomId];\r\n\r\n        if (encryptor) {\r\n            encryptor.prepareForEncryption(this.globalBlacklistUnverifiedDevices);\r\n        }\r\n    }\r\n\r\n    public forceDiscardSession(roomId: string): Promise<void> {\r\n        return this.roomEncryptors[roomId]?.forceDiscardSession();\r\n    }\r\n\r\n    public async exportRoomKeys(): Promise<IMegolmSessionData[]> {\r\n        const raw = await this.olmMachine.exportRoomKeys(() => true);\r\n        return JSON.parse(raw);\r\n    }\r\n\r\n    public async exportRoomKeysAsJson(): Promise<string> {\r\n        return await this.olmMachine.exportRoomKeys(() => true);\r\n    }\r\n\r\n    public async importRoomKeys(keys: IMegolmSessionData[], opts?: ImportRoomKeysOpts): Promise<void> {\r\n        return await this.backupManager.importRoomKeys(keys, opts);\r\n    }\r\n\r\n    public async importRoomKeysAsJson(keys: string, opts?: ImportRoomKeysOpts): Promise<void> {\r\n        return await this.backupManager.importRoomKeysAsJson(keys, opts);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi.userHasCrossSigningKeys}.\r\n     */\r\n    public async userHasCrossSigningKeys(userId = this.userId, downloadUncached = false): Promise<boolean> {\r\n        // TODO: could probably do with a more efficient way of doing this than returning the whole set and searching\r\n        const rustTrackedUsers: Set<RustSdkCryptoJs.UserId> = await this.olmMachine.trackedUsers();\r\n        let rustTrackedUser: RustSdkCryptoJs.UserId | undefined;\r\n        for (const u of rustTrackedUsers) {\r\n            if (userId === u.toString()) {\r\n                rustTrackedUser = u;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (rustTrackedUser !== undefined) {\r\n            if (userId === this.userId) {\r\n                /* make sure we have an *up-to-date* idea of the user's cross-signing keys. This is important, because if we\r\n                 * return \"false\" here, we will end up generating new cross-signing keys and replacing the existing ones.\r\n                 */\r\n                const request = this.olmMachine.queryKeysForUsers(\r\n                    // clone as rust layer will take ownership and it's reused later\r\n                    [rustTrackedUser.clone()],\r\n                );\r\n                await this.outgoingRequestProcessor.makeOutgoingRequest(request);\r\n            }\r\n            const userIdentity = await this.olmMachine.getIdentity(rustTrackedUser);\r\n            userIdentity?.free();\r\n            return userIdentity !== undefined;\r\n        } else if (downloadUncached) {\r\n            // Download the cross signing keys and check if the master key is available\r\n            const keyResult = await this.downloadDeviceList(new Set([userId]));\r\n            const keys = keyResult.master_keys?.[userId];\r\n\r\n            // No master key\r\n            if (!keys) return false;\r\n\r\n            // `keys` is an object with { [`ed25519:${pubKey}`]: pubKey }\r\n            // We assume only a single key, and we want the bare form without type\r\n            // prefix, so we select the values.\r\n            return Boolean(Object.values(keys.keys)[0]);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the device information for the given list of users.\r\n     *\r\n     * @param userIds - The users to fetch.\r\n     * @param downloadUncached - If true, download the device list for users whose device list we are not\r\n     *    currently tracking. Defaults to false, in which case such users will not appear at all in the result map.\r\n     *\r\n     * @returns A map `{@link DeviceMap}`.\r\n     */\r\n    public async getUserDeviceInfo(userIds: string[], downloadUncached = false): Promise<DeviceMap> {\r\n        const deviceMapByUserId = new Map<string, Map<string, Device>>();\r\n        const rustTrackedUsers: Set<RustSdkCryptoJs.UserId> = await this.getOlmMachineOrThrow().trackedUsers();\r\n\r\n        // Convert RustSdkCryptoJs.UserId to a `Set<string>`\r\n        const trackedUsers = new Set<string>();\r\n        rustTrackedUsers.forEach((rustUserId) => trackedUsers.add(rustUserId.toString()));\r\n\r\n        // Keep untracked user to download their keys after\r\n        const untrackedUsers: Set<string> = new Set();\r\n\r\n        for (const userId of userIds) {\r\n            // if this is a tracked user, we can just fetch the device list from the rust-sdk\r\n            // (NB: this is probably ok even if we race with a leave event such that we stop tracking the user's\r\n            // devices: the rust-sdk will return the last-known device list, which will be good enough.)\r\n            if (trackedUsers.has(userId)) {\r\n                deviceMapByUserId.set(userId, await this.getUserDevices(userId));\r\n            } else {\r\n                untrackedUsers.add(userId);\r\n            }\r\n        }\r\n\r\n        // for any users whose device lists we are not tracking, fall back to downloading the device list\r\n        // over HTTP.\r\n        if (downloadUncached && untrackedUsers.size >= 1) {\r\n            const queryResult = await this.downloadDeviceList(untrackedUsers);\r\n            Object.entries(queryResult.device_keys).forEach(([userId, deviceKeys]) =>\r\n                deviceMapByUserId.set(userId, deviceKeysToDeviceMap(deviceKeys)),\r\n            );\r\n        }\r\n\r\n        return deviceMapByUserId;\r\n    }\r\n\r\n    /**\r\n     * Get the device list for the given user from the olm machine\r\n     * @param userId - Rust SDK UserId\r\n     */\r\n    private async getUserDevices(userId: string): Promise<Map<string, Device>> {\r\n        const rustUserId = new RustSdkCryptoJs.UserId(userId);\r\n\r\n        // For reasons I don't really understand, the Javascript FinalizationRegistry doesn't seem to run the\r\n        // registered callbacks when `userDevices` goes out of scope, nor when the individual devices in the array\r\n        // returned by `userDevices.devices` do so.\r\n        //\r\n        // This is particularly problematic, because each of those structures holds a reference to the\r\n        // VerificationMachine, which in turn holds a reference to the IndexeddbCryptoStore. Hence, we end up leaking\r\n        // open connections to the crypto store, which means the store can't be deleted on logout.\r\n        //\r\n        // To fix this, we explicitly call `.free` on each of the objects, which tells the rust code to drop the\r\n        // allocated memory and decrement the refcounts for the crypto store.\r\n\r\n        // Wait for up to a second for any in-flight device list requests to complete.\r\n        // The reason for this isn't so much to avoid races (some level of raciness is\r\n        // inevitable for this method) but to make testing easier.\r\n        const userDevices: RustSdkCryptoJs.UserDevices = await this.olmMachine.getUserDevices(rustUserId, 1);\r\n        try {\r\n            const deviceArray: RustSdkCryptoJs.Device[] = userDevices.devices();\r\n            try {\r\n                return new Map(\r\n                    deviceArray.map((device) => [device.deviceId.toString(), rustDeviceToJsDevice(device, rustUserId)]),\r\n                );\r\n            } finally {\r\n                deviceArray.forEach((d) => d.free());\r\n            }\r\n        } finally {\r\n            userDevices.free();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Download the given user keys by calling `/keys/query` request\r\n     * @param untrackedUsers - download keys of these users\r\n     */\r\n    private async downloadDeviceList(untrackedUsers: Set<string>): Promise<IDownloadKeyResult> {\r\n        const queryBody: IQueryKeysRequest = { device_keys: {} };\r\n        untrackedUsers.forEach((user) => (queryBody.device_keys[user] = []));\r\n\r\n        return await this.http.authedRequest(Method.Post, \"/_matrix/client/v3/keys/query\", undefined, queryBody, {\r\n            prefix: \"\",\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#getTrustCrossSignedDevices}.\r\n     */\r\n    public getTrustCrossSignedDevices(): boolean {\r\n        return this._trustCrossSignedDevices;\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#setTrustCrossSignedDevices}.\r\n     */\r\n    public setTrustCrossSignedDevices(val: boolean): void {\r\n        this._trustCrossSignedDevices = val;\r\n        // TODO: legacy crypto goes through the list of known devices and emits DeviceVerificationChanged\r\n        //  events. Maybe we need to do the same?\r\n    }\r\n\r\n    /**\r\n     * Mark the given device as locally verified.\r\n     *\r\n     * Implementation of {@link CryptoApi#setDeviceVerified}.\r\n     */\r\n    public async setDeviceVerified(userId: string, deviceId: string, verified = true): Promise<void> {\r\n        const device: RustSdkCryptoJs.Device | undefined = await this.olmMachine.getDevice(\r\n            new RustSdkCryptoJs.UserId(userId),\r\n            new RustSdkCryptoJs.DeviceId(deviceId),\r\n        );\r\n\r\n        if (!device) {\r\n            throw new Error(`Unknown device ${userId}|${deviceId}`);\r\n        }\r\n        try {\r\n            await device.setLocalTrust(\r\n                verified ? RustSdkCryptoJs.LocalTrust.Verified : RustSdkCryptoJs.LocalTrust.Unset,\r\n            );\r\n        } finally {\r\n            device.free();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Blindly cross-sign one of our other devices.\r\n     *\r\n     * Implementation of {@link CryptoApi#crossSignDevice}.\r\n     */\r\n    public async crossSignDevice(deviceId: string): Promise<void> {\r\n        const device: RustSdkCryptoJs.Device | undefined = await this.olmMachine.getDevice(\r\n            new RustSdkCryptoJs.UserId(this.userId),\r\n            new RustSdkCryptoJs.DeviceId(deviceId),\r\n        );\r\n        if (!device) {\r\n            throw new Error(`Unknown device ${deviceId}`);\r\n        }\r\n        try {\r\n            const outgoingRequest: RustSdkCryptoJs.SignatureUploadRequest = await device.verify();\r\n            await this.outgoingRequestProcessor.makeOutgoingRequest(outgoingRequest);\r\n        } finally {\r\n            device.free();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#getDeviceVerificationStatus}.\r\n     */\r\n    public async getDeviceVerificationStatus(\r\n        userId: string,\r\n        deviceId: string,\r\n    ): Promise<DeviceVerificationStatus | null> {\r\n        const device: RustSdkCryptoJs.Device | undefined = await this.olmMachine.getDevice(\r\n            new RustSdkCryptoJs.UserId(userId),\r\n            new RustSdkCryptoJs.DeviceId(deviceId),\r\n        );\r\n\r\n        if (!device) return null;\r\n        try {\r\n            return new DeviceVerificationStatus({\r\n                signedByOwner: device.isCrossSignedByOwner(),\r\n                crossSigningVerified: device.isCrossSigningTrusted(),\r\n                localVerified: device.isLocallyTrusted(),\r\n                trustCrossSignedDevices: this._trustCrossSignedDevices,\r\n            });\r\n        } finally {\r\n            device.free();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#getUserVerificationStatus}.\r\n     */\r\n    public async getUserVerificationStatus(userId: string): Promise<UserVerificationStatus> {\r\n        const userIdentity: RustSdkCryptoJs.UserIdentity | RustSdkCryptoJs.OwnUserIdentity | undefined =\r\n            await this.getOlmMachineOrThrow().getIdentity(new RustSdkCryptoJs.UserId(userId));\r\n        if (userIdentity === undefined) {\r\n            return new UserVerificationStatus(false, false, false);\r\n        }\r\n        const verified = userIdentity.isVerified();\r\n        userIdentity.free();\r\n        return new UserVerificationStatus(verified, false, false);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#isCrossSigningReady}\r\n     */\r\n    public async isCrossSigningReady(): Promise<boolean> {\r\n        const { privateKeysInSecretStorage, privateKeysCachedLocally } = await this.getCrossSigningStatus();\r\n        const hasKeysInCache =\r\n            Boolean(privateKeysCachedLocally.masterKey) &&\r\n            Boolean(privateKeysCachedLocally.selfSigningKey) &&\r\n            Boolean(privateKeysCachedLocally.userSigningKey);\r\n\r\n        const identity = await this.getOwnIdentity();\r\n\r\n        // Cross-signing is ready if the public identity is trusted, and the private keys\r\n        // are either cached, or accessible via secret-storage.\r\n        return !!identity?.isVerified() && (hasKeysInCache || privateKeysInSecretStorage);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#getCrossSigningKeyId}\r\n     */\r\n    public async getCrossSigningKeyId(type: CrossSigningKey = CrossSigningKey.Master): Promise<string | null> {\r\n        const userIdentity: RustSdkCryptoJs.OwnUserIdentity | undefined = await this.olmMachine.getIdentity(\r\n            new RustSdkCryptoJs.UserId(this.userId),\r\n        );\r\n        if (!userIdentity) {\r\n            // The public keys are not available on this device\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            const crossSigningStatus: RustSdkCryptoJs.CrossSigningStatus = await this.olmMachine.crossSigningStatus();\r\n\r\n            const privateKeysOnDevice =\r\n                crossSigningStatus.hasMaster && crossSigningStatus.hasUserSigning && crossSigningStatus.hasSelfSigning;\r\n\r\n            if (!privateKeysOnDevice) {\r\n                // The private keys are not available on this device\r\n                return null;\r\n            }\r\n\r\n            if (!userIdentity.isVerified()) {\r\n                // We have both public and private keys, but they don't match!\r\n                return null;\r\n            }\r\n\r\n            let key: string;\r\n            switch (type) {\r\n                case CrossSigningKey.Master:\r\n                    key = userIdentity.masterKey;\r\n                    break;\r\n                case CrossSigningKey.SelfSigning:\r\n                    key = userIdentity.selfSigningKey;\r\n                    break;\r\n                case CrossSigningKey.UserSigning:\r\n                    key = userIdentity.userSigningKey;\r\n                    break;\r\n                default:\r\n                    // Unknown type\r\n                    return null;\r\n            }\r\n\r\n            const parsedKey: CrossSigningKeyInfo = JSON.parse(key);\r\n            // `keys` is an object with { [`ed25519:${pubKey}`]: pubKey }\r\n            // We assume only a single key, and we want the bare form without type\r\n            // prefix, so we select the values.\r\n            return Object.values(parsedKey.keys)[0];\r\n        } finally {\r\n            userIdentity.free();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#boostrapCrossSigning}\r\n     */\r\n    public async bootstrapCrossSigning(opts: BootstrapCrossSigningOpts): Promise<void> {\r\n        await this.crossSigningIdentity.bootstrapCrossSigning(opts);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#isSecretStorageReady}\r\n     */\r\n    public async isSecretStorageReady(): Promise<boolean> {\r\n        // make sure that the cross-signing keys are stored\r\n        const secretsToCheck = [\r\n            \"m.cross_signing.master\",\r\n            \"m.cross_signing.user_signing\",\r\n            \"m.cross_signing.self_signing\",\r\n        ];\r\n\r\n        // if key backup is active, we also need to check that the backup decryption key is stored\r\n        const keyBackupEnabled = (await this.backupManager.getActiveBackupVersion()) != null;\r\n        if (keyBackupEnabled) {\r\n            secretsToCheck.push(\"m.megolm_backup.v1\");\r\n        }\r\n\r\n        return secretStorageCanAccessSecrets(this.secretStorage, secretsToCheck);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#bootstrapSecretStorage}\r\n     */\r\n    public async bootstrapSecretStorage({\r\n        createSecretStorageKey,\r\n        setupNewSecretStorage,\r\n        setupNewKeyBackup,\r\n    }: CreateSecretStorageOpts = {}): Promise<void> {\r\n        // If an AES Key is already stored in the secret storage and setupNewSecretStorage is not set\r\n        // we don't want to create a new key\r\n        const isNewSecretStorageKeyNeeded = setupNewSecretStorage || !(await this.secretStorageHasAESKey());\r\n\r\n        if (isNewSecretStorageKeyNeeded) {\r\n            if (!createSecretStorageKey) {\r\n                throw new Error(\"unable to create a new secret storage key, createSecretStorageKey is not set\");\r\n            }\r\n\r\n            // Create a new storage key and add it to secret storage\r\n            this.logger.info(\"bootstrapSecretStorage: creating new secret storage key\");\r\n            const recoveryKey = await createSecretStorageKey();\r\n            await this.addSecretStorageKeyToSecretStorage(recoveryKey);\r\n        }\r\n\r\n        const crossSigningStatus: RustSdkCryptoJs.CrossSigningStatus = await this.olmMachine.crossSigningStatus();\r\n        const hasPrivateKeys =\r\n            crossSigningStatus.hasMaster && crossSigningStatus.hasSelfSigning && crossSigningStatus.hasUserSigning;\r\n\r\n        // If we have cross-signing private keys cached, store them in secret\r\n        // storage if they are not there already.\r\n        if (\r\n            hasPrivateKeys &&\r\n            (isNewSecretStorageKeyNeeded || !(await secretStorageContainsCrossSigningKeys(this.secretStorage)))\r\n        ) {\r\n            this.logger.info(\"bootstrapSecretStorage: cross-signing keys not yet exported; doing so now.\");\r\n\r\n            const crossSigningPrivateKeys: RustSdkCryptoJs.CrossSigningKeyExport =\r\n                await this.olmMachine.exportCrossSigningKeys();\r\n\r\n            if (!crossSigningPrivateKeys.masterKey) {\r\n                throw new Error(\"missing master key in cross signing private keys\");\r\n            }\r\n\r\n            if (!crossSigningPrivateKeys.userSigningKey) {\r\n                throw new Error(\"missing user signing key in cross signing private keys\");\r\n            }\r\n\r\n            if (!crossSigningPrivateKeys.self_signing_key) {\r\n                throw new Error(\"missing self signing key in cross signing private keys\");\r\n            }\r\n\r\n            await this.secretStorage.store(\"m.cross_signing.master\", crossSigningPrivateKeys.masterKey);\r\n            await this.secretStorage.store(\"m.cross_signing.user_signing\", crossSigningPrivateKeys.userSigningKey);\r\n            await this.secretStorage.store(\"m.cross_signing.self_signing\", crossSigningPrivateKeys.self_signing_key);\r\n        }\r\n\r\n        if (setupNewKeyBackup) {\r\n            await this.resetKeyBackup();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the secretStorage key to the secret storage\r\n     * - The secret storage key must have the `keyInfo` field filled\r\n     * - The secret storage key is set as the default key of the secret storage\r\n     * - Call `cryptoCallbacks.cacheSecretStorageKey` when done\r\n     *\r\n     * @param secretStorageKey - The secret storage key to add in the secret storage.\r\n     */\r\n    private async addSecretStorageKeyToSecretStorage(secretStorageKey: GeneratedSecretStorageKey): Promise<void> {\r\n        const secretStorageKeyObject = await this.secretStorage.addKey(SECRET_STORAGE_ALGORITHM_V1_AES, {\r\n            passphrase: secretStorageKey.keyInfo?.passphrase,\r\n            name: secretStorageKey.keyInfo?.name,\r\n            key: secretStorageKey.privateKey,\r\n        });\r\n\r\n        await this.secretStorage.setDefaultKeyId(secretStorageKeyObject.keyId);\r\n\r\n        this.cryptoCallbacks.cacheSecretStorageKey?.(\r\n            secretStorageKeyObject.keyId,\r\n            secretStorageKeyObject.keyInfo,\r\n            secretStorageKey.privateKey,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check if a secret storage AES Key is already added in secret storage\r\n     *\r\n     * @returns True if an AES key is in the secret storage\r\n     */\r\n    private async secretStorageHasAESKey(): Promise<boolean> {\r\n        // See if we already have an AES secret-storage key.\r\n        const secretStorageKeyTuple = await this.secretStorage.getKey();\r\n\r\n        if (!secretStorageKeyTuple) return false;\r\n\r\n        const [, keyInfo] = secretStorageKeyTuple;\r\n\r\n        // Check if the key is an AES key\r\n        return keyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES;\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#getCrossSigningStatus}\r\n     */\r\n    public async getCrossSigningStatus(): Promise<CrossSigningStatus> {\r\n        const userIdentity: RustSdkCryptoJs.OwnUserIdentity | null = await this.getOlmMachineOrThrow().getIdentity(\r\n            new RustSdkCryptoJs.UserId(this.userId),\r\n        );\r\n\r\n        const publicKeysOnDevice =\r\n            Boolean(userIdentity?.masterKey) &&\r\n            Boolean(userIdentity?.selfSigningKey) &&\r\n            Boolean(userIdentity?.userSigningKey);\r\n        userIdentity?.free();\r\n\r\n        const privateKeysInSecretStorage = await secretStorageContainsCrossSigningKeys(this.secretStorage);\r\n        const crossSigningStatus: RustSdkCryptoJs.CrossSigningStatus | null =\r\n            await this.getOlmMachineOrThrow().crossSigningStatus();\r\n\r\n        return {\r\n            publicKeysOnDevice,\r\n            privateKeysInSecretStorage,\r\n            privateKeysCachedLocally: {\r\n                masterKey: Boolean(crossSigningStatus?.hasMaster),\r\n                userSigningKey: Boolean(crossSigningStatus?.hasUserSigning),\r\n                selfSigningKey: Boolean(crossSigningStatus?.hasSelfSigning),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#createRecoveryKeyFromPassphrase}\r\n     */\r\n    public async createRecoveryKeyFromPassphrase(password?: string): Promise<GeneratedSecretStorageKey> {\r\n        if (password) {\r\n            // Generate the key from the passphrase\r\n            const derivation = await keyFromPassphrase(password);\r\n            return {\r\n                keyInfo: {\r\n                    passphrase: {\r\n                        algorithm: \"m.pbkdf2\",\r\n                        iterations: derivation.iterations,\r\n                        salt: derivation.salt,\r\n                    },\r\n                },\r\n                privateKey: derivation.key,\r\n                encodedPrivateKey: encodeRecoveryKey(derivation.key),\r\n            };\r\n        } else {\r\n            // Using the navigator crypto API to generate the private key\r\n            const key = new Uint8Array(32);\r\n            globalThis.crypto.getRandomValues(key);\r\n            return {\r\n                privateKey: key,\r\n                encodedPrivateKey: encodeRecoveryKey(key),\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link Crypto.CryptoApi.getEncryptionInfoForEvent}.\r\n     */\r\n    public async getEncryptionInfoForEvent(event: MatrixEvent): Promise<EventEncryptionInfo | null> {\r\n        return this.eventDecryptor.getEncryptionInfoForEvent(event);\r\n    }\r\n\r\n    /**\r\n     * Returns to-device verification requests that are already in progress for the given user id.\r\n     *\r\n     * Implementation of {@link CryptoApi#getVerificationRequestsToDeviceInProgress}\r\n     *\r\n     * @param userId - the ID of the user to query\r\n     *\r\n     * @returns the VerificationRequests that are in progress\r\n     */\r\n    public getVerificationRequestsToDeviceInProgress(userId: string): VerificationRequest[] {\r\n        const requests: RustSdkCryptoJs.VerificationRequest[] = this.olmMachine.getVerificationRequests(\r\n            new RustSdkCryptoJs.UserId(userId),\r\n        );\r\n        return requests\r\n            .filter((request) => request.roomId === undefined)\r\n            .map(\r\n                (request) =>\r\n                    new RustVerificationRequest(\r\n                        this.olmMachine,\r\n                        request,\r\n                        this.outgoingRequestProcessor,\r\n                        this._supportedVerificationMethods,\r\n                    ),\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Finds a DM verification request that is already in progress for the given room id\r\n     *\r\n     * Implementation of {@link CryptoApi#findVerificationRequestDMInProgress}\r\n     *\r\n     * @param roomId - the room to use for verification\r\n     * @param userId - search the verification request for the given user\r\n     *\r\n     * @returns the VerificationRequest that is in progress, if any\r\n     *\r\n     */\r\n    public findVerificationRequestDMInProgress(roomId: string, userId?: string): VerificationRequest | undefined {\r\n        if (!userId) throw new Error(\"missing userId\");\r\n\r\n        const requests: RustSdkCryptoJs.VerificationRequest[] = this.olmMachine.getVerificationRequests(\r\n            new RustSdkCryptoJs.UserId(userId),\r\n        );\r\n\r\n        // Search for the verification request for the given room id\r\n        const request = requests.find((request) => request.roomId?.toString() === roomId);\r\n\r\n        if (request) {\r\n            return new RustVerificationRequest(\r\n                this.olmMachine,\r\n                request,\r\n                this.outgoingRequestProcessor,\r\n                this._supportedVerificationMethods,\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#requestVerificationDM}\r\n     */\r\n    public async requestVerificationDM(userId: string, roomId: string): Promise<VerificationRequest> {\r\n        const userIdentity: RustSdkCryptoJs.UserIdentity | undefined = await this.olmMachine.getIdentity(\r\n            new RustSdkCryptoJs.UserId(userId),\r\n        );\r\n\r\n        if (!userIdentity) throw new Error(`unknown userId ${userId}`);\r\n\r\n        try {\r\n            // Transform the verification methods into rust objects\r\n            const methods = this._supportedVerificationMethods.map((method) =>\r\n                verificationMethodIdentifierToMethod(method),\r\n            );\r\n            // Get the request content to send to the DM room\r\n            const verificationEventContent: string = await userIdentity.verificationRequestContent(methods);\r\n\r\n            // Send the request content to send to the DM room\r\n            const eventId = await this.sendVerificationRequestContent(roomId, verificationEventContent);\r\n\r\n            // Get a verification request\r\n            const request: RustSdkCryptoJs.VerificationRequest = await userIdentity.requestVerification(\r\n                new RustSdkCryptoJs.RoomId(roomId),\r\n                new RustSdkCryptoJs.EventId(eventId),\r\n                methods,\r\n            );\r\n            return new RustVerificationRequest(\r\n                this.olmMachine,\r\n                request,\r\n                this.outgoingRequestProcessor,\r\n                this._supportedVerificationMethods,\r\n            );\r\n        } finally {\r\n            userIdentity.free();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send the verification content to a room\r\n     * See https://spec.matrix.org/v1.7/client-server-api/#put_matrixclientv3roomsroomidsendeventtypetxnid\r\n     *\r\n     * Prefer to use {@link OutgoingRequestProcessor.makeOutgoingRequest} when dealing with {@link RustSdkCryptoJs.RoomMessageRequest}\r\n     *\r\n     * @param roomId - the targeted room\r\n     * @param verificationEventContent - the request body.\r\n     *\r\n     * @returns the event id\r\n     */\r\n    private async sendVerificationRequestContent(roomId: string, verificationEventContent: string): Promise<string> {\r\n        const txId = randomString(32);\r\n        // Send the verification request content to the DM room\r\n        const { event_id: eventId } = await this.http.authedRequest<{ event_id: string }>(\r\n            Method.Put,\r\n            `/_matrix/client/v3/rooms/${encodeURIComponent(roomId)}/send/m.room.message/${encodeURIComponent(txId)}`,\r\n            undefined,\r\n            verificationEventContent,\r\n            {\r\n                prefix: \"\",\r\n            },\r\n        );\r\n\r\n        return eventId;\r\n    }\r\n\r\n    /**\r\n     * The verification methods we offer to the other side during an interactive verification.\r\n     */\r\n    private _supportedVerificationMethods: string[] = ALL_VERIFICATION_METHODS;\r\n\r\n    /**\r\n     * Set the verification methods we offer to the other side during an interactive verification.\r\n     *\r\n     * If `undefined`, we will offer all the methods supported by the Rust SDK.\r\n     */\r\n    public setSupportedVerificationMethods(methods: string[] | undefined): void {\r\n        // by default, the Rust SDK does not offer `m.qr_code.scan.v1`, but we do want to offer that.\r\n        this._supportedVerificationMethods = methods ?? ALL_VERIFICATION_METHODS;\r\n    }\r\n\r\n    /**\r\n     * Send a verification request to our other devices.\r\n     *\r\n     * If a verification is already in flight, returns it. Otherwise, initiates a new one.\r\n     *\r\n     * Implementation of {@link CryptoApi#requestOwnUserVerification}.\r\n     *\r\n     * @returns a VerificationRequest when the request has been sent to the other party.\r\n     */\r\n    public async requestOwnUserVerification(): Promise<VerificationRequest> {\r\n        const userIdentity: RustSdkCryptoJs.OwnUserIdentity | undefined = await this.olmMachine.getIdentity(\r\n            new RustSdkCryptoJs.UserId(this.userId),\r\n        );\r\n        if (userIdentity === undefined) {\r\n            throw new Error(\"cannot request verification for this device when there is no existing cross-signing key\");\r\n        }\r\n\r\n        try {\r\n            const [request, outgoingRequest]: [RustSdkCryptoJs.VerificationRequest, RustSdkCryptoJs.ToDeviceRequest] =\r\n                await userIdentity.requestVerification(\r\n                    this._supportedVerificationMethods.map(verificationMethodIdentifierToMethod),\r\n                );\r\n            await this.outgoingRequestProcessor.makeOutgoingRequest(outgoingRequest);\r\n            return new RustVerificationRequest(\r\n                this.olmMachine,\r\n                request,\r\n                this.outgoingRequestProcessor,\r\n                this._supportedVerificationMethods,\r\n            );\r\n        } finally {\r\n            userIdentity.free();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request an interactive verification with the given device.\r\n     *\r\n     * If a verification is already in flight, returns it. Otherwise, initiates a new one.\r\n     *\r\n     * Implementation of {@link CryptoApi#requestDeviceVerification}.\r\n     *\r\n     * @param userId - ID of the owner of the device to verify\r\n     * @param deviceId - ID of the device to verify\r\n     *\r\n     * @returns a VerificationRequest when the request has been sent to the other party.\r\n     */\r\n    public async requestDeviceVerification(userId: string, deviceId: string): Promise<VerificationRequest> {\r\n        const device: RustSdkCryptoJs.Device | undefined = await this.olmMachine.getDevice(\r\n            new RustSdkCryptoJs.UserId(userId),\r\n            new RustSdkCryptoJs.DeviceId(deviceId),\r\n        );\r\n\r\n        if (!device) {\r\n            throw new Error(\"Not a known device\");\r\n        }\r\n\r\n        try {\r\n            const [request, outgoingRequest] = device.requestVerification(\r\n                this._supportedVerificationMethods.map(verificationMethodIdentifierToMethod),\r\n            );\r\n            await this.outgoingRequestProcessor.makeOutgoingRequest(outgoingRequest);\r\n            return new RustVerificationRequest(\r\n                this.olmMachine,\r\n                request,\r\n                this.outgoingRequestProcessor,\r\n                this._supportedVerificationMethods,\r\n            );\r\n        } finally {\r\n            device.free();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetch the backup decryption key we have saved in our store.\r\n     *\r\n     * Implementation of {@link CryptoApi#getSessionBackupPrivateKey}.\r\n     *\r\n     * @returns the key, if any, or null\r\n     */\r\n    public async getSessionBackupPrivateKey(): Promise<Uint8Array | null> {\r\n        const backupKeys: RustSdkCryptoJs.BackupKeys = await this.olmMachine.getBackupKeys();\r\n        if (!backupKeys.decryptionKey) return null;\r\n        return Buffer.from(backupKeys.decryptionKey.toBase64(), \"base64\");\r\n    }\r\n\r\n    /**\r\n     * Store the backup decryption key.\r\n     *\r\n     * Implementation of {@link CryptoApi#storeSessionBackupPrivateKey}.\r\n     *\r\n     * @param key - the backup decryption key\r\n     * @param version - the backup version for this key.\r\n     */\r\n    public async storeSessionBackupPrivateKey(key: Uint8Array, version?: string): Promise<void> {\r\n        const base64Key = encodeBase64(key);\r\n\r\n        if (!version) {\r\n            throw new Error(\"storeSessionBackupPrivateKey: version is required\");\r\n        }\r\n\r\n        await this.backupManager.saveBackupDecryptionKey(\r\n            RustSdkCryptoJs.BackupDecryptionKey.fromBase64(base64Key),\r\n            version,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current status of key backup.\r\n     *\r\n     * Implementation of {@link CryptoApi#getActiveSessionBackupVersion}.\r\n     */\r\n    public async getActiveSessionBackupVersion(): Promise<string | null> {\r\n        return await this.backupManager.getActiveBackupVersion();\r\n    }\r\n\r\n    /**\r\n     * Determine if a key backup can be trusted.\r\n     *\r\n     * Implementation of {@link Crypto.CryptoApi.isKeyBackupTrusted}.\r\n     */\r\n    public async isKeyBackupTrusted(info: KeyBackupInfo): Promise<BackupTrustInfo> {\r\n        return await this.backupManager.isKeyBackupTrusted(info);\r\n    }\r\n\r\n    /**\r\n     * Force a re-check of the key backup and enable/disable it as appropriate.\r\n     *\r\n     * Implementation of {@link Crypto.CryptoApi.checkKeyBackupAndEnable}.\r\n     */\r\n    public async checkKeyBackupAndEnable(): Promise<KeyBackupCheck | null> {\r\n        return await this.backupManager.checkKeyBackupAndEnable(true);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#deleteKeyBackupVersion}.\r\n     */\r\n    public async deleteKeyBackupVersion(version: string): Promise<void> {\r\n        await this.backupManager.deleteKeyBackupVersion(version);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#resetKeyBackup}.\r\n     */\r\n    public async resetKeyBackup(): Promise<void> {\r\n        const backupInfo = await this.backupManager.setupKeyBackup((o) => this.signObject(o));\r\n\r\n        // we want to store the private key in 4S\r\n        // need to check if 4S is set up?\r\n        if (await this.secretStorageHasAESKey()) {\r\n            await this.secretStorage.store(\"m.megolm_backup.v1\", backupInfo.decryptionKey.toBase64());\r\n        }\r\n\r\n        // we can check and start async\r\n        this.checkKeyBackupAndEnable();\r\n    }\r\n\r\n    /**\r\n     * Signs the given object with the current device and current identity (if available).\r\n     * As defined in {@link https://spec.matrix.org/v1.8/appendices/#signing-json | Signing JSON}.\r\n     *\r\n     * Helper for {@link RustCrypto#resetKeyBackup}.\r\n     *\r\n     * @param obj - The object to sign\r\n     */\r\n    private async signObject<T extends ISignableObject & object>(obj: T): Promise<void> {\r\n        const sigs = new Map(Object.entries(obj.signatures || {}));\r\n        const unsigned = obj.unsigned;\r\n\r\n        delete obj.signatures;\r\n        delete obj.unsigned;\r\n\r\n        const userSignatures = sigs.get(this.userId) || {};\r\n\r\n        const canonalizedJson = anotherjson.stringify(obj);\r\n        const signatures: RustSdkCryptoJs.Signatures = await this.olmMachine.sign(canonalizedJson);\r\n\r\n        const map = JSON.parse(signatures.asJSON());\r\n\r\n        sigs.set(this.userId, { ...userSignatures, ...map[this.userId] });\r\n\r\n        if (unsigned !== undefined) obj.unsigned = unsigned;\r\n        obj.signatures = Object.fromEntries(sigs.entries());\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#isDehydrationSupported}.\r\n     */\r\n    public async isDehydrationSupported(): Promise<boolean> {\r\n        return await this.dehydratedDeviceManager.isSupported();\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#startDehydration}.\r\n     */\r\n    public async startDehydration(createNewKey?: boolean): Promise<void> {\r\n        if (!(await this.isCrossSigningReady()) || !(await this.isSecretStorageReady())) {\r\n            throw new Error(\"Device dehydration requires cross-signing and secret storage to be set up\");\r\n        }\r\n        return await this.dehydratedDeviceManager.start(createNewKey);\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#importSecretsBundle}.\r\n     */\r\n    public async importSecretsBundle(\r\n        secrets: Parameters<NonNullable<CryptoApi[\"importSecretsBundle\"]>>[0],\r\n    ): Promise<void> {\r\n        const secretsBundle = RustSdkCryptoJs.SecretsBundle.from_json(secrets);\r\n        await this.getOlmMachineOrThrow().importSecretsBundle(secretsBundle); // this method frees the SecretsBundle\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoApi#exportSecretsBundle}.\r\n     */\r\n    public async exportSecretsBundle(): ReturnType<NonNullable<CryptoApi[\"exportSecretsBundle\"]>> {\r\n        const secretsBundle = await this.getOlmMachineOrThrow().exportSecretsBundle();\r\n        const secrets = secretsBundle.to_json();\r\n        secretsBundle.free();\r\n        return secrets;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // SyncCryptoCallbacks implementation\r\n    //\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /**\r\n     * Apply sync changes to the olm machine\r\n     * @param events - the received to-device messages\r\n     * @param oneTimeKeysCounts - the received one time key counts\r\n     * @param unusedFallbackKeys - the received unused fallback keys\r\n     * @param devices - the received device list updates\r\n     * @returns A list of preprocessed to-device messages.\r\n     */\r\n    private async receiveSyncChanges({\r\n        events,\r\n        oneTimeKeysCounts = new Map<string, number>(),\r\n        unusedFallbackKeys,\r\n        devices = new RustSdkCryptoJs.DeviceLists(),\r\n    }: {\r\n        events?: IToDeviceEvent[];\r\n        oneTimeKeysCounts?: Map<string, number>;\r\n        unusedFallbackKeys?: Set<string>;\r\n        devices?: RustSdkCryptoJs.DeviceLists;\r\n    }): Promise<IToDeviceEvent[]> {\r\n        const result = await logDuration(logger, \"receiveSyncChanges\", async () => {\r\n            return await this.olmMachine.receiveSyncChanges(\r\n                events ? JSON.stringify(events) : \"[]\",\r\n                devices,\r\n                oneTimeKeysCounts,\r\n                unusedFallbackKeys,\r\n            );\r\n        });\r\n\r\n        // receiveSyncChanges returns a JSON-encoded list of decrypted to-device messages.\r\n        return JSON.parse(result);\r\n    }\r\n\r\n    /** called by the sync loop to preprocess incoming to-device messages\r\n     *\r\n     * @param events - the received to-device messages\r\n     * @returns A list of preprocessed to-device messages.\r\n     */\r\n    public async preprocessToDeviceMessages(events: IToDeviceEvent[]): Promise<IToDeviceEvent[]> {\r\n        // send the received to-device messages into receiveSyncChanges. We have no info on device-list changes,\r\n        // one-time-keys, or fallback keys, so just pass empty data.\r\n        const processed = await this.receiveSyncChanges({ events });\r\n\r\n        // look for interesting to-device messages\r\n        for (const message of processed) {\r\n            if (message.type === EventType.KeyVerificationRequest) {\r\n                const sender = message.sender;\r\n                const transactionId = message.content.transaction_id;\r\n                if (transactionId && sender) {\r\n                    this.onIncomingKeyVerificationRequest(sender, transactionId);\r\n                }\r\n            }\r\n        }\r\n        return processed;\r\n    }\r\n\r\n    /** called by the sync loop to process one time key counts and unused fallback keys\r\n     *\r\n     * @param oneTimeKeysCounts - the received one time key counts\r\n     * @param unusedFallbackKeys - the received unused fallback keys\r\n     */\r\n    public async processKeyCounts(\r\n        oneTimeKeysCounts?: Record<string, number>,\r\n        unusedFallbackKeys?: string[],\r\n    ): Promise<void> {\r\n        const mapOneTimeKeysCount = oneTimeKeysCounts && new Map<string, number>(Object.entries(oneTimeKeysCounts));\r\n        const setUnusedFallbackKeys = unusedFallbackKeys && new Set<string>(unusedFallbackKeys);\r\n\r\n        if (mapOneTimeKeysCount !== undefined || setUnusedFallbackKeys !== undefined) {\r\n            await this.receiveSyncChanges({\r\n                oneTimeKeysCounts: mapOneTimeKeysCount,\r\n                unusedFallbackKeys: setUnusedFallbackKeys,\r\n            });\r\n        }\r\n    }\r\n\r\n    /** called by the sync loop to process the notification that device lists have\r\n     * been changed.\r\n     *\r\n     * @param deviceLists - device_lists field from /sync\r\n     */\r\n    public async processDeviceLists(deviceLists: IDeviceLists): Promise<void> {\r\n        const devices = new RustSdkCryptoJs.DeviceLists(\r\n            deviceLists.changed?.map((userId) => new RustSdkCryptoJs.UserId(userId)),\r\n            deviceLists.left?.map((userId) => new RustSdkCryptoJs.UserId(userId)),\r\n        );\r\n        await this.receiveSyncChanges({ devices });\r\n    }\r\n\r\n    /** called by the sync loop on m.room.encrypted events\r\n     *\r\n     * @param room - in which the event was received\r\n     * @param event - encryption event to be processed\r\n     */\r\n    public async onCryptoEvent(room: Room, event: MatrixEvent): Promise<void> {\r\n        const config = event.getContent();\r\n        const settings = new RustSdkCryptoJs.RoomSettings();\r\n\r\n        if (config.algorithm === \"m.megolm.v1.aes-sha2\") {\r\n            settings.algorithm = RustSdkCryptoJs.EncryptionAlgorithm.MegolmV1AesSha2;\r\n        } else {\r\n            // Among other situations, this happens if the crypto state event is redacted.\r\n            this.logger.warn(`Room ${room.roomId}: ignoring crypto event with invalid algorithm ${config.algorithm}`);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            settings.sessionRotationPeriodMs = config.rotation_period_ms;\r\n            settings.sessionRotationPeriodMessages = config.rotation_period_msgs;\r\n            await this.olmMachine.setRoomSettings(new RustSdkCryptoJs.RoomId(room.roomId), settings);\r\n        } catch (e) {\r\n            this.logger.warn(`Room ${room.roomId}: ignoring crypto event which caused error: ${e}`);\r\n            return;\r\n        }\r\n\r\n        // If we got this far, the SDK found the event acceptable.\r\n        // We need to either create or update the active RoomEncryptor.\r\n        const existingEncryptor = this.roomEncryptors[room.roomId];\r\n        if (existingEncryptor) {\r\n            existingEncryptor.onCryptoEvent(config);\r\n        } else {\r\n            this.roomEncryptors[room.roomId] = new RoomEncryptor(\r\n                this.olmMachine,\r\n                this.keyClaimManager,\r\n                this.outgoingRequestsManager,\r\n                room,\r\n                config,\r\n            );\r\n        }\r\n    }\r\n\r\n    /** called by the sync loop after processing each sync.\r\n     *\r\n     * TODO: figure out something equivalent for sliding sync.\r\n     *\r\n     * @param syncState - information on the completed sync.\r\n     */\r\n    public onSyncCompleted(syncState: OnSyncCompletedData): void {\r\n        // Processing the /sync may have produced new outgoing requests which need sending, so kick off the outgoing\r\n        // request loop, if it's not already running.\r\n        this.outgoingRequestsManager.doProcessOutgoingRequests().catch((e) => {\r\n            this.logger.warn(\"onSyncCompleted: Error processing outgoing requests\", e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle an incoming m.key.verification.request event, received either in-room or in a to-device message.\r\n     *\r\n     * @param sender - the sender of the event\r\n     * @param transactionId - the transaction ID for the verification. For to-device messages, this comes from the\r\n     *    content of the message; for in-room messages it is the event ID.\r\n     */\r\n    private onIncomingKeyVerificationRequest(sender: string, transactionId: string): void {\r\n        const request: RustSdkCryptoJs.VerificationRequest | undefined = this.olmMachine.getVerificationRequest(\r\n            new RustSdkCryptoJs.UserId(sender),\r\n            transactionId,\r\n        );\r\n\r\n        if (request) {\r\n            this.emit(\r\n                CryptoEvent.VerificationRequestReceived,\r\n                new RustVerificationRequest(\r\n                    this.olmMachine,\r\n                    request,\r\n                    this.outgoingRequestProcessor,\r\n                    this._supportedVerificationMethods,\r\n                ),\r\n            );\r\n        } else {\r\n            // There are multiple reasons this can happen; probably the most likely is that the event is an\r\n            // in-room event which is too old.\r\n            this.logger.info(\r\n                `Ignoring just-received verification request ${transactionId} which did not start a rust-side verification`,\r\n            );\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //\r\n    // Other public functions\r\n    //\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /** called by the MatrixClient on a room membership event\r\n     *\r\n     * @param event - The matrix event which caused this event to fire.\r\n     * @param member - The member whose RoomMember.membership changed.\r\n     * @param oldMembership - The previous membership state. Null if it's a new member.\r\n     */\r\n    public onRoomMembership(event: MatrixEvent, member: RoomMember, oldMembership?: string): void {\r\n        const enc = this.roomEncryptors[event.getRoomId()!];\r\n        if (!enc) {\r\n            // not encrypting in this room\r\n            return;\r\n        }\r\n        enc.onRoomMembership(member);\r\n    }\r\n\r\n    /** Callback for OlmMachine.registerRoomKeyUpdatedCallback\r\n     *\r\n     * Called by the rust-sdk whenever there is an update to (megolm) room keys. We\r\n     * check if we have any events waiting for the given keys, and schedule them for\r\n     * a decryption retry if so.\r\n     *\r\n     * @param keys - details of the updated keys\r\n     */\r\n    public async onRoomKeysUpdated(keys: RustSdkCryptoJs.RoomKeyInfo[]): Promise<void> {\r\n        for (const key of keys) {\r\n            this.onRoomKeyUpdated(key);\r\n        }\r\n        this.backupManager.maybeUploadKey();\r\n    }\r\n\r\n    private onRoomKeyUpdated(key: RustSdkCryptoJs.RoomKeyInfo): void {\r\n        if (this.stopped) return;\r\n        this.logger.debug(\r\n            `Got update for session ${key.senderKey.toBase64()}|${key.sessionId} in ${key.roomId.toString()}`,\r\n        );\r\n        const pendingList = this.eventDecryptor.getEventsPendingRoomKey(key.roomId.toString(), key.sessionId);\r\n        if (pendingList.length === 0) return;\r\n\r\n        this.logger.debug(\r\n            \"Retrying decryption on events:\",\r\n            pendingList.map((e) => `${e.getId()}`),\r\n        );\r\n\r\n        // Have another go at decrypting events with this key.\r\n        //\r\n        // We don't want to end up blocking the callback from Rust, which could otherwise end up dropping updates,\r\n        // so we don't wait for the decryption to complete. In any case, there is no need to wait:\r\n        // MatrixEvent.attemptDecryption ensures that there is only one decryption attempt happening at once,\r\n        // and deduplicates repeated attempts for the same event.\r\n        for (const ev of pendingList) {\r\n            ev.attemptDecryption(this, { isRetry: true }).catch((_e) => {\r\n                this.logger.info(`Still unable to decrypt event ${ev.getId()} after receiving key`);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback for `OlmMachine.registerRoomKeyWithheldCallback`.\r\n     *\r\n     * Called by the rust sdk whenever we are told that a key has been withheld. We see if we had any events that\r\n     * failed to decrypt for the given session, and update their status if so.\r\n     *\r\n     * @param withheld - Details of the withheld sessions.\r\n     */\r\n    public async onRoomKeysWithheld(withheld: RustSdkCryptoJs.RoomKeyWithheldInfo[]): Promise<void> {\r\n        for (const session of withheld) {\r\n            this.logger.debug(`Got withheld message for session ${session.sessionId} in ${session.roomId.toString()}`);\r\n            const pendingList = this.eventDecryptor.getEventsPendingRoomKey(\r\n                session.roomId.toString(),\r\n                session.sessionId,\r\n            );\r\n            if (pendingList.length === 0) return;\r\n\r\n            // The easiest way to update the status of the event is to have another go at decrypting it.\r\n            this.logger.debug(\r\n                \"Retrying decryption on events:\",\r\n                pendingList.map((e) => `${e.getId()}`),\r\n            );\r\n\r\n            for (const ev of pendingList) {\r\n                ev.attemptDecryption(this, { isRetry: true }).catch((_e) => {\r\n                    // It's somewhat expected that we still can't decrypt here.\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback for `OlmMachine.registerUserIdentityUpdatedCallback`\r\n     *\r\n     * Called by the rust-sdk whenever there is an update to any user's cross-signing status. We re-check their trust\r\n     * status and emit a `UserTrustStatusChanged` event, as well as a `KeysChanged` if it is our own identity that changed.\r\n     *\r\n     * @param userId - the user with the updated identity\r\n     */\r\n    public async onUserIdentityUpdated(userId: RustSdkCryptoJs.UserId): Promise<void> {\r\n        const newVerification = await this.getUserVerificationStatus(userId.toString());\r\n        this.emit(CryptoEvent.UserTrustStatusChanged, userId.toString(), newVerification);\r\n\r\n        // If our own user identity has changed, we may now trust the key backup where we did not before.\r\n        // So, re-check the key backup status and enable it if available.\r\n        if (userId.toString() === this.userId) {\r\n            this.emit(CryptoEvent.KeysChanged, {});\r\n            await this.checkKeyBackupAndEnable();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback for `OlmMachine.registerDevicesUpdatedCallback`\r\n     *\r\n     * Called when users' devices have updated. Emits `WillUpdateDevices` and `DevicesUpdated`. In the JavaScript\r\n     * crypto backend, these events are called at separate times, with `WillUpdateDevices` being emitted just before\r\n     * the devices are saved, and `DevicesUpdated` being emitted just after. But the OlmMachine only gives us\r\n     * one event, so we emit both events here.\r\n     *\r\n     * @param userIds - an array of user IDs of users whose devices have updated.\r\n     */\r\n    public async onDevicesUpdated(userIds: string[]): Promise<void> {\r\n        this.emit(CryptoEvent.WillUpdateDevices, userIds, false);\r\n        this.emit(CryptoEvent.DevicesUpdated, userIds, false);\r\n    }\r\n\r\n    /**\r\n     * Handles secret received from the rust secret inbox.\r\n     *\r\n     * The gossipped secrets are received using the `m.secret.send` event type\r\n     * and are guaranteed to have been received over a 1-to-1 Olm\r\n     * Session from a verified device.\r\n     *\r\n     * The only secret currently handled in this way is `m.megolm_backup.v1`.\r\n     *\r\n     * @param name - the secret name\r\n     * @param value - the secret value\r\n     */\r\n    private async handleSecretReceived(name: string, value: string): Promise<boolean> {\r\n        this.logger.debug(`onReceiveSecret: Received secret ${name}`);\r\n        if (name === \"m.megolm_backup.v1\") {\r\n            return await this.backupManager.handleBackupSecretReceived(value);\r\n            // XXX at this point we should probably try to download the backup and import the keys,\r\n            // or at least retry for the current decryption failures?\r\n            // Maybe add some signaling when a new secret is received, and let clients handle it?\r\n            // as it's where the restore from backup APIs are exposed.\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when a new secret is received in the rust secret inbox.\r\n     *\r\n     * Will poll the secret inbox and handle the secrets received.\r\n     *\r\n     * @param name - The name of the secret received.\r\n     */\r\n    public async checkSecrets(name: string): Promise<void> {\r\n        const pendingValues: string[] = await this.olmMachine.getSecretsFromInbox(name);\r\n        for (const value of pendingValues) {\r\n            if (await this.handleSecretReceived(name, value)) {\r\n                // If we have a valid secret for that name there is no point of processing the other secrets values.\r\n                // It's probably the same secret shared by another device.\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Important to call this after handling the secrets as good hygiene.\r\n        await this.olmMachine.deleteSecretsFromInbox(name);\r\n    }\r\n\r\n    /**\r\n     * Handle a live event received via /sync.\r\n     * See {@link ClientEventHandlerMap#event}\r\n     *\r\n     * @param event - live event\r\n     */\r\n    public async onLiveEventFromSync(event: MatrixEvent): Promise<void> {\r\n        // Ignore state event or remote echo\r\n        // transaction_id is provided in case of remote echo {@link https://spec.matrix.org/v1.7/client-server-api/#local-echo}\r\n        if (event.isState() || !!event.getUnsigned().transaction_id) return;\r\n\r\n        const processEvent = async (evt: MatrixEvent): Promise<void> => {\r\n            // Process only verification event\r\n            if (isVerificationEvent(event)) {\r\n                await this.onKeyVerificationEvent(evt);\r\n            }\r\n        };\r\n\r\n        // If the event is encrypted of in failure, we wait for decryption\r\n        if (event.isDecryptionFailure() || event.isEncrypted()) {\r\n            // 5 mins\r\n            const TIMEOUT_DELAY = 5 * 60 * 1000;\r\n\r\n            // After 5mins, we are not expecting the event to be decrypted\r\n            const timeoutId = setTimeout(() => event.off(MatrixEventEvent.Decrypted, onDecrypted), TIMEOUT_DELAY);\r\n\r\n            const onDecrypted = (decryptedEvent: MatrixEvent, error?: Error): void => {\r\n                if (error) return;\r\n\r\n                clearTimeout(timeoutId);\r\n                event.off(MatrixEventEvent.Decrypted, onDecrypted);\r\n                processEvent(decryptedEvent);\r\n            };\r\n\r\n            event.on(MatrixEventEvent.Decrypted, onDecrypted);\r\n        } else {\r\n            await processEvent(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle an in-room key verification event.\r\n     *\r\n     * @param event - a key validation request event.\r\n     */\r\n    private async onKeyVerificationEvent(event: MatrixEvent): Promise<void> {\r\n        const roomId = event.getRoomId();\r\n\r\n        if (!roomId) {\r\n            throw new Error(\"missing roomId in the event\");\r\n        }\r\n\r\n        this.logger.debug(\r\n            `Incoming verification event ${event.getId()} type ${event.getType()} from ${event.getSender()}`,\r\n        );\r\n\r\n        await this.olmMachine.receiveVerificationEvent(\r\n            JSON.stringify({\r\n                event_id: event.getId(),\r\n                type: event.getType(),\r\n                sender: event.getSender(),\r\n                state_key: event.getStateKey(),\r\n                content: event.getContent(),\r\n                origin_server_ts: event.getTs(),\r\n            }),\r\n            new RustSdkCryptoJs.RoomId(roomId),\r\n        );\r\n\r\n        if (\r\n            event.getType() === EventType.RoomMessage &&\r\n            event.getContent().msgtype === MsgType.KeyVerificationRequest\r\n        ) {\r\n            this.onIncomingKeyVerificationRequest(event.getSender()!, event.getId()!);\r\n        }\r\n\r\n        // that may have caused us to queue up outgoing requests, so make sure we send them.\r\n        this.outgoingRequestsManager.doProcessOutgoingRequests().catch((e) => {\r\n            this.logger.warn(\"onKeyVerificationRequest: Error processing outgoing requests\", e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the cross-signing user identity of the current user.\r\n     *\r\n     * Not part of the public crypto-api interface.\r\n     * Used during migration from legacy js-crypto to update local trust if needed.\r\n     */\r\n    public async getOwnIdentity(): Promise<RustSdkCryptoJs.OwnUserIdentity | undefined> {\r\n        return await this.olmMachine.getIdentity(new RustSdkCryptoJs.UserId(this.userId));\r\n    }\r\n}\r\n\r\nclass EventDecryptor {\r\n    /**\r\n     * Events which we couldn't decrypt due to unknown sessions / indexes.\r\n     *\r\n     * Map from roomId to sessionId to Set of MatrixEvents\r\n     */\r\n    private eventsPendingKey = new MapWithDefault<string, MapWithDefault<string, Set<MatrixEvent>>>(\r\n        () => new MapWithDefault<string, Set<MatrixEvent>>(() => new Set()),\r\n    );\r\n\r\n    public constructor(\r\n        private readonly logger: Logger,\r\n        private readonly olmMachine: RustSdkCryptoJs.OlmMachine,\r\n        private readonly perSessionBackupDownloader: PerSessionKeyBackupDownloader,\r\n    ) {}\r\n\r\n    public async attemptEventDecryption(event: MatrixEvent): Promise<IEventDecryptionResult> {\r\n        // add the event to the pending list *before* attempting to decrypt.\r\n        // then, if the key turns up while decryption is in progress (and\r\n        // decryption fails), we will schedule a retry.\r\n        // (fixes https://github.com/vector-im/element-web/issues/5001)\r\n        this.addEventToPendingList(event);\r\n\r\n        try {\r\n            const res = (await this.olmMachine.decryptRoomEvent(\r\n                stringifyEvent(event),\r\n                new RustSdkCryptoJs.RoomId(event.getRoomId()!),\r\n            )) as RustSdkCryptoJs.DecryptedRoomEvent;\r\n\r\n            // Success. We can remove the event from the pending list, if\r\n            // that hasn't already happened.\r\n            this.removeEventFromPendingList(event);\r\n\r\n            return {\r\n                clearEvent: JSON.parse(res.event),\r\n                claimedEd25519Key: res.senderClaimedEd25519Key,\r\n                senderCurve25519Key: res.senderCurve25519Key,\r\n                forwardingCurve25519KeyChain: res.forwardingCurve25519KeyChain,\r\n            };\r\n        } catch (err) {\r\n            if (err instanceof RustSdkCryptoJs.MegolmDecryptionError) {\r\n                this.onMegolmDecryptionError(event, err, await this.perSessionBackupDownloader.getServerBackupInfo());\r\n            } else {\r\n                throw new DecryptionError(DecryptionFailureCode.UNKNOWN_ERROR, \"Unknown error\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle a `MegolmDecryptionError` returned by the rust SDK.\r\n     *\r\n     * Fires off a request to the `perSessionBackupDownloader`, if appropriate, and then throws a `DecryptionError`.\r\n     *\r\n     * @param event - The event which could not be decrypted.\r\n     * @param err - The error from the Rust SDK.\r\n     * @param serverBackupInfo - Details about the current backup from the server. `null` if there is no backup.\r\n     *     `undefined` if our attempt to check failed.\r\n     */\r\n    private onMegolmDecryptionError(\r\n        event: MatrixEvent,\r\n        err: RustSdkCryptoJs.MegolmDecryptionError,\r\n        serverBackupInfo: KeyBackupInfo | null | undefined,\r\n    ): never {\r\n        const content = event.getWireContent();\r\n        const errorDetails = { session: content.sender_key + \"|\" + content.session_id };\r\n\r\n        // If the error looks like it might be recoverable from backup, queue up a request to try that.\r\n        if (\r\n            err.code === RustSdkCryptoJs.DecryptionErrorCode.MissingRoomKey ||\r\n            err.code === RustSdkCryptoJs.DecryptionErrorCode.UnknownMessageIndex\r\n        ) {\r\n            this.perSessionBackupDownloader.onDecryptionKeyMissingError(event.getRoomId()!, content.session_id!);\r\n\r\n            // If the server is telling us our membership at the time the event\r\n            // was sent, and it isn't \"join\", we use a different error code.\r\n            const membership = event.getMembershipAtEvent();\r\n            if (membership && membership !== KnownMembership.Join && membership !== KnownMembership.Invite) {\r\n                throw new DecryptionError(\r\n                    DecryptionFailureCode.HISTORICAL_MESSAGE_USER_NOT_JOINED,\r\n                    \"This message was sent when we were not a member of the room.\",\r\n                    errorDetails,\r\n                );\r\n            }\r\n\r\n            // If the event was sent before this device was created, we use some different error codes.\r\n            if (event.getTs() <= this.olmMachine.deviceCreationTimeMs) {\r\n                if (serverBackupInfo === null) {\r\n                    throw new DecryptionError(\r\n                        DecryptionFailureCode.HISTORICAL_MESSAGE_NO_KEY_BACKUP,\r\n                        \"This message was sent before this device logged in, and there is no key backup on the server.\",\r\n                        errorDetails,\r\n                    );\r\n                } else if (!this.perSessionBackupDownloader.isKeyBackupDownloadConfigured()) {\r\n                    throw new DecryptionError(\r\n                        DecryptionFailureCode.HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED,\r\n                        \"This message was sent before this device logged in, and key backup is not working.\",\r\n                        errorDetails,\r\n                    );\r\n                } else {\r\n                    throw new DecryptionError(\r\n                        DecryptionFailureCode.HISTORICAL_MESSAGE_WORKING_BACKUP,\r\n                        \"This message was sent before this device logged in. Key backup is working, but we still do not (yet) have the key.\",\r\n                        errorDetails,\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        // If we got a withheld code, expose that.\r\n        if (err.maybe_withheld) {\r\n            // Unfortunately the Rust SDK API doesn't let us distinguish between different withheld cases, other than\r\n            // by string-matching.\r\n            const failureCode =\r\n                err.maybe_withheld === \"The sender has disabled encrypting to unverified devices.\"\r\n                    ? DecryptionFailureCode.MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE\r\n                    : DecryptionFailureCode.MEGOLM_KEY_WITHHELD;\r\n            throw new DecryptionError(failureCode, err.maybe_withheld, errorDetails);\r\n        }\r\n\r\n        switch (err.code) {\r\n            case RustSdkCryptoJs.DecryptionErrorCode.MissingRoomKey:\r\n                throw new DecryptionError(\r\n                    DecryptionFailureCode.MEGOLM_UNKNOWN_INBOUND_SESSION_ID,\r\n                    \"The sender's device has not sent us the keys for this message.\",\r\n                    errorDetails,\r\n                );\r\n\r\n            case RustSdkCryptoJs.DecryptionErrorCode.UnknownMessageIndex:\r\n                throw new DecryptionError(\r\n                    DecryptionFailureCode.OLM_UNKNOWN_MESSAGE_INDEX,\r\n                    \"The sender's device has not sent us the keys for this message at this index.\",\r\n                    errorDetails,\r\n                );\r\n\r\n            // We don't map MismatchedIdentityKeys for now, as there is no equivalent in legacy.\r\n            // Just put it on the `UNKNOWN_ERROR` bucket.\r\n            default:\r\n                throw new DecryptionError(DecryptionFailureCode.UNKNOWN_ERROR, err.description, errorDetails);\r\n        }\r\n    }\r\n\r\n    public async getEncryptionInfoForEvent(event: MatrixEvent): Promise<EventEncryptionInfo | null> {\r\n        if (!event.getClearContent() || event.isDecryptionFailure()) {\r\n            // not successfully decrypted\r\n            return null;\r\n        }\r\n\r\n        // special-case outgoing events, which the rust crypto-sdk will barf on\r\n        if (event.status !== null) {\r\n            return { shieldColour: EventShieldColour.NONE, shieldReason: null };\r\n        }\r\n\r\n        const encryptionInfo = await this.olmMachine.getRoomEventEncryptionInfo(\r\n            stringifyEvent(event),\r\n            new RustSdkCryptoJs.RoomId(event.getRoomId()!),\r\n        );\r\n\r\n        return rustEncryptionInfoToJsEncryptionInfo(this.logger, encryptionInfo);\r\n    }\r\n\r\n    /**\r\n     * Look for events which are waiting for a given megolm session\r\n     *\r\n     * Returns a list of events which were encrypted by `session` and could not be decrypted\r\n     */\r\n    public getEventsPendingRoomKey(roomId: string, sessionId: string): MatrixEvent[] {\r\n        const roomPendingEvents = this.eventsPendingKey.get(roomId);\r\n        if (!roomPendingEvents) return [];\r\n\r\n        const sessionPendingEvents = roomPendingEvents.get(sessionId);\r\n        if (!sessionPendingEvents) return [];\r\n\r\n        return [...sessionPendingEvents];\r\n    }\r\n\r\n    /**\r\n     * Add an event to the list of those awaiting their session keys.\r\n     */\r\n    private addEventToPendingList(event: MatrixEvent): void {\r\n        const roomId = event.getRoomId();\r\n        // We shouldn't have events without a room id here.\r\n        if (!roomId) return;\r\n\r\n        const roomPendingEvents = this.eventsPendingKey.getOrCreate(roomId);\r\n        const sessionPendingEvents = roomPendingEvents.getOrCreate(event.getWireContent().session_id);\r\n        sessionPendingEvents.add(event);\r\n    }\r\n\r\n    /**\r\n     * Remove an event from the list of those awaiting their session keys.\r\n     */\r\n    private removeEventFromPendingList(event: MatrixEvent): void {\r\n        const roomId = event.getRoomId();\r\n        if (!roomId) return;\r\n\r\n        const roomPendingEvents = this.eventsPendingKey.getOrCreate(roomId);\r\n        if (!roomPendingEvents) return;\r\n\r\n        const sessionPendingEvents = roomPendingEvents.get(event.getWireContent().session_id);\r\n        if (!sessionPendingEvents) return;\r\n\r\n        sessionPendingEvents.delete(event);\r\n\r\n        // also clean up the higher-level maps if they are now empty\r\n        if (sessionPendingEvents.size === 0) {\r\n            roomPendingEvents.delete(event.getWireContent().session_id);\r\n            if (roomPendingEvents.size === 0) {\r\n                this.eventsPendingKey.delete(roomId);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction stringifyEvent(event: MatrixEvent): string {\r\n    return JSON.stringify({\r\n        event_id: event.getId(),\r\n        type: event.getWireType(),\r\n        sender: event.getSender(),\r\n        state_key: event.getStateKey(),\r\n        content: event.getWireContent(),\r\n        origin_server_ts: event.getTs(),\r\n    });\r\n}\r\n\r\nfunction rustEncryptionInfoToJsEncryptionInfo(\r\n    logger: Logger,\r\n    encryptionInfo: RustSdkCryptoJs.EncryptionInfo | undefined,\r\n): EventEncryptionInfo | null {\r\n    if (encryptionInfo === undefined) {\r\n        // not decrypted here\r\n        return null;\r\n    }\r\n\r\n    // TODO: use strict shield semantics.\r\n    const shieldState = encryptionInfo.shieldState(false);\r\n\r\n    let shieldColour: EventShieldColour;\r\n    switch (shieldState.color) {\r\n        case RustSdkCryptoJs.ShieldColor.Grey:\r\n            shieldColour = EventShieldColour.GREY;\r\n            break;\r\n        case RustSdkCryptoJs.ShieldColor.None:\r\n            shieldColour = EventShieldColour.NONE;\r\n            break;\r\n        default:\r\n            shieldColour = EventShieldColour.RED;\r\n    }\r\n\r\n    let shieldReason: EventShieldReason | null;\r\n    if (shieldState.message === undefined) {\r\n        shieldReason = null;\r\n    } else if (shieldState.message === \"Encrypted by an unverified user.\") {\r\n        // this case isn't actually used with lax shield semantics.\r\n        shieldReason = EventShieldReason.UNVERIFIED_IDENTITY;\r\n    } else if (shieldState.message === \"Encrypted by a device not verified by its owner.\") {\r\n        shieldReason = EventShieldReason.UNSIGNED_DEVICE;\r\n    } else if (\r\n        shieldState.message === \"The authenticity of this encrypted message can't be guaranteed on this device.\"\r\n    ) {\r\n        shieldReason = EventShieldReason.AUTHENTICITY_NOT_GUARANTEED;\r\n    } else if (shieldState.message === \"Encrypted by an unknown or deleted device.\") {\r\n        shieldReason = EventShieldReason.UNKNOWN_DEVICE;\r\n    } else {\r\n        logger.warn(`Unknown shield state message '${shieldState.message}'`);\r\n        shieldReason = EventShieldReason.UNKNOWN;\r\n    }\r\n\r\n    return { shieldColour, shieldReason };\r\n}\r\n\r\ntype RustCryptoEvents =\r\n    | CryptoEvent.VerificationRequestReceived\r\n    | CryptoEvent.UserTrustStatusChanged\r\n    | CryptoEvent.KeysChanged\r\n    | CryptoEvent.WillUpdateDevices\r\n    | CryptoEvent.DevicesUpdated\r\n    | RustBackupCryptoEvents;\r\n\r\ntype RustCryptoEventMap = {\r\n    /**\r\n     * Fires when a key verification request is received.\r\n     */\r\n    [CryptoEvent.VerificationRequestReceived]: (request: VerificationRequest) => void;\r\n\r\n    /**\r\n     * Fires when the trust status of a user changes.\r\n     */\r\n    [CryptoEvent.UserTrustStatusChanged]: (userId: string, userTrustLevel: UserVerificationStatus) => void;\r\n\r\n    [CryptoEvent.KeyBackupDecryptionKeyCached]: (version: string) => void;\r\n    /**\r\n     * Fires when the user's cross-signing keys have changed or cross-signing\r\n     * has been enabled/disabled. The client can use getStoredCrossSigningForUser\r\n     * with the user ID of the logged in user to check if cross-signing is\r\n     * enabled on the account. If enabled, it can test whether the current key\r\n     * is trusted using with checkUserTrust with the user ID of the logged\r\n     * in user. The checkOwnCrossSigningTrust function may be used to reconcile\r\n     * the trust in the account key.\r\n     *\r\n     * The cross-signing API is currently UNSTABLE and may change without notice.\r\n     * @experimental\r\n     */\r\n    [CryptoEvent.KeysChanged]: (data: {}) => void;\r\n    /**\r\n     * Fires whenever the stored devices for a user will be updated\r\n     * @param users - A list of user IDs that will be updated\r\n     * @param initialFetch - If true, the store is empty (apart\r\n     *     from our own device) and is being seeded.\r\n     */\r\n    [CryptoEvent.WillUpdateDevices]: (users: string[], initialFetch: boolean) => void;\r\n    /**\r\n     * Fires whenever the stored devices for a user have changed\r\n     * @param users - A list of user IDs that were updated\r\n     * @param initialFetch - If true, the store was empty (apart\r\n     *     from our own device) and has been seeded.\r\n     */\r\n    [CryptoEvent.DevicesUpdated]: (users: string[], initialFetch: boolean) => void;\r\n} & RustBackupCryptoEventMap;\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { OlmMachine, SignatureVerification } from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport {\r\n    BackupTrustInfo,\r\n    Curve25519AuthData,\r\n    KeyBackupCheck,\r\n    KeyBackupInfo,\r\n    KeyBackupSession,\r\n    Curve25519SessionData,\r\n} from \"../crypto-api/keybackup\";\r\nimport { logger } from \"../logger\";\r\nimport { ClientPrefix, IHttpOpts, MatrixError, MatrixHttpApi, Method } from \"../http-api\";\r\nimport { CryptoEvent, IMegolmSessionData } from \"../crypto\";\r\nimport { TypedEventEmitter } from \"../models/typed-event-emitter\";\r\nimport { encodeUri, logDuration } from \"../utils\";\r\nimport { OutgoingRequestProcessor } from \"./OutgoingRequestProcessor\";\r\nimport { sleep } from \"../utils\";\r\nimport { BackupDecryptor } from \"../common-crypto/CryptoBackend\";\r\nimport { IEncryptedPayload } from \"../crypto/aes\";\r\nimport { ImportRoomKeyProgressData, ImportRoomKeysOpts } from \"../crypto-api\";\r\nimport { IKeyBackupInfo } from \"../crypto/keybackup\";\r\nimport { IKeyBackup } from \"../crypto/backup\";\r\n\r\n/** Authentification of the backup info, depends on algorithm */\r\ntype AuthData = KeyBackupInfo[\"auth_data\"];\r\n\r\n/**\r\n * Holds information of a created keybackup.\r\n * Useful to get the generated private key material and save it securely somewhere.\r\n */\r\ninterface KeyBackupCreationInfo {\r\n    version: string;\r\n    algorithm: string;\r\n    authData: AuthData;\r\n    decryptionKey: RustSdkCryptoJs.BackupDecryptionKey;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class RustBackupManager extends TypedEventEmitter<RustBackupCryptoEvents, RustBackupCryptoEventMap> {\r\n    /** Have we checked if there is a backup on the server which we can use */\r\n    private checkedForBackup = false;\r\n\r\n    /**\r\n     * The latest backup version on the server, when we last checked.\r\n     *\r\n     * If there was no backup on the server, `null`. If our attempt to check resulted in an error, `undefined`.\r\n     *\r\n     * Note that the backup was not necessarily verified.\r\n     */\r\n    private serverBackupInfo: KeyBackupInfo | null | undefined = undefined;\r\n\r\n    private activeBackupVersion: string | null = null;\r\n    private stopped = false;\r\n\r\n    /** whether {@link backupKeysLoop} is currently running */\r\n    private backupKeysLoopRunning = false;\r\n\r\n    public constructor(\r\n        private readonly olmMachine: OlmMachine,\r\n        private readonly http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\r\n        private readonly outgoingRequestProcessor: OutgoingRequestProcessor,\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Tells the RustBackupManager to stop.\r\n     * The RustBackupManager is scheduling background uploads of keys to the backup, this\r\n     * call allows to cancel the process when the client is stoppped.\r\n     */\r\n    public stop(): void {\r\n        this.stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Get the backup version we are currently backing up to, if any\r\n     */\r\n    public async getActiveBackupVersion(): Promise<string | null> {\r\n        if (!(await this.olmMachine.isBackupEnabled())) return null;\r\n        return this.activeBackupVersion;\r\n    }\r\n\r\n    /**\r\n     * Return the details of the latest backup on the server, when we last checked.\r\n     *\r\n     * This normally returns a cached value, but if we haven't yet made a request to the server, it will fire one off.\r\n     * It will always return the details of the active backup if key backup is enabled.\r\n     *\r\n     * If there was no backup on the server, `null`. If our attempt to check resulted in an error, `undefined`.\r\n     */\r\n    public async getServerBackupInfo(): Promise<KeyBackupInfo | null | undefined> {\r\n        // Do a validity check if we haven't already done one. The check is likely to fail if we don't yet have the\r\n        // backup keys -- but as a side-effect, it will populate `serverBackupInfo`.\r\n        await this.checkKeyBackupAndEnable(false);\r\n        return this.serverBackupInfo;\r\n    }\r\n\r\n    /**\r\n     * Determine if a key backup can be trusted.\r\n     *\r\n     * @param info - key backup info dict from {@link MatrixClient#getKeyBackupVersion}.\r\n     */\r\n    public async isKeyBackupTrusted(info: KeyBackupInfo): Promise<BackupTrustInfo> {\r\n        const signatureVerification: SignatureVerification = await this.olmMachine.verifyBackup(info);\r\n\r\n        const backupKeys: RustSdkCryptoJs.BackupKeys = await this.olmMachine.getBackupKeys();\r\n        const decryptionKey = backupKeys?.decryptionKey;\r\n        const backupMatchesSavedPrivateKey =\r\n            !!decryptionKey && backupInfoMatchesBackupDecryptionKey(info, decryptionKey);\r\n        return {\r\n            matchesDecryptionKey: backupMatchesSavedPrivateKey,\r\n            trusted: signatureVerification.trusted(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Re-check the key backup and enable/disable it as appropriate.\r\n     *\r\n     * @param force - whether we should force a re-check even if one has already happened.\r\n     */\r\n    public checkKeyBackupAndEnable(force: boolean): Promise<KeyBackupCheck | null> {\r\n        if (!force && this.checkedForBackup) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        // make sure there is only one check going on at a time\r\n        if (!this.keyBackupCheckInProgress) {\r\n            this.keyBackupCheckInProgress = this.doCheckKeyBackup().finally(() => {\r\n                this.keyBackupCheckInProgress = null;\r\n            });\r\n        }\r\n        return this.keyBackupCheckInProgress;\r\n    }\r\n\r\n    /**\r\n     * Handles a backup secret received event and store it if it matches the current backup version.\r\n     *\r\n     * @param secret - The secret as received from a `m.secret.send` event for secret `m.megolm_backup.v1`.\r\n     * @returns true if the secret is valid and has been stored, false otherwise.\r\n     */\r\n    public async handleBackupSecretReceived(secret: string): Promise<boolean> {\r\n        // Currently we only receive the decryption key without any key backup version. It is important to\r\n        // check that the secret is valid for the current version before storing it.\r\n        // We force a check to ensure to have the latest version. We also want to check that the backup is trusted\r\n        // as we don't want to store the secret if the backup is not trusted, and eventually import megolm keys later from an untrusted backup.\r\n        const backupCheck = await this.checkKeyBackupAndEnable(true);\r\n\r\n        if (!backupCheck?.backupInfo?.version || !backupCheck.trustInfo.trusted) {\r\n            // There is no server-side key backup, or the backup is not signed by a trusted cross-signing key or trusted own device.\r\n            // This decryption key is useless to us.\r\n            logger.warn(\r\n                \"handleBackupSecretReceived: Received a backup decryption key, but there is no trusted server-side key backup\",\r\n            );\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            const backupDecryptionKey = RustSdkCryptoJs.BackupDecryptionKey.fromBase64(secret);\r\n            const privateKeyMatches = backupInfoMatchesBackupDecryptionKey(backupCheck.backupInfo, backupDecryptionKey);\r\n            if (!privateKeyMatches) {\r\n                logger.warn(\r\n                    `handleBackupSecretReceived: Private decryption key does not match the public key of the current remote backup.`,\r\n                );\r\n                // just ignore the secret\r\n                return false;\r\n            }\r\n            logger.info(\r\n                `handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache.`,\r\n            );\r\n            await this.saveBackupDecryptionKey(backupDecryptionKey, backupCheck.backupInfo.version);\r\n            return true;\r\n        } catch (e) {\r\n            logger.warn(\"handleBackupSecretReceived: Invalid backup decryption key\", e);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public async saveBackupDecryptionKey(\r\n        backupDecryptionKey: RustSdkCryptoJs.BackupDecryptionKey,\r\n        version: string,\r\n    ): Promise<void> {\r\n        await this.olmMachine.saveBackupDecryptionKey(backupDecryptionKey, version);\r\n        // Emit an event that we have a new backup decryption key, so that the sdk can start\r\n        // importing keys from backup if needed.\r\n        this.emit(CryptoEvent.KeyBackupDecryptionKeyCached, version);\r\n    }\r\n\r\n    /**\r\n     * Import a list of room keys previously exported by exportRoomKeys\r\n     *\r\n     * @param keys - a list of session export objects\r\n     * @param opts - options object\r\n     * @returns a promise which resolves once the keys have been imported\r\n     */\r\n    public async importRoomKeys(keys: IMegolmSessionData[], opts?: ImportRoomKeysOpts): Promise<void> {\r\n        await this.importRoomKeysAsJson(JSON.stringify(keys), opts);\r\n    }\r\n\r\n    /**\r\n     * Import a list of room keys previously exported by exportRoomKeysAsJson\r\n     *\r\n     * @param keys - a JSON string encoding a list of session export objects,\r\n     *    each of which is an IMegolmSessionData\r\n     * @param opts - options object\r\n     * @returns a promise which resolves once the keys have been imported\r\n     */\r\n    public async importRoomKeysAsJson(jsonKeys: string, opts?: ImportRoomKeysOpts): Promise<void> {\r\n        await this.olmMachine.importExportedRoomKeys(jsonKeys, (progress: BigInt, total: BigInt): void => {\r\n            const importOpt: ImportRoomKeyProgressData = {\r\n                total: Number(total),\r\n                successes: Number(progress),\r\n                stage: \"load_keys\",\r\n                failures: 0,\r\n            };\r\n            opts?.progressCallback?.(importOpt);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Implementation of {@link CryptoBackend#importBackedUpRoomKeys}.\r\n     */\r\n    public async importBackedUpRoomKeys(\r\n        keys: IMegolmSessionData[],\r\n        backupVersion: string,\r\n        opts?: ImportRoomKeysOpts,\r\n    ): Promise<void> {\r\n        const keysByRoom: Map<RustSdkCryptoJs.RoomId, Map<string, IMegolmSessionData>> = new Map();\r\n        for (const key of keys) {\r\n            const roomId = new RustSdkCryptoJs.RoomId(key.room_id);\r\n            if (!keysByRoom.has(roomId)) {\r\n                keysByRoom.set(roomId, new Map());\r\n            }\r\n            keysByRoom.get(roomId)!.set(key.session_id, key);\r\n        }\r\n        await this.olmMachine.importBackedUpRoomKeys(\r\n            keysByRoom,\r\n            (progress: BigInt, total: BigInt, failures: BigInt): void => {\r\n                const importOpt: ImportRoomKeyProgressData = {\r\n                    total: Number(total),\r\n                    successes: Number(progress),\r\n                    stage: \"load_keys\",\r\n                    failures: Number(failures),\r\n                };\r\n                opts?.progressCallback?.(importOpt);\r\n            },\r\n            backupVersion,\r\n        );\r\n    }\r\n\r\n    private keyBackupCheckInProgress: Promise<KeyBackupCheck | null> | null = null;\r\n\r\n    /** Helper for `checkKeyBackup` */\r\n    private async doCheckKeyBackup(): Promise<KeyBackupCheck | null> {\r\n        logger.log(\"Checking key backup status...\");\r\n        let backupInfo: KeyBackupInfo | null | undefined;\r\n        try {\r\n            backupInfo = await this.requestKeyBackupVersion();\r\n        } catch (e) {\r\n            logger.warn(\"Error checking for active key backup\", e);\r\n            this.serverBackupInfo = undefined;\r\n            return null;\r\n        }\r\n        this.checkedForBackup = true;\r\n\r\n        if (backupInfo && !backupInfo.version) {\r\n            logger.warn(\"active backup lacks a useful 'version'; ignoring it\");\r\n            backupInfo = undefined;\r\n        }\r\n        this.serverBackupInfo = backupInfo;\r\n\r\n        const activeVersion = await this.getActiveBackupVersion();\r\n\r\n        if (!backupInfo) {\r\n            if (activeVersion !== null) {\r\n                logger.log(\"No key backup present on server: disabling key backup\");\r\n                await this.disableKeyBackup();\r\n            } else {\r\n                logger.log(\"No key backup present on server: not enabling key backup\");\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const trustInfo = await this.isKeyBackupTrusted(backupInfo);\r\n\r\n        if (!trustInfo.trusted) {\r\n            if (activeVersion !== null) {\r\n                logger.log(\"Key backup present on server but not trusted: disabling key backup\");\r\n                await this.disableKeyBackup();\r\n            } else {\r\n                logger.log(\"Key backup present on server but not trusted: not enabling key backup\");\r\n            }\r\n        } else {\r\n            if (activeVersion === null) {\r\n                logger.log(`Found usable key backup v${backupInfo.version}: enabling key backups`);\r\n                await this.enableKeyBackup(backupInfo);\r\n            } else if (activeVersion !== backupInfo.version) {\r\n                logger.log(`On backup version ${activeVersion} but found version ${backupInfo.version}: switching.`);\r\n                // This will remove any pending backup request, remove the backup key and reset the backup state of each room key we have.\r\n                await this.disableKeyBackup();\r\n                // Enabling will now trigger re-upload of all the keys\r\n                await this.enableKeyBackup(backupInfo);\r\n            } else {\r\n                logger.log(`Backup version ${backupInfo.version} still current`);\r\n            }\r\n        }\r\n        return { backupInfo, trustInfo };\r\n    }\r\n\r\n    private async enableKeyBackup(backupInfo: KeyBackupInfo): Promise<void> {\r\n        // we know for certain it must be a Curve25519 key, because we have verified it and only Curve25519\r\n        // keys can be verified.\r\n        //\r\n        // we also checked it has a valid `version`.\r\n        await this.olmMachine.enableBackupV1(\r\n            (backupInfo.auth_data as Curve25519AuthData).public_key,\r\n            backupInfo.version!,\r\n        );\r\n        this.activeBackupVersion = backupInfo.version!;\r\n\r\n        this.emit(CryptoEvent.KeyBackupStatus, true);\r\n\r\n        this.backupKeysLoop();\r\n    }\r\n\r\n    /**\r\n     * Restart the backup key loop if there is an active trusted backup.\r\n     * Doesn't try to check the backup server side. To be called when a new\r\n     * megolm key is known locally.\r\n     */\r\n    public async maybeUploadKey(): Promise<void> {\r\n        if (this.activeBackupVersion != null) {\r\n            this.backupKeysLoop();\r\n        }\r\n    }\r\n\r\n    private async disableKeyBackup(): Promise<void> {\r\n        await this.olmMachine.disableBackup();\r\n        this.activeBackupVersion = null;\r\n        this.emit(CryptoEvent.KeyBackupStatus, false);\r\n    }\r\n\r\n    private async backupKeysLoop(maxDelay = 10000): Promise<void> {\r\n        if (this.backupKeysLoopRunning) {\r\n            logger.log(`Backup loop already running`);\r\n            return;\r\n        }\r\n        this.backupKeysLoopRunning = true;\r\n\r\n        logger.log(`Backup: Starting keys upload loop for backup version:${this.activeBackupVersion}.`);\r\n\r\n        // wait between 0 and `maxDelay` seconds, to avoid backup\r\n        // requests from different clients hitting the server all at\r\n        // the same time when a new key is sent\r\n        const delay = Math.random() * maxDelay;\r\n        await sleep(delay);\r\n\r\n        try {\r\n            // number of consecutive network failures for exponential backoff\r\n            let numFailures = 0;\r\n            // The number of keys left to back up. (Populated lazily: see more comments below.)\r\n            let remainingToUploadCount: number | null = null;\r\n            // To avoid computing the key when only a few keys were added (after a sync for example),\r\n            // we compute the count only when at least two iterations are needed.\r\n            let isFirstIteration = true;\r\n\r\n            while (!this.stopped) {\r\n                // Get a batch of room keys to upload\r\n                let request: RustSdkCryptoJs.KeysBackupRequest | null = null;\r\n                try {\r\n                    request = await logDuration(\r\n                        logger,\r\n                        \"BackupRoomKeys: Get keys to backup from rust crypto-sdk\",\r\n                        async () => {\r\n                            return await this.olmMachine.backupRoomKeys();\r\n                        },\r\n                    );\r\n                } catch (err) {\r\n                    logger.error(\"Backup: Failed to get keys to backup from rust crypto-sdk\", err);\r\n                }\r\n\r\n                if (!request || this.stopped || !this.activeBackupVersion) {\r\n                    logger.log(`Backup: Ending loop for version ${this.activeBackupVersion}.`);\r\n                    if (!request) {\r\n                        // nothing more to upload\r\n                        this.emit(CryptoEvent.KeyBackupSessionsRemaining, 0);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    await this.outgoingRequestProcessor.makeOutgoingRequest(request);\r\n                    numFailures = 0;\r\n                    if (this.stopped) break;\r\n\r\n                    // Key count performance (`olmMachine.roomKeyCounts()`) can be pretty bad on some configurations.\r\n                    // In particular, we detected on some M1 macs that when the object store reaches a threshold, the count\r\n                    // performance stops growing in O(n) and suddenly becomes very slow (40s, 60s or more).\r\n                    // For reference, the performance drop occurs around 300-400k keys on the platforms where this issue is observed.\r\n                    // Even on other configurations, the count can take several seconds.\r\n                    // This will block other operations on the database, like sending messages.\r\n                    //\r\n                    // This is a workaround to avoid calling `olmMachine.roomKeyCounts()` too often, and only when necessary.\r\n                    // We don't call it on the first loop because there could be only a few keys to upload, and we don't want to wait for the count.\r\n                    if (!isFirstIteration && remainingToUploadCount === null) {\r\n                        try {\r\n                            const keyCount = await this.olmMachine.roomKeyCounts();\r\n                            remainingToUploadCount = keyCount.total - keyCount.backedUp;\r\n                        } catch (err) {\r\n                            logger.error(\"Backup: Failed to get key counts from rust crypto-sdk\", err);\r\n                        }\r\n                    }\r\n\r\n                    if (remainingToUploadCount !== null) {\r\n                        this.emit(CryptoEvent.KeyBackupSessionsRemaining, remainingToUploadCount);\r\n                        const keysCountInBatch = this.keysCountInBatch(request);\r\n                        // `OlmMachine.roomKeyCounts` is called only once for the current backupKeysLoop. But new\r\n                        // keys could be added during the current loop (after a sync for example).\r\n                        // So the count can get out of sync with the real number of remaining keys to upload.\r\n                        // Depending on the number of new keys imported and the time to complete the loop,\r\n                        // this could result in multiple events being emitted with a remaining key count of 0.\r\n                        remainingToUploadCount = Math.max(remainingToUploadCount - keysCountInBatch, 0);\r\n                    }\r\n                } catch (err) {\r\n                    numFailures++;\r\n                    logger.error(\"Backup: Error processing backup request for rust crypto-sdk\", err);\r\n                    if (err instanceof MatrixError) {\r\n                        const errCode = err.data.errcode;\r\n                        if (errCode == \"M_NOT_FOUND\" || errCode == \"M_WRONG_ROOM_KEYS_VERSION\") {\r\n                            logger.log(`Backup: Failed to upload keys to current vesion: ${errCode}.`);\r\n                            try {\r\n                                await this.disableKeyBackup();\r\n                            } catch (error) {\r\n                                logger.error(\"Backup: An error occurred while disabling key backup:\", error);\r\n                            }\r\n                            this.emit(CryptoEvent.KeyBackupFailed, err.data.errcode!);\r\n                            // There was an active backup and we are out of sync with the server\r\n                            // force a check server side\r\n                            this.backupKeysLoopRunning = false;\r\n                            this.checkKeyBackupAndEnable(true);\r\n                            return;\r\n                        } else if (errCode == \"M_LIMIT_EXCEEDED\") {\r\n                            // wait for that and then continue?\r\n                            const waitTime = err.data.retry_after_ms;\r\n                            if (waitTime > 0) {\r\n                                await sleep(waitTime);\r\n                                continue;\r\n                            } // else go to the normal backoff\r\n                        }\r\n                    }\r\n\r\n                    // Some other errors (mx, network, or CORS or invalid urls?) anyhow backoff\r\n                    // exponential backoff if we have failures\r\n                    await sleep(1000 * Math.pow(2, Math.min(numFailures - 1, 4)));\r\n                }\r\n                isFirstIteration = false;\r\n            }\r\n        } finally {\r\n            this.backupKeysLoopRunning = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility method to count the number of keys in a backup request, in order to update the remaining keys count.\r\n     * This should be the chunk size of the backup request for all requests but the last, but we don't have access to it\r\n     * (it's static in the Rust SDK).\r\n     * @param batch - The backup request to count the keys from.\r\n     *\r\n     * @returns The number of keys in the backup request.\r\n     */\r\n    private keysCountInBatch(batch: RustSdkCryptoJs.KeysBackupRequest): number {\r\n        const parsedBody: IKeyBackup = JSON.parse(batch.body);\r\n        let count = 0;\r\n        for (const { sessions } of Object.values(parsedBody.rooms)) {\r\n            count += Object.keys(sessions).length;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Get information about the current key backup from the server\r\n     *\r\n     * @returns Information object from API or null if there is no active backup.\r\n     */\r\n    private async requestKeyBackupVersion(): Promise<KeyBackupInfo | null> {\r\n        return await requestKeyBackupVersion(this.http);\r\n    }\r\n\r\n    /**\r\n     * Creates a new key backup by generating a new random private key.\r\n     *\r\n     * If there is an existing backup server side it will be deleted and replaced\r\n     * by the new one.\r\n     *\r\n     * @param signObject - Method that should sign the backup with existing device and\r\n     * existing identity.\r\n     * @returns a KeyBackupCreationInfo - All information related to the backup.\r\n     */\r\n    public async setupKeyBackup(signObject: (authData: AuthData) => Promise<void>): Promise<KeyBackupCreationInfo> {\r\n        // Clean up any existing backup\r\n        await this.deleteAllKeyBackupVersions();\r\n\r\n        const randomKey = RustSdkCryptoJs.BackupDecryptionKey.createRandomKey();\r\n        const pubKey = randomKey.megolmV1PublicKey;\r\n\r\n        const authData = { public_key: pubKey.publicKeyBase64 };\r\n\r\n        await signObject(authData);\r\n\r\n        const res = await this.http.authedRequest<{ version: string }>(\r\n            Method.Post,\r\n            \"/room_keys/version\",\r\n            undefined,\r\n            {\r\n                algorithm: pubKey.algorithm,\r\n                auth_data: authData,\r\n            },\r\n            {\r\n                prefix: ClientPrefix.V3,\r\n            },\r\n        );\r\n\r\n        await this.saveBackupDecryptionKey(randomKey, res.version);\r\n\r\n        return {\r\n            version: res.version,\r\n            algorithm: pubKey.algorithm,\r\n            authData: authData,\r\n            decryptionKey: randomKey,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deletes all key backups.\r\n     *\r\n     * Will call the API to delete active backup until there is no more present.\r\n     */\r\n    public async deleteAllKeyBackupVersions(): Promise<void> {\r\n        // there could be several backup versions. Delete all to be safe.\r\n        let current = (await this.requestKeyBackupVersion())?.version ?? null;\r\n        while (current != null) {\r\n            await this.deleteKeyBackupVersion(current);\r\n            current = (await this.requestKeyBackupVersion())?.version ?? null;\r\n        }\r\n\r\n        // XXX: Should this also update Secret Storage and delete any existing keys?\r\n    }\r\n\r\n    /**\r\n     * Deletes the given key backup.\r\n     *\r\n     * @param version - The backup version to delete.\r\n     */\r\n    public async deleteKeyBackupVersion(version: string): Promise<void> {\r\n        logger.debug(`deleteKeyBackupVersion v:${version}`);\r\n        const path = encodeUri(\"/room_keys/version/$version\", { $version: version });\r\n        await this.http.authedRequest<void>(Method.Delete, path, undefined, undefined, {\r\n            prefix: ClientPrefix.V3,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new backup decryptor for the given private key.\r\n     * @param decryptionKey - The private key to use for decryption.\r\n     */\r\n    public createBackupDecryptor(decryptionKey: RustSdkCryptoJs.BackupDecryptionKey): BackupDecryptor {\r\n        return new RustBackupDecryptor(decryptionKey);\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the provided backup info matches the given private key.\r\n *\r\n * @param info - The backup info to check.\r\n * @param backupDecryptionKey - The `BackupDecryptionKey` private key to check against.\r\n * @returns `true` if the private key can decrypt the backup, `false` otherwise.\r\n */\r\nfunction backupInfoMatchesBackupDecryptionKey(\r\n    info: KeyBackupInfo,\r\n    backupDecryptionKey: RustSdkCryptoJs.BackupDecryptionKey,\r\n): boolean {\r\n    if (info.algorithm !== \"m.megolm_backup.v1.curve25519-aes-sha2\") {\r\n        logger.warn(\"backupMatchesPrivateKey: Unsupported backup algorithm\", info.algorithm);\r\n        return false;\r\n    }\r\n\r\n    return (info.auth_data as Curve25519AuthData)?.public_key === backupDecryptionKey.megolmV1PublicKey.publicKeyBase64;\r\n}\r\n\r\n/**\r\n * Implementation of {@link BackupDecryptor} for the rust crypto backend.\r\n */\r\nexport class RustBackupDecryptor implements BackupDecryptor {\r\n    private decryptionKey: RustSdkCryptoJs.BackupDecryptionKey;\r\n    public sourceTrusted: boolean;\r\n\r\n    public constructor(decryptionKey: RustSdkCryptoJs.BackupDecryptionKey) {\r\n        this.decryptionKey = decryptionKey;\r\n        this.sourceTrusted = false;\r\n    }\r\n\r\n    /**\r\n     * Implements {@link BackupDecryptor#decryptSessions}\r\n     */\r\n    public async decryptSessions(\r\n        ciphertexts: Record<string, KeyBackupSession<Curve25519SessionData | IEncryptedPayload>>,\r\n    ): Promise<IMegolmSessionData[]> {\r\n        const keys: IMegolmSessionData[] = [];\r\n        for (const [sessionId, sessionData] of Object.entries(ciphertexts)) {\r\n            try {\r\n                const decrypted = JSON.parse(\r\n                    this.decryptionKey.decryptV1(\r\n                        sessionData.session_data.ephemeral,\r\n                        sessionData.session_data.mac,\r\n                        sessionData.session_data.ciphertext,\r\n                    ),\r\n                );\r\n                decrypted.session_id = sessionId;\r\n                keys.push(decrypted);\r\n            } catch (e) {\r\n                logger.log(\"Failed to decrypt megolm session from backup\", e, sessionData);\r\n            }\r\n        }\r\n        return keys;\r\n    }\r\n\r\n    /**\r\n     * Implements {@link BackupDecryptor#free}\r\n     */\r\n    public free(): void {\r\n        this.decryptionKey.free();\r\n    }\r\n}\r\n\r\nexport async function requestKeyBackupVersion(\r\n    http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\r\n): Promise<IKeyBackupInfo | null> {\r\n    try {\r\n        return await http.authedRequest<KeyBackupInfo>(Method.Get, \"/room_keys/version\", undefined, undefined, {\r\n            prefix: ClientPrefix.V3,\r\n        });\r\n    } catch (e) {\r\n        if ((<MatrixError>e).errcode === \"M_NOT_FOUND\") {\r\n            return null;\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n\r\nexport type RustBackupCryptoEvents =\r\n    | CryptoEvent.KeyBackupStatus\r\n    | CryptoEvent.KeyBackupSessionsRemaining\r\n    | CryptoEvent.KeyBackupFailed\r\n    | CryptoEvent.KeyBackupDecryptionKeyCached;\r\n\r\nexport type RustBackupCryptoEventMap = {\r\n    [CryptoEvent.KeyBackupStatus]: (enabled: boolean) => void;\r\n    [CryptoEvent.KeyBackupSessionsRemaining]: (remaining: number) => void;\r\n    [CryptoEvent.KeyBackupFailed]: (errCode: string) => void;\r\n    [CryptoEvent.KeyBackupDecryptionKeyCached]: (version: string) => void;\r\n};\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { OlmMachine, UserId } from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { OutgoingRequestProcessor } from \"./OutgoingRequestProcessor\";\r\nimport { LogSpan } from \"../logger\";\r\n\r\n/**\r\n * KeyClaimManager: linearises calls to OlmMachine.getMissingSessions to avoid races\r\n *\r\n * We have one of these per `RustCrypto` (and hence per `MatrixClient`).\r\n *\r\n * @internal\r\n */\r\nexport class KeyClaimManager {\r\n    private currentClaimPromise: Promise<void>;\r\n    private stopped = false;\r\n\r\n    public constructor(\r\n        private readonly olmMachine: OlmMachine,\r\n        private readonly outgoingRequestProcessor: OutgoingRequestProcessor,\r\n    ) {\r\n        this.currentClaimPromise = Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Tell the KeyClaimManager to immediately stop processing requests.\r\n     *\r\n     * Any further calls, and any still in the queue, will fail with an error.\r\n     */\r\n    public stop(): void {\r\n        this.stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Given a list of users, attempt to ensure that we have Olm Sessions active with each of their devices\r\n     *\r\n     * If we don't have an active olm session, we will claim a one-time key and start one.\r\n     *\r\n     * @param userList - list of userIDs to claim\r\n     */\r\n    public ensureSessionsForUsers(logger: LogSpan, userList: Array<UserId>): Promise<void> {\r\n        // The Rust-SDK requires that we only have one getMissingSessions process in flight at once. This little dance\r\n        // ensures that, by only having one call to ensureSessionsForUsersInner active at once (and making them\r\n        // queue up in order).\r\n        const prom = this.currentClaimPromise\r\n            .catch(() => {\r\n                // any errors in the previous claim will have been reported already, so there is nothing to do here.\r\n                // we just throw away the error and start anew.\r\n            })\r\n            .then(() => this.ensureSessionsForUsersInner(logger, userList));\r\n        this.currentClaimPromise = prom;\r\n        return prom;\r\n    }\r\n\r\n    private async ensureSessionsForUsersInner(logger: LogSpan, userList: Array<UserId>): Promise<void> {\r\n        // bail out quickly if we've been stopped.\r\n        if (this.stopped) {\r\n            throw new Error(`Cannot ensure Olm sessions: shutting down`);\r\n        }\r\n        logger.info(\"Checking for missing Olm sessions\");\r\n        // By passing the userId array to rust we transfer ownership of the items to rust, causing\r\n        // them to be invalidated on the JS side as soon as the method is called.\r\n        // As we haven't created the `userList` let's clone the users, to not break the caller from re-using it.\r\n        const claimRequest = await this.olmMachine.getMissingSessions(userList.map((u) => u.clone()));\r\n        if (claimRequest) {\r\n            logger.info(\"Making /keys/claim request\");\r\n            await this.outgoingRequestProcessor.makeOutgoingRequest(claimRequest);\r\n        }\r\n        logger.info(\"Olm sessions prepared\");\r\n    }\r\n}\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\nimport {\r\n    CollectStrategy,\r\n    EncryptionAlgorithm,\r\n    EncryptionSettings,\r\n    HistoryVisibility as RustHistoryVisibility,\r\n    OlmMachine,\r\n    RoomId,\r\n    ToDeviceRequest,\r\n    UserId,\r\n} from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { EventType } from \"../@types/event\";\r\nimport { IContent, MatrixEvent } from \"../models/event\";\r\nimport { Room } from \"../models/room\";\r\nimport { Logger, logger, LogSpan } from \"../logger\";\r\nimport { KeyClaimManager } from \"./KeyClaimManager\";\r\nimport { RoomMember } from \"../models/room-member\";\r\nimport { HistoryVisibility } from \"../@types/partials\";\r\nimport { OutgoingRequestsManager } from \"./OutgoingRequestsManager\";\r\nimport { logDuration } from \"../utils\";\r\nimport { KnownMembership } from \"../@types/membership\";\r\n\r\n/**\r\n * RoomEncryptor: responsible for encrypting messages to a given room\r\n *\r\n * @internal\r\n */\r\nexport class RoomEncryptor {\r\n    private readonly prefixedLogger: Logger;\r\n\r\n    /** whether the room members have been loaded and tracked for the first time */\r\n    private lazyLoadedMembersResolved = false;\r\n\r\n    /**\r\n     * Ensures that there is only one encryption operation at a time for that room.\r\n     *\r\n     * An encryption operation is either a {@link prepareForEncryption} or an {@link encryptEvent} call.\r\n     */\r\n    private currentEncryptionPromise: Promise<void> = Promise.resolve();\r\n\r\n    /**\r\n     * @param olmMachine - The rust-sdk's OlmMachine\r\n     * @param keyClaimManager - Our KeyClaimManager, which manages the queue of one-time-key claim requests\r\n     * @param outgoingRequestManager - The OutgoingRequestManager, which manages the queue of outgoing requests.\r\n     * @param room - The room we want to encrypt for\r\n     * @param encryptionSettings - body of the m.room.encryption event currently in force in this room\r\n     */\r\n    public constructor(\r\n        private readonly olmMachine: OlmMachine,\r\n        private readonly keyClaimManager: KeyClaimManager,\r\n        private readonly outgoingRequestManager: OutgoingRequestsManager,\r\n        private readonly room: Room,\r\n        private encryptionSettings: IContent,\r\n    ) {\r\n        this.prefixedLogger = logger.getChild(`[${room.roomId} encryption]`);\r\n\r\n        // start tracking devices for any users already known to be in this room.\r\n        // Do not load members here, would defeat lazy loading.\r\n        const members = room.getJoinedMembers();\r\n\r\n        // At this point just mark the known members as tracked, it might not be the full list of members\r\n        // because of lazy loading. This is fine, because we will get a member list update when sending a message for\r\n        // the first time, see `RoomEncryptor#ensureEncryptionSession`\r\n        this.olmMachine\r\n            .updateTrackedUsers(members.map((u) => new RustSdkCryptoJs.UserId(u.userId)))\r\n            .catch((e) => this.prefixedLogger.error(\"Error initializing tracked users\", e));\r\n    }\r\n\r\n    /**\r\n     * Handle a new `m.room.encryption` event in this room\r\n     *\r\n     * @param config - The content of the encryption event\r\n     */\r\n    public onCryptoEvent(config: IContent): void {\r\n        if (JSON.stringify(this.encryptionSettings) != JSON.stringify(config)) {\r\n            // This should currently be unreachable, since the Rust SDK will reject any attempts to change config.\r\n            throw new Error(\"Cannot reconfigure an active RoomEncryptor\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle a new `m.room.member` event in this room\r\n     *\r\n     * @param member - new membership state\r\n     */\r\n    public onRoomMembership(member: RoomMember): void {\r\n        if (\r\n            member.membership == KnownMembership.Join ||\r\n            (member.membership == KnownMembership.Invite && this.room.shouldEncryptForInvitedMembers())\r\n        ) {\r\n            // make sure we are tracking the deviceList for this user\r\n            this.olmMachine.updateTrackedUsers([new UserId(member.userId)]).catch((e) => {\r\n                this.prefixedLogger.error(\"Unable to update tracked users\", e);\r\n            });\r\n        }\r\n\r\n        // TODO: handle leaves (including our own)\r\n    }\r\n\r\n    /**\r\n     * Prepare to encrypt events in this room.\r\n     *\r\n     * This ensures that we have a megolm session ready to use and that we have shared its key with all the devices\r\n     * in the room.\r\n     *\r\n     * @param globalBlacklistUnverifiedDevices - When `true`, it will not send encrypted messages to unverified devices\r\n     */\r\n    public async prepareForEncryption(globalBlacklistUnverifiedDevices: boolean): Promise<void> {\r\n        // We consider a prepareForEncryption as an encryption promise as it will potentially share keys\r\n        // even if it doesn't send an event.\r\n        // Usually this is called when the user starts typing, so we want to make sure we have keys ready when the\r\n        // message is finally sent.\r\n        // If `encryptEvent` is invoked before `prepareForEncryption` has completed, the `encryptEvent` call will wait for\r\n        // `prepareForEncryption` to complete before executing.\r\n        // The part where `encryptEvent` shares the room key will then usually be a no-op as it was already performed by `prepareForEncryption`.\r\n        await this.encryptEvent(null, globalBlacklistUnverifiedDevices);\r\n    }\r\n\r\n    /**\r\n     * Encrypt an event for this room, or prepare for encryption.\r\n     *\r\n     * This will ensure that we have a megolm session for this room, share it with the devices in the room, and\r\n     * then, if an event is provided, encrypt it using the session.\r\n     *\r\n     * @param event - Event to be encrypted, or null if only preparing for encryption (in which case we will pre-share the room key).\r\n     * @param globalBlacklistUnverifiedDevices - When `true`, it will not send encrypted messages to unverified devices\r\n     */\r\n    public encryptEvent(event: MatrixEvent | null, globalBlacklistUnverifiedDevices: boolean): Promise<void> {\r\n        const logger = new LogSpan(this.prefixedLogger, event ? (event.getTxnId() ?? \"\") : \"prepareForEncryption\");\r\n        // Ensure order of encryption to avoid message ordering issues, as the scheduler only ensures\r\n        // events order after they have been encrypted.\r\n        const prom = this.currentEncryptionPromise\r\n            .catch(() => {\r\n                // Any errors in the previous call will have been reported already, so there is nothing to do here.\r\n                // we just throw away the error and start anew.\r\n            })\r\n            .then(async () => {\r\n                await logDuration(logger, \"ensureEncryptionSession\", async () => {\r\n                    await this.ensureEncryptionSession(logger, globalBlacklistUnverifiedDevices);\r\n                });\r\n                if (event) {\r\n                    await logDuration(logger, \"encryptEventInner\", async () => {\r\n                        await this.encryptEventInner(logger, event);\r\n                    });\r\n                }\r\n            });\r\n\r\n        this.currentEncryptionPromise = prom;\r\n        return prom;\r\n    }\r\n\r\n    /**\r\n     * Prepare to encrypt events in this room.\r\n     *\r\n     * This ensures that we have a megolm session ready to use and that we have shared its key with all the devices\r\n     * in the room.\r\n     *\r\n     * @param logger - a place to write diagnostics to\r\n     * @param globalBlacklistUnverifiedDevices - When `true`, it will not send encrypted messages to unverified devices\r\n     */\r\n    private async ensureEncryptionSession(logger: LogSpan, globalBlacklistUnverifiedDevices: boolean): Promise<void> {\r\n        if (this.encryptionSettings.algorithm !== \"m.megolm.v1.aes-sha2\") {\r\n            throw new Error(\r\n                `Cannot encrypt in ${this.room.roomId} for unsupported algorithm '${this.encryptionSettings.algorithm}'`,\r\n            );\r\n        }\r\n        logger.debug(\"Starting encryption\");\r\n\r\n        const members = await this.room.getEncryptionTargetMembers();\r\n\r\n        // If this is the first time we are sending a message to the room, we may not yet have seen all the members\r\n        // (so the Crypto SDK might not have a device list for them). So, if this is the first time we are encrypting\r\n        // for this room, give the SDK the full list of members, to be on the safe side.\r\n        //\r\n        // This could end up being racy (if two calls to ensureEncryptionSession happen at the same time), but that's\r\n        // not a particular problem, since `OlmMachine.updateTrackedUsers` just adds any users that weren't already tracked.\r\n        if (!this.lazyLoadedMembersResolved) {\r\n            await logDuration(this.prefixedLogger, \"loadMembersIfNeeded: updateTrackedUsers\", async () => {\r\n                await this.olmMachine.updateTrackedUsers(members.map((u) => new RustSdkCryptoJs.UserId(u.userId)));\r\n            });\r\n            logger.debug(`Updated tracked users`);\r\n            this.lazyLoadedMembersResolved = true;\r\n\r\n            // Query keys in case we don't have them for newly tracked members.\r\n            // It's important after loading members for the first time, as likely most of them won't be\r\n            // known yet and will be unable to decrypt messages despite being in the room for long.\r\n            // This must be done before ensuring sessions. If not the devices of these users are not\r\n            // known yet and will not get the room key.\r\n            // We don't have API to only get the keys queries related to this member list, so we just\r\n            // process the pending requests from the olmMachine. (usually these are processed\r\n            // at the end of the sync, but we can't wait for that).\r\n            // XXX future improvement process only KeysQueryRequests for the users that have never been queried.\r\n            logger.debug(`Processing outgoing requests`);\r\n\r\n            await logDuration(this.prefixedLogger, \"doProcessOutgoingRequests\", async () => {\r\n                await this.outgoingRequestManager.doProcessOutgoingRequests();\r\n            });\r\n        } else {\r\n            // If members are already loaded it's less critical to await on key queries.\r\n            // We might still want to trigger a processOutgoingRequests here.\r\n            // The call to `ensureSessionsForUsers` below will wait a bit on in-flight key queries we are\r\n            // interested in. If a sync handling happens in the meantime, and some new members are added to the room\r\n            // or have new devices it would give us a chance to query them before sending.\r\n            // It's less critical due to the racy nature of this process.\r\n            logger.debug(`Processing outgoing requests in background`);\r\n            this.outgoingRequestManager.doProcessOutgoingRequests();\r\n        }\r\n\r\n        logger.debug(\r\n            `Encrypting for users (shouldEncryptForInvitedMembers: ${this.room.shouldEncryptForInvitedMembers()}):`,\r\n            members.map((u) => `${u.userId} (${u.membership})`),\r\n        );\r\n\r\n        const userList = members.map((u) => new UserId(u.userId));\r\n\r\n        await logDuration(this.prefixedLogger, \"ensureSessionsForUsers\", async () => {\r\n            await this.keyClaimManager.ensureSessionsForUsers(logger, userList);\r\n        });\r\n\r\n        const rustEncryptionSettings = new EncryptionSettings();\r\n        rustEncryptionSettings.historyVisibility = toRustHistoryVisibility(this.room.getHistoryVisibility());\r\n\r\n        // We only support megolm\r\n        rustEncryptionSettings.algorithm = EncryptionAlgorithm.MegolmV1AesSha2;\r\n\r\n        // We need to convert the rotation period from milliseconds to microseconds\r\n        // See https://spec.matrix.org/v1.8/client-server-api/#mroomencryption and\r\n        // https://matrix-org.github.io/matrix-rust-sdk-crypto-wasm/classes/EncryptionSettings.html#rotationPeriod\r\n        if (typeof this.encryptionSettings.rotation_period_ms === \"number\") {\r\n            rustEncryptionSettings.rotationPeriod = BigInt(this.encryptionSettings.rotation_period_ms * 1000);\r\n        }\r\n\r\n        if (typeof this.encryptionSettings.rotation_period_msgs === \"number\") {\r\n            rustEncryptionSettings.rotationPeriodMessages = BigInt(this.encryptionSettings.rotation_period_msgs);\r\n        }\r\n\r\n        // When this.room.getBlacklistUnverifiedDevices() === null, the global settings should be used\r\n        // See Room#getBlacklistUnverifiedDevices\r\n        if (this.room.getBlacklistUnverifiedDevices() ?? globalBlacklistUnverifiedDevices) {\r\n            rustEncryptionSettings.sharingStrategy = CollectStrategy.DeviceBasedStrategyOnlyTrustedDevices;\r\n        } else {\r\n            rustEncryptionSettings.sharingStrategy = CollectStrategy.DeviceBasedStrategyAllDevices;\r\n        }\r\n\r\n        await logDuration(this.prefixedLogger, \"shareRoomKey\", async () => {\r\n            const shareMessages: ToDeviceRequest[] = await this.olmMachine.shareRoomKey(\r\n                new RoomId(this.room.roomId),\r\n                // safe to pass without cloning, as it's not reused here (before or after)\r\n                userList,\r\n                rustEncryptionSettings,\r\n            );\r\n            if (shareMessages) {\r\n                for (const m of shareMessages) {\r\n                    await this.outgoingRequestManager.outgoingRequestProcessor.makeOutgoingRequest(m);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Discard any existing group session for this room\r\n     */\r\n    public async forceDiscardSession(): Promise<void> {\r\n        const r = await this.olmMachine.invalidateGroupSession(new RoomId(this.room.roomId));\r\n        if (r) {\r\n            this.prefixedLogger.info(\"Discarded existing group session\");\r\n        }\r\n    }\r\n\r\n    private async encryptEventInner(logger: LogSpan, event: MatrixEvent): Promise<void> {\r\n        logger.debug(\"Encrypting actual message content\");\r\n        const encryptedContent = await this.olmMachine.encryptRoomEvent(\r\n            new RoomId(this.room.roomId),\r\n            event.getType(),\r\n            JSON.stringify(event.getContent()),\r\n        );\r\n\r\n        event.makeEncrypted(\r\n            EventType.RoomMessageEncrypted,\r\n            JSON.parse(encryptedContent),\r\n            this.olmMachine.identityKeys.curve25519.toBase64(),\r\n            this.olmMachine.identityKeys.ed25519.toBase64(),\r\n        );\r\n\r\n        logger.debug(\"Encrypted event successfully\");\r\n    }\r\n}\r\n\r\n/**\r\n * Convert a HistoryVisibility to a RustHistoryVisibility\r\n * @param visibility - HistoryVisibility enum\r\n * @returns a RustHistoryVisibility enum\r\n */\r\nexport function toRustHistoryVisibility(visibility: HistoryVisibility): RustHistoryVisibility {\r\n    switch (visibility) {\r\n        case HistoryVisibility.Invited:\r\n            return RustHistoryVisibility.Invited;\r\n        case HistoryVisibility.Joined:\r\n            return RustHistoryVisibility.Joined;\r\n        case HistoryVisibility.Shared:\r\n            return RustHistoryVisibility.Shared;\r\n        case HistoryVisibility.WorldReadable:\r\n            return RustHistoryVisibility.WorldReadable;\r\n    }\r\n}\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\nimport { OlmMachine } from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { Curve25519AuthData, KeyBackupInfo, KeyBackupSession } from \"../crypto-api/keybackup\";\r\nimport { Logger } from \"../logger\";\r\nimport { ClientPrefix, IHttpOpts, MatrixError, MatrixHttpApi, Method } from \"../http-api\";\r\nimport { RustBackupManager } from \"./backup\";\r\nimport { CryptoEvent } from \"../matrix\";\r\nimport { encodeUri, sleep } from \"../utils\";\r\nimport { BackupDecryptor } from \"../common-crypto/CryptoBackend\";\r\n\r\n// The minimum time to wait between two retries in case of errors. To avoid hammering the server.\r\nconst KEY_BACKUP_BACKOFF = 5000; // ms\r\n\r\n/**\r\n * Enumerates the different kind of errors that can occurs when downloading and importing a key from backup.\r\n */\r\nenum KeyDownloadErrorCode {\r\n    /** The requested key is not in the backup. */\r\n    MISSING_DECRYPTION_KEY = \"MISSING_DECRYPTION_KEY\",\r\n    /** A network error occurred while trying to download the key from backup. */\r\n    NETWORK_ERROR = \"NETWORK_ERROR\",\r\n    /** The loop has been stopped. */\r\n    STOPPED = \"STOPPED\",\r\n}\r\n\r\nclass KeyDownloadError extends Error {\r\n    public constructor(public readonly code: KeyDownloadErrorCode) {\r\n        super(`Failed to get key from backup: ${code}`);\r\n        this.name = \"KeyDownloadError\";\r\n    }\r\n}\r\n\r\nclass KeyDownloadRateLimitError extends Error {\r\n    public constructor(public readonly retryMillis: number) {\r\n        super(`Failed to get key from backup: rate limited`);\r\n        this.name = \"KeyDownloadRateLimitError\";\r\n    }\r\n}\r\n\r\n/** Details of a megolm session whose key we are trying to fetch. */\r\ntype SessionInfo = { roomId: string; megolmSessionId: string };\r\n\r\n/** Holds the current backup decryptor and version that should be used.\r\n *\r\n * This is intended to be used as an immutable object (a new instance should be created if the configuration changes),\r\n * and some of the logic relies on that, so the properties are marked as `readonly`.\r\n */\r\ntype Configuration = {\r\n    readonly backupVersion: string;\r\n    readonly decryptor: BackupDecryptor;\r\n};\r\n\r\n/**\r\n * Used when an 'unable to decrypt' error occurs. It attempts to download the key from the backup.\r\n *\r\n * The current backup API lacks pagination, which can lead to lengthy key retrieval times for large histories (several 10s of minutes).\r\n * To mitigate this, keys are downloaded on demand as decryption errors occurs.\r\n * While this approach may result in numerous requests, it improves user experience by reducing wait times for message decryption.\r\n *\r\n * The PerSessionKeyBackupDownloader is resistant to backup configuration changes: it will automatically resume querying when\r\n * the backup is configured correctly.\r\n */\r\nexport class PerSessionKeyBackupDownloader {\r\n    private stopped = false;\r\n\r\n    /**\r\n     * The version and decryption key to use with current backup if all set up correctly.\r\n     *\r\n     * Will not be set unless `hasConfigurationProblem` is `false`.\r\n     */\r\n    private configuration: Configuration | null = null;\r\n\r\n    /** We remember when a session was requested and not found in backup to avoid query again too soon.\r\n     * Map of session_id to timestamp */\r\n    private sessionLastCheckAttemptedTime: Map<string, number> = new Map();\r\n\r\n    /** The logger to use */\r\n    private readonly logger: Logger;\r\n\r\n    /** Whether the download loop is running. */\r\n    private downloadLoopRunning = false;\r\n\r\n    /** The list of requests that are queued. */\r\n    private queuedRequests: SessionInfo[] = [];\r\n\r\n    /** Remembers if we have a configuration problem. */\r\n    private hasConfigurationProblem = false;\r\n\r\n    /** The current server backup version check promise. To avoid doing a server call if one is in flight. */\r\n    private currentBackupVersionCheck: Promise<Configuration | null> | null = null;\r\n\r\n    /**\r\n     * Creates a new instance of PerSessionKeyBackupDownloader.\r\n     *\r\n     * @param backupManager - The backup manager to use.\r\n     * @param olmMachine - The olm machine to use.\r\n     * @param http - The http instance to use.\r\n     * @param logger - The logger to use.\r\n     */\r\n    public constructor(\r\n        logger: Logger,\r\n        private readonly olmMachine: OlmMachine,\r\n        private readonly http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\r\n        private readonly backupManager: RustBackupManager,\r\n    ) {\r\n        this.logger = logger.getChild(\"[PerSessionKeyBackupDownloader]\");\r\n\r\n        backupManager.on(CryptoEvent.KeyBackupStatus, this.onBackupStatusChanged);\r\n        backupManager.on(CryptoEvent.KeyBackupFailed, this.onBackupStatusChanged);\r\n        backupManager.on(CryptoEvent.KeyBackupDecryptionKeyCached, this.onBackupStatusChanged);\r\n    }\r\n\r\n    /**\r\n     * Check if key download is successfully configured and active.\r\n     *\r\n     * @return `true` if key download is correctly configured and active; otherwise `false`.\r\n     */\r\n    public isKeyBackupDownloadConfigured(): boolean {\r\n        return this.configuration !== null;\r\n    }\r\n\r\n    /**\r\n     * Return the details of the latest backup on the server, when we last checked.\r\n     *\r\n     * This is just a convenience method to expose {@link RustBackupManager.getServerBackupInfo}.\r\n     */\r\n    public async getServerBackupInfo(): Promise<KeyBackupInfo | null | undefined> {\r\n        return await this.backupManager.getServerBackupInfo();\r\n    }\r\n\r\n    /**\r\n     * Called when a MissingRoomKey or UnknownMessageIndex decryption error is encountered.\r\n     *\r\n     * This will try to download the key from the backup if there is a trusted active backup.\r\n     * In case of success the key will be imported and the onRoomKeysUpdated callback will be called\r\n     * internally by the rust-sdk and decryption will be retried.\r\n     *\r\n     * @param roomId - The room ID of the room where the error occurred.\r\n     * @param megolmSessionId - The megolm session ID that is missing.\r\n     */\r\n    public onDecryptionKeyMissingError(roomId: string, megolmSessionId: string): void {\r\n        // Several messages encrypted with the same session may be decrypted at the same time,\r\n        // so we need to be resistant and not query several time the same session.\r\n        if (this.isAlreadyInQueue(roomId, megolmSessionId)) {\r\n            // There is already a request queued for this session, no need to queue another one.\r\n            this.logger.trace(`Not checking key backup for session ${megolmSessionId} as it is already queued`);\r\n            return;\r\n        }\r\n\r\n        if (this.wasRequestedRecently(megolmSessionId)) {\r\n            // We already tried to download this session recently and it was not in backup, no need to try again.\r\n            this.logger.trace(\r\n                `Not checking key backup for session ${megolmSessionId} as it was already requested recently`,\r\n            );\r\n            return;\r\n        }\r\n\r\n        // We always add the request to the queue, even if we have a configuration problem (can't access backup).\r\n        // This is to make sure that if the configuration problem is resolved, we will try to download the key.\r\n        // This will happen after an initial sync, at this point the backup will not yet be trusted and the decryption\r\n        // key will not be available, but it will be just after the verification.\r\n        // We don't need to persist it because currently on refresh the sdk will retry to decrypt the messages in error.\r\n        this.queuedRequests.push({ roomId, megolmSessionId });\r\n\r\n        // Start the download loop if it's not already running.\r\n        this.downloadKeysLoop();\r\n    }\r\n\r\n    public stop(): void {\r\n        this.stopped = true;\r\n        this.backupManager.off(CryptoEvent.KeyBackupStatus, this.onBackupStatusChanged);\r\n        this.backupManager.off(CryptoEvent.KeyBackupFailed, this.onBackupStatusChanged);\r\n        this.backupManager.off(CryptoEvent.KeyBackupDecryptionKeyCached, this.onBackupStatusChanged);\r\n    }\r\n\r\n    /**\r\n     * Called when the backup status changes (CryptoEvents)\r\n     * This will trigger a check of the backup configuration.\r\n     */\r\n    private onBackupStatusChanged = (): void => {\r\n        // we want to force check configuration, so we clear the current one.\r\n        this.hasConfigurationProblem = false;\r\n        this.configuration = null;\r\n        this.getOrCreateBackupConfiguration().then((configuration) => {\r\n            if (configuration) {\r\n                // restart the download loop if it was stopped\r\n                this.downloadKeysLoop();\r\n            }\r\n        });\r\n    };\r\n\r\n    /** Returns true if the megolm session is already queued for download. */\r\n    private isAlreadyInQueue(roomId: string, megolmSessionId: string): boolean {\r\n        return this.queuedRequests.some((info) => {\r\n            return info.roomId == roomId && info.megolmSessionId == megolmSessionId;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Marks the session as not found in backup, to avoid retrying to soon for a key not in backup\r\n     *\r\n     * @param megolmSessionId - The megolm session ID that is missing.\r\n     */\r\n    private markAsNotFoundInBackup(megolmSessionId: string): void {\r\n        const now = Date.now();\r\n        this.sessionLastCheckAttemptedTime.set(megolmSessionId, now);\r\n        // if too big make some cleaning to keep under control\r\n        if (this.sessionLastCheckAttemptedTime.size > 100) {\r\n            this.sessionLastCheckAttemptedTime = new Map(\r\n                Array.from(this.sessionLastCheckAttemptedTime).filter((sid, ts) => {\r\n                    return Math.max(now - ts, 0) < KEY_BACKUP_BACKOFF;\r\n                }),\r\n            );\r\n        }\r\n    }\r\n\r\n    /** Returns true if the session was requested recently. */\r\n    private wasRequestedRecently(megolmSessionId: string): boolean {\r\n        const lastCheck = this.sessionLastCheckAttemptedTime.get(megolmSessionId);\r\n        if (!lastCheck) return false;\r\n        return Math.max(Date.now() - lastCheck, 0) < KEY_BACKUP_BACKOFF;\r\n    }\r\n\r\n    private async getBackupDecryptionKey(): Promise<RustSdkCryptoJs.BackupKeys | null> {\r\n        try {\r\n            return await this.olmMachine.getBackupKeys();\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Requests a key from the server side backup.\r\n     *\r\n     * @param version - The backup version to use.\r\n     * @param roomId - The room ID of the room where the error occurred.\r\n     * @param sessionId - The megolm session ID that is missing.\r\n     */\r\n    private async requestRoomKeyFromBackup(\r\n        version: string,\r\n        roomId: string,\r\n        sessionId: string,\r\n    ): Promise<KeyBackupSession> {\r\n        const path = encodeUri(\"/room_keys/keys/$roomId/$sessionId\", {\r\n            $roomId: roomId,\r\n            $sessionId: sessionId,\r\n        });\r\n\r\n        return await this.http.authedRequest<KeyBackupSession>(Method.Get, path, { version }, undefined, {\r\n            prefix: ClientPrefix.V3,\r\n        });\r\n    }\r\n\r\n    private async downloadKeysLoop(): Promise<void> {\r\n        if (this.downloadLoopRunning) return;\r\n\r\n        // If we have a configuration problem, we don't want to try to download.\r\n        // If any configuration change is detected, we will retry and restart the loop.\r\n        if (this.hasConfigurationProblem) return;\r\n\r\n        this.downloadLoopRunning = true;\r\n\r\n        try {\r\n            while (this.queuedRequests.length > 0) {\r\n                // we just peek the first one without removing it, so if a new request for same key comes in while we're\r\n                // processing this one, it won't queue another request.\r\n                const request = this.queuedRequests[0];\r\n                try {\r\n                    // The backup could have changed between the time we queued the request and now, so we need to check\r\n                    const configuration = await this.getOrCreateBackupConfiguration();\r\n                    if (!configuration) {\r\n                        // Backup is not configured correctly, so stop the loop.\r\n                        this.downloadLoopRunning = false;\r\n                        return;\r\n                    }\r\n\r\n                    const result = await this.queryKeyBackup(request.roomId, request.megolmSessionId, configuration);\r\n\r\n                    if (this.stopped) {\r\n                        return;\r\n                    }\r\n                    // We got the encrypted key from backup, let's try to decrypt and import it.\r\n                    try {\r\n                        await this.decryptAndImport(request, result, configuration);\r\n                    } catch (e) {\r\n                        this.logger.error(\r\n                            `Error while decrypting and importing key backup for session ${request.megolmSessionId}`,\r\n                            e,\r\n                        );\r\n                    }\r\n                    // now remove the request from the queue as we've processed it.\r\n                    this.queuedRequests.shift();\r\n                } catch (err) {\r\n                    if (err instanceof KeyDownloadError) {\r\n                        switch (err.code) {\r\n                            case KeyDownloadErrorCode.MISSING_DECRYPTION_KEY:\r\n                                this.markAsNotFoundInBackup(request.megolmSessionId);\r\n                                // continue for next one\r\n                                this.queuedRequests.shift();\r\n                                break;\r\n                            case KeyDownloadErrorCode.NETWORK_ERROR:\r\n                                // We don't want to hammer if there is a problem, so wait a bit.\r\n                                await sleep(KEY_BACKUP_BACKOFF);\r\n                                break;\r\n                            case KeyDownloadErrorCode.STOPPED:\r\n                                // If the downloader was stopped, we don't want to retry.\r\n                                this.downloadLoopRunning = false;\r\n                                return;\r\n                        }\r\n                    } else if (err instanceof KeyDownloadRateLimitError) {\r\n                        // we want to retry after the backoff time\r\n                        await sleep(err.retryMillis);\r\n                    }\r\n                }\r\n            }\r\n        } finally {\r\n            // all pending request have been processed, we can stop the loop.\r\n            this.downloadLoopRunning = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Query the backup for a key.\r\n     *\r\n     * @param targetRoomId - ID of the room that the session is used in.\r\n     * @param targetSessionId - ID of the session for which to check backup.\r\n     * @param configuration - The backup configuration to use.\r\n     */\r\n    private async queryKeyBackup(\r\n        targetRoomId: string,\r\n        targetSessionId: string,\r\n        configuration: Configuration,\r\n    ): Promise<KeyBackupSession> {\r\n        this.logger.debug(`Checking key backup for session ${targetSessionId}`);\r\n        if (this.stopped) throw new KeyDownloadError(KeyDownloadErrorCode.STOPPED);\r\n        try {\r\n            const res = await this.requestRoomKeyFromBackup(configuration.backupVersion, targetRoomId, targetSessionId);\r\n            this.logger.debug(`Got key from backup for sessionId:${targetSessionId}`);\r\n            return res;\r\n        } catch (e) {\r\n            if (this.stopped) throw new KeyDownloadError(KeyDownloadErrorCode.STOPPED);\r\n\r\n            this.logger.info(`No luck requesting key backup for session ${targetSessionId}: ${e}`);\r\n            if (e instanceof MatrixError) {\r\n                const errCode = e.data.errcode;\r\n                if (errCode == \"M_NOT_FOUND\") {\r\n                    // Unfortunately the spec doesn't give us a way to differentiate between a missing key and a wrong version.\r\n                    // Synapse will return:\r\n                    //     - \"error\": \"Unknown backup version\" if the version is wrong.\r\n                    //     - \"error\": \"No room_keys found\" if the key is missing.\r\n                    // It's useful to know if the key is missing or if the version is wrong.\r\n                    // As it's not spec'ed, we fall back on considering the key is not in backup.\r\n                    // Notice that this request will be lost if instead the backup got out of sync (updated from other session).\r\n                    throw new KeyDownloadError(KeyDownloadErrorCode.MISSING_DECRYPTION_KEY);\r\n                }\r\n                if (errCode == \"M_LIMIT_EXCEEDED\") {\r\n                    const waitTime = e.data.retry_after_ms;\r\n                    if (waitTime > 0) {\r\n                        this.logger.info(`Rate limited by server, waiting ${waitTime}ms`);\r\n                        throw new KeyDownloadRateLimitError(waitTime);\r\n                    } else {\r\n                        // apply the default backoff time\r\n                        throw new KeyDownloadRateLimitError(KEY_BACKUP_BACKOFF);\r\n                    }\r\n                }\r\n            }\r\n            throw new KeyDownloadError(KeyDownloadErrorCode.NETWORK_ERROR);\r\n        }\r\n    }\r\n\r\n    private async decryptAndImport(\r\n        sessionInfo: SessionInfo,\r\n        data: KeyBackupSession,\r\n        configuration: Configuration,\r\n    ): Promise<void> {\r\n        const sessionsToImport: Record<string, KeyBackupSession> = { [sessionInfo.megolmSessionId]: data };\r\n\r\n        const keys = await configuration!.decryptor.decryptSessions(sessionsToImport);\r\n        for (const k of keys) {\r\n            k.room_id = sessionInfo.roomId;\r\n        }\r\n        await this.backupManager.importBackedUpRoomKeys(keys, configuration.backupVersion);\r\n    }\r\n\r\n    /**\r\n     * Gets the current backup configuration or create one if it doesn't exist.\r\n     *\r\n     * When a valid configuration is found it is cached and returned for subsequent calls.\r\n     * Otherwise, if a check is forced or a check has not yet been done, a new check is done.\r\n     *\r\n     * @returns The backup configuration to use or null if there is a configuration problem.\r\n     */\r\n    private async getOrCreateBackupConfiguration(): Promise<Configuration | null> {\r\n        if (this.configuration) {\r\n            return this.configuration;\r\n        }\r\n\r\n        // We already tried to check the configuration and it failed.\r\n        // We don't want to try again immediately, we will retry if a configuration change is detected.\r\n        if (this.hasConfigurationProblem) {\r\n            return null;\r\n        }\r\n\r\n        // This method can be called rapidly by several emitted CryptoEvent, so we need to make sure that we don't\r\n        // query the server several times.\r\n        if (this.currentBackupVersionCheck != null) {\r\n            this.logger.debug(`Already checking server version, use current promise`);\r\n            return await this.currentBackupVersionCheck;\r\n        }\r\n\r\n        this.currentBackupVersionCheck = this.internalCheckFromServer();\r\n        try {\r\n            return await this.currentBackupVersionCheck;\r\n        } finally {\r\n            this.currentBackupVersionCheck = null;\r\n        }\r\n    }\r\n\r\n    private async internalCheckFromServer(): Promise<Configuration | null> {\r\n        let currentServerVersion = null;\r\n        try {\r\n            currentServerVersion = await this.backupManager.getServerBackupInfo();\r\n        } catch (e) {\r\n            this.logger.debug(`Backup: error while checking server version: ${e}`);\r\n            this.hasConfigurationProblem = true;\r\n            return null;\r\n        }\r\n        this.logger.debug(`Got current backup version from server: ${currentServerVersion?.version}`);\r\n\r\n        if (currentServerVersion?.algorithm != \"m.megolm_backup.v1.curve25519-aes-sha2\") {\r\n            this.logger.info(`Unsupported algorithm ${currentServerVersion?.algorithm}`);\r\n            this.hasConfigurationProblem = true;\r\n            return null;\r\n        }\r\n\r\n        if (!currentServerVersion?.version) {\r\n            this.logger.info(`No current key backup`);\r\n            this.hasConfigurationProblem = true;\r\n            return null;\r\n        }\r\n\r\n        const activeVersion = await this.backupManager.getActiveBackupVersion();\r\n        if (activeVersion == null || currentServerVersion.version != activeVersion) {\r\n            // Either the current backup version on server side is not trusted, or it is out of sync with the active version on the client side.\r\n            this.logger.info(\r\n                `The current backup version on the server (${currentServerVersion.version}) is not trusted. Version we are currently backing up to: ${activeVersion}`,\r\n            );\r\n            this.hasConfigurationProblem = true;\r\n            return null;\r\n        }\r\n\r\n        const authData = currentServerVersion.auth_data as Curve25519AuthData;\r\n\r\n        const backupKeys = await this.getBackupDecryptionKey();\r\n        if (!backupKeys?.decryptionKey) {\r\n            this.logger.debug(`Not checking key backup for session (no decryption key)`);\r\n            this.hasConfigurationProblem = true;\r\n            return null;\r\n        }\r\n\r\n        if (activeVersion != backupKeys.backupVersion) {\r\n            this.logger.debug(\r\n                `Version for which we have a decryption key (${backupKeys.backupVersion}) doesn't match the version we are backing up to (${activeVersion})`,\r\n            );\r\n            this.hasConfigurationProblem = true;\r\n            return null;\r\n        }\r\n\r\n        if (authData.public_key != backupKeys.decryptionKey.megolmV1PublicKey.publicKeyBase64) {\r\n            this.logger.debug(`getBackupDecryptor key mismatch error`);\r\n            this.hasConfigurationProblem = true;\r\n            return null;\r\n        }\r\n\r\n        const backupDecryptor = this.backupManager.createBackupDecryptor(backupKeys.decryptionKey);\r\n        this.hasConfigurationProblem = false;\r\n        this.configuration = {\r\n            decryptor: backupDecryptor,\r\n            backupVersion: activeVersion,\r\n        };\r\n        return this.configuration;\r\n    }\r\n}\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { Device, DeviceVerification } from \"../models/device\";\r\nimport { DeviceKeys } from \"../client\";\r\n\r\n/**\r\n * Convert a {@link RustSdkCryptoJs.Device} to a {@link Device}\r\n * @param device - Rust Sdk device\r\n * @param userId - owner of the device\r\n *\r\n * @internal\r\n */\r\nexport function rustDeviceToJsDevice(device: RustSdkCryptoJs.Device, userId: RustSdkCryptoJs.UserId): Device {\r\n    // Copy rust device keys to Device.keys\r\n    const keys = new Map<string, string>();\r\n    for (const [keyId, key] of device.keys.entries()) {\r\n        keys.set(keyId.toString(), key.toBase64());\r\n    }\r\n\r\n    // Compute verified from device state\r\n    let verified: DeviceVerification = DeviceVerification.Unverified;\r\n    if (device.isBlacklisted()) {\r\n        verified = DeviceVerification.Blocked;\r\n    } else if (device.isVerified()) {\r\n        verified = DeviceVerification.Verified;\r\n    }\r\n\r\n    // Convert rust signatures to Device.signatures\r\n    const signatures = new Map<string, Map<string, string>>();\r\n    const mayBeSignatureMap: Map<string, RustSdkCryptoJs.MaybeSignature> | undefined = device.signatures.get(userId);\r\n    if (mayBeSignatureMap) {\r\n        const convertedSignatures = new Map<string, string>();\r\n        // Convert maybeSignatures map to a Map<string, string>\r\n        for (const [key, value] of mayBeSignatureMap.entries()) {\r\n            if (value.isValid() && value.signature) {\r\n                convertedSignatures.set(key, value.signature.toBase64());\r\n            }\r\n        }\r\n\r\n        signatures.set(userId.toString(), convertedSignatures);\r\n    }\r\n\r\n    // Convert rust algorithms to algorithms\r\n    const rustAlgorithms: RustSdkCryptoJs.EncryptionAlgorithm[] = device.algorithms;\r\n    // Use set to ensure that algorithms are not duplicated\r\n    const algorithms = new Set<string>();\r\n    rustAlgorithms.forEach((algorithm) => {\r\n        switch (algorithm) {\r\n            case RustSdkCryptoJs.EncryptionAlgorithm.MegolmV1AesSha2:\r\n                algorithms.add(\"m.megolm.v1.aes-sha2\");\r\n                break;\r\n            case RustSdkCryptoJs.EncryptionAlgorithm.OlmV1Curve25519AesSha2:\r\n            default:\r\n                algorithms.add(\"m.olm.v1.curve25519-aes-sha2\");\r\n                break;\r\n        }\r\n    });\r\n\r\n    return new Device({\r\n        deviceId: device.deviceId.toString(),\r\n        userId: userId.toString(),\r\n        keys,\r\n        algorithms: Array.from(algorithms),\r\n        verified,\r\n        signatures,\r\n        displayName: device.displayName,\r\n        dehydrated: device.isDehydrated,\r\n    });\r\n}\r\n\r\n/**\r\n * Convert {@link DeviceKeys}  from `/keys/query` request to a `Map<string, Device>`\r\n * @param deviceKeys - Device keys object to convert\r\n *\r\n * @internal\r\n */\r\nexport function deviceKeysToDeviceMap(deviceKeys: DeviceKeys): Map<string, Device> {\r\n    return new Map(\r\n        Object.entries(deviceKeys).map(([deviceId, device]) => [deviceId, downloadDeviceToJsDevice(device)]),\r\n    );\r\n}\r\n\r\n// Device from `/keys/query` request\r\ntype QueryDevice = DeviceKeys[keyof DeviceKeys];\r\n\r\n/**\r\n * Convert `/keys/query` {@link QueryDevice} device to {@link Device}\r\n * @param device - Device from `/keys/query` request\r\n *\r\n * @internal\r\n */\r\nexport function downloadDeviceToJsDevice(device: QueryDevice): Device {\r\n    const keys = new Map(Object.entries(device.keys));\r\n    const displayName = device.unsigned?.device_display_name;\r\n\r\n    const signatures = new Map<string, Map<string, string>>();\r\n    if (device.signatures) {\r\n        for (const userId in device.signatures) {\r\n            signatures.set(userId, new Map(Object.entries(device.signatures[userId])));\r\n        }\r\n    }\r\n\r\n    return new Device({\r\n        deviceId: device.device_id,\r\n        userId: device.user_id,\r\n        keys,\r\n        algorithms: device.algorithms,\r\n        verified: DeviceVerification.Unverified,\r\n        signatures,\r\n        displayName,\r\n    });\r\n}\r\n","/*\r\nCopyright 2023-2024 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { Logger } from \"../logger\";\r\nimport { CryptoStore, MigrationState, SecretStorePrivateKeys } from \"../crypto/store/base\";\r\nimport { IndexedDBCryptoStore } from \"../crypto/store/indexeddb-crypto-store\";\r\nimport { decryptAES, IEncryptedPayload } from \"../crypto/aes\";\r\nimport { IHttpOpts, MatrixHttpApi } from \"../http-api\";\r\nimport { requestKeyBackupVersion } from \"./backup\";\r\nimport { IRoomEncryption } from \"../crypto/RoomList\";\r\nimport { CrossSigningKeyInfo, Curve25519AuthData } from \"../crypto-api\";\r\nimport { RustCrypto } from \"./rust-crypto\";\r\nimport { KeyBackupInfo } from \"../crypto-api/keybackup\";\r\nimport { sleep } from \"../utils\";\r\nimport { encodeBase64 } from \"../base64\";\r\n\r\n/**\r\n * Determine if any data needs migrating from the legacy store, and do so.\r\n *\r\n * This migrates the base account data, and olm and megolm sessions. It does *not* migrate the room list, which should\r\n * happen after an `OlmMachine` is created, via {@link migrateRoomSettingsFromLegacyCrypto}.\r\n *\r\n * @param args - Arguments object.\r\n */\r\nexport async function migrateFromLegacyCrypto(args: {\r\n    /** A `Logger` instance that will be used for debug output. */\r\n    logger: Logger;\r\n\r\n    /**\r\n     * Low-level HTTP interface: used to make outgoing requests required by the rust SDK.\r\n     * We expect it to set the access token, etc.\r\n     */\r\n    http: MatrixHttpApi<IHttpOpts & { onlyData: true }>;\r\n\r\n    /** Store to migrate data from. */\r\n    legacyStore: CryptoStore;\r\n\r\n    /** Pickle key for `legacyStore`. */\r\n    legacyPickleKey?: string;\r\n\r\n    /** Local user's User ID. */\r\n    userId: string;\r\n\r\n    /** Local user's Device ID. */\r\n    deviceId: string;\r\n\r\n    /** Rust crypto store to migrate data into. */\r\n    storeHandle: RustSdkCryptoJs.StoreHandle;\r\n\r\n    /**\r\n     * A callback which will receive progress updates on migration from `legacyStore`.\r\n     *\r\n     * Called with (-1, -1) to mark the end of migration.\r\n     */\r\n    legacyMigrationProgressListener?: (progress: number, total: number) => void;\r\n}): Promise<void> {\r\n    const { logger, legacyStore } = args;\r\n\r\n    // initialise the rust matrix-sdk-crypto-wasm, if it hasn't already been done\r\n    await RustSdkCryptoJs.initAsync();\r\n\r\n    // enable tracing in the rust-sdk\r\n    new RustSdkCryptoJs.Tracing(RustSdkCryptoJs.LoggerLevel.Debug).turnOn();\r\n\r\n    if (!(await legacyStore.containsData())) {\r\n        // This store was never used. Nothing to migrate.\r\n        return;\r\n    }\r\n\r\n    await legacyStore.startup();\r\n\r\n    let accountPickle: string | null = null;\r\n    await legacyStore.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\r\n        legacyStore.getAccount(txn, (acctPickle) => {\r\n            accountPickle = acctPickle;\r\n        });\r\n    });\r\n    if (!accountPickle) {\r\n        // This store is not properly set up. Nothing to migrate.\r\n        logger.debug(\"Legacy crypto store is not set up (no account found). Not migrating.\");\r\n        return;\r\n    }\r\n\r\n    let migrationState = await legacyStore.getMigrationState();\r\n\r\n    if (migrationState >= MigrationState.MEGOLM_SESSIONS_MIGRATED) {\r\n        // All migration is done for now. The room list comes later, once we have an OlmMachine.\r\n        return;\r\n    }\r\n\r\n    const nOlmSessions = await countOlmSessions(logger, legacyStore);\r\n    const nMegolmSessions = await countMegolmSessions(logger, legacyStore);\r\n    const totalSteps = 1 + nOlmSessions + nMegolmSessions;\r\n    logger.info(\r\n        `Migrating data from legacy crypto store. ${nOlmSessions} olm sessions and ${nMegolmSessions} megolm sessions to migrate.`,\r\n    );\r\n\r\n    let stepsDone = 0;\r\n    function onProgress(steps: number): void {\r\n        stepsDone += steps;\r\n        args.legacyMigrationProgressListener?.(stepsDone, totalSteps);\r\n    }\r\n    onProgress(0);\r\n\r\n    const pickleKey = new TextEncoder().encode(args.legacyPickleKey);\r\n\r\n    if (migrationState === MigrationState.NOT_STARTED) {\r\n        logger.info(\"Migrating data from legacy crypto store. Step 1: base data\");\r\n        await migrateBaseData(args.http, args.userId, args.deviceId, legacyStore, pickleKey, args.storeHandle, logger);\r\n\r\n        migrationState = MigrationState.INITIAL_DATA_MIGRATED;\r\n        await legacyStore.setMigrationState(migrationState);\r\n    }\r\n    onProgress(1);\r\n\r\n    if (migrationState === MigrationState.INITIAL_DATA_MIGRATED) {\r\n        logger.info(\r\n            `Migrating data from legacy crypto store. Step 2: olm sessions (${nOlmSessions} sessions to migrate).`,\r\n        );\r\n        await migrateOlmSessions(logger, legacyStore, pickleKey, args.storeHandle, onProgress);\r\n\r\n        migrationState = MigrationState.OLM_SESSIONS_MIGRATED;\r\n        await legacyStore.setMigrationState(migrationState);\r\n    }\r\n\r\n    if (migrationState === MigrationState.OLM_SESSIONS_MIGRATED) {\r\n        logger.info(\r\n            `Migrating data from legacy crypto store. Step 3: megolm sessions (${nMegolmSessions} sessions to migrate).`,\r\n        );\r\n        await migrateMegolmSessions(logger, legacyStore, pickleKey, args.storeHandle, onProgress);\r\n\r\n        migrationState = MigrationState.MEGOLM_SESSIONS_MIGRATED;\r\n        await legacyStore.setMigrationState(migrationState);\r\n    }\r\n\r\n    // Migration is done.\r\n    args.legacyMigrationProgressListener?.(-1, -1);\r\n    logger.info(\"Migration from legacy crypto store complete\");\r\n}\r\n\r\nasync function migrateBaseData(\r\n    http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\r\n    userId: string,\r\n    deviceId: string,\r\n    legacyStore: CryptoStore,\r\n    pickleKey: Uint8Array,\r\n    storeHandle: RustSdkCryptoJs.StoreHandle,\r\n    logger: Logger,\r\n): Promise<void> {\r\n    const migrationData = new RustSdkCryptoJs.BaseMigrationData();\r\n    migrationData.userId = new RustSdkCryptoJs.UserId(userId);\r\n    migrationData.deviceId = new RustSdkCryptoJs.DeviceId(deviceId);\r\n\r\n    await legacyStore.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) =>\r\n        legacyStore.getAccount(txn, (a) => {\r\n            migrationData.pickledAccount = a ?? \"\";\r\n        }),\r\n    );\r\n\r\n    const recoveryKey = await getAndDecryptCachedSecretKey(legacyStore, pickleKey, \"m.megolm_backup.v1\");\r\n\r\n    // If we have a backup recovery key, we need to try to figure out which backup version it is for.\r\n    // All we can really do is ask the server for the most recent version and check if the cached key we have matches.\r\n    // It is possible that the backup has changed since last time his session was opened.\r\n    if (recoveryKey) {\r\n        let backupCallDone = false;\r\n        let backupInfo: KeyBackupInfo | null = null;\r\n        while (!backupCallDone) {\r\n            try {\r\n                backupInfo = await requestKeyBackupVersion(http);\r\n                backupCallDone = true;\r\n            } catch (e) {\r\n                logger.info(\"Failed to get backup version during migration, retrying in 2 seconds\", e);\r\n                // Retry until successful, use simple constant delay\r\n                await sleep(2000);\r\n            }\r\n        }\r\n        if (backupInfo && backupInfo.algorithm == \"m.megolm_backup.v1.curve25519-aes-sha2\") {\r\n            // check if the recovery key matches, as the active backup version may have changed since the key was cached\r\n            // and the migration started.\r\n            try {\r\n                const decryptionKey = RustSdkCryptoJs.BackupDecryptionKey.fromBase64(recoveryKey);\r\n                const publicKey = (backupInfo.auth_data as Curve25519AuthData)?.public_key;\r\n                const isValid = decryptionKey.megolmV1PublicKey.publicKeyBase64 == publicKey;\r\n                if (isValid) {\r\n                    migrationData.backupVersion = backupInfo.version;\r\n                    migrationData.backupRecoveryKey = recoveryKey;\r\n                } else {\r\n                    logger.debug(\r\n                        \"The backup key to migrate does not match the active backup version\",\r\n                        `Cached pub key: ${decryptionKey.megolmV1PublicKey.publicKeyBase64}`,\r\n                        `Active pub key: ${publicKey}`,\r\n                    );\r\n                }\r\n            } catch (e) {\r\n                logger.warn(\"Failed to check if the backup key to migrate matches the active backup version\", e);\r\n            }\r\n        }\r\n    }\r\n\r\n    migrationData.privateCrossSigningMasterKey = await getAndDecryptCachedSecretKey(legacyStore, pickleKey, \"master\");\r\n    migrationData.privateCrossSigningSelfSigningKey = await getAndDecryptCachedSecretKey(\r\n        legacyStore,\r\n        pickleKey,\r\n        \"self_signing\",\r\n    );\r\n    migrationData.privateCrossSigningUserSigningKey = await getAndDecryptCachedSecretKey(\r\n        legacyStore,\r\n        pickleKey,\r\n        \"user_signing\",\r\n    );\r\n    await RustSdkCryptoJs.Migration.migrateBaseData(migrationData, pickleKey, storeHandle);\r\n}\r\n\r\nasync function countOlmSessions(logger: Logger, legacyStore: CryptoStore): Promise<number> {\r\n    logger.debug(\"Counting olm sessions to be migrated\");\r\n    let nSessions: number;\r\n    await legacyStore.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_SESSIONS], (txn) =>\r\n        legacyStore.countEndToEndSessions(txn, (n) => (nSessions = n)),\r\n    );\r\n    return nSessions!;\r\n}\r\n\r\nasync function countMegolmSessions(logger: Logger, legacyStore: CryptoStore): Promise<number> {\r\n    logger.debug(\"Counting megolm sessions to be migrated\");\r\n    return await legacyStore.countEndToEndInboundGroupSessions();\r\n}\r\n\r\nasync function migrateOlmSessions(\r\n    logger: Logger,\r\n    legacyStore: CryptoStore,\r\n    pickleKey: Uint8Array,\r\n    storeHandle: RustSdkCryptoJs.StoreHandle,\r\n    onBatchDone: (batchSize: number) => void,\r\n): Promise<void> {\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n        const batch = await legacyStore.getEndToEndSessionsBatch();\r\n        if (batch === null) return;\r\n\r\n        logger.debug(`Migrating batch of ${batch.length} olm sessions`);\r\n        const migrationData: RustSdkCryptoJs.PickledSession[] = [];\r\n        for (const session of batch) {\r\n            const pickledSession = new RustSdkCryptoJs.PickledSession();\r\n            pickledSession.senderKey = session.deviceKey!;\r\n            pickledSession.pickle = session.session!;\r\n            pickledSession.lastUseTime = pickledSession.creationTime = new Date(session.lastReceivedMessageTs!);\r\n            migrationData.push(pickledSession);\r\n        }\r\n\r\n        await RustSdkCryptoJs.Migration.migrateOlmSessions(migrationData, pickleKey, storeHandle);\r\n        await legacyStore.deleteEndToEndSessionsBatch(batch);\r\n        onBatchDone(batch.length);\r\n    }\r\n}\r\n\r\nasync function migrateMegolmSessions(\r\n    logger: Logger,\r\n    legacyStore: CryptoStore,\r\n    pickleKey: Uint8Array,\r\n    storeHandle: RustSdkCryptoJs.StoreHandle,\r\n    onBatchDone: (batchSize: number) => void,\r\n): Promise<void> {\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n        const batch = await legacyStore.getEndToEndInboundGroupSessionsBatch();\r\n        if (batch === null) return;\r\n\r\n        logger.debug(`Migrating batch of ${batch.length} megolm sessions`);\r\n        const migrationData: RustSdkCryptoJs.PickledInboundGroupSession[] = [];\r\n        for (const session of batch) {\r\n            const sessionData = session.sessionData!;\r\n\r\n            const pickledSession = new RustSdkCryptoJs.PickledInboundGroupSession();\r\n            pickledSession.pickle = sessionData.session;\r\n            pickledSession.roomId = new RustSdkCryptoJs.RoomId(sessionData.room_id);\r\n            pickledSession.senderKey = session.senderKey;\r\n            pickledSession.senderSigningKey = sessionData.keysClaimed?.[\"ed25519\"];\r\n            pickledSession.backedUp = !session.needsBackup;\r\n\r\n            // The Rust SDK `imported` flag is used to indicate the authenticity status of a Megolm\r\n            // session, which tells us whether we can reliably tell which Olm device is the owner\r\n            // (creator) of the session.\r\n            //\r\n            // If `imported` is true, then we have no cryptographic proof that the session is owned\r\n            // by the device with the identity key `senderKey`.\r\n            //\r\n            // Only Megolm sessions received directly from the owning device via an encrypted\r\n            // `m.room_key` to-device message should have `imported` flag set to false. Megolm\r\n            // sessions received by any other currently available means (i.e. from a\r\n            // `m.forwarded_room_key`, from v1 asymmetric server-side key backup, imported from a\r\n            // file, etc) should have the `imported` flag set to true.\r\n            //\r\n            // Messages encrypted with such Megolm sessions will have a grey shield in the UI\r\n            // (\"Authenticity of this message cannot be guaranteed\").\r\n            //\r\n            // However, we don't want to bluntly mark all sessions as `imported` during migration\r\n            // because users will suddenly start seeing all their historic messages decorated with a\r\n            // grey shield, which would be seen as a non-actionable regression.\r\n            //\r\n            // In the legacy crypto stack, the flag encoding similar information was called\r\n            // `InboundGroupSessionData.untrusted`. The value of this flag was set as follows:\r\n            //\r\n            // - For outbound Megolm sessions created by our own device, `untrusted` is `undefined`.\r\n            // - For Megolm sessions received via a `m.room_key` to-device message, `untrusted` is\r\n            //   `undefined`.\r\n            // - For Megolm sessions received via a `m.forwarded_room_key` to-device message,\r\n            //   `untrusted` is `true`.\r\n            // - For Megolm sessions imported from a (v1 asymmetric / \"legacy\") server-side key\r\n            //   backup, `untrusted` is `true`.\r\n            // - For Megolm sessions imported from a file, untrusted is `undefined`.\r\n            //\r\n            // The main difference between the legacy crypto stack and the Rust crypto stack is that\r\n            // the Rust stack considers sessions imported from a file as `imported` (not\r\n            // authenticated). This is because the Megolm session export file format does not\r\n            // encode this authenticity information.\r\n            //\r\n            // Given this migration is only a one-time thing, we make a concession to accept the\r\n            // loss of information in this case, to avoid degrading UX in a non-actionable way.\r\n            pickledSession.imported = sessionData.untrusted === true;\r\n\r\n            migrationData.push(pickledSession);\r\n        }\r\n\r\n        await RustSdkCryptoJs.Migration.migrateMegolmSessions(migrationData, pickleKey, storeHandle);\r\n        await legacyStore.deleteEndToEndInboundGroupSessionsBatch(batch);\r\n        onBatchDone(batch.length);\r\n    }\r\n}\r\n\r\n/**\r\n * Determine if any room settings need migrating from the legacy store, and do so.\r\n *\r\n * @param args - Arguments object.\r\n */\r\nexport async function migrateRoomSettingsFromLegacyCrypto({\r\n    logger,\r\n    legacyStore,\r\n    olmMachine,\r\n}: {\r\n    /** A `Logger` instance that will be used for debug output. */\r\n    logger: Logger;\r\n\r\n    /** Store to migrate data from. */\r\n    legacyStore: CryptoStore;\r\n\r\n    /** OlmMachine to store the new data on. */\r\n    olmMachine: RustSdkCryptoJs.OlmMachine;\r\n}): Promise<void> {\r\n    if (!(await legacyStore.containsData())) {\r\n        // This store was never used. Nothing to migrate.\r\n        return;\r\n    }\r\n\r\n    const migrationState = await legacyStore.getMigrationState();\r\n\r\n    if (migrationState >= MigrationState.ROOM_SETTINGS_MIGRATED) {\r\n        // We've already migrated the room settings.\r\n        return;\r\n    }\r\n\r\n    let rooms: Record<string, IRoomEncryption> = {};\r\n\r\n    await legacyStore.doTxn(\"readwrite\", [IndexedDBCryptoStore.STORE_ROOMS], (txn) => {\r\n        legacyStore.getEndToEndRooms(txn, (result) => {\r\n            rooms = result;\r\n        });\r\n    });\r\n\r\n    logger.debug(`Migrating ${Object.keys(rooms).length} sets of room settings`);\r\n    for (const [roomId, legacySettings] of Object.entries(rooms)) {\r\n        try {\r\n            const rustSettings = new RustSdkCryptoJs.RoomSettings();\r\n\r\n            if (legacySettings.algorithm !== \"m.megolm.v1.aes-sha2\") {\r\n                logger.warn(`Room ${roomId}: ignoring room with invalid algorithm ${legacySettings.algorithm}`);\r\n                continue;\r\n            }\r\n            rustSettings.algorithm = RustSdkCryptoJs.EncryptionAlgorithm.MegolmV1AesSha2;\r\n            rustSettings.sessionRotationPeriodMs = legacySettings.rotation_period_ms;\r\n            rustSettings.sessionRotationPeriodMessages = legacySettings.rotation_period_msgs;\r\n            await olmMachine.setRoomSettings(new RustSdkCryptoJs.RoomId(roomId), rustSettings);\r\n\r\n            // We don't attempt to clear out the settings from the old store, or record where we've gotten up to,\r\n            // which means that if the app gets restarted while we're in the middle of this migration, we'll start\r\n            // again from scratch. So be it. Given that legacy crypto loads the whole room list into memory on startup\r\n            // anyway, we know it can't be that big.\r\n        } catch (e) {\r\n            logger.warn(`Room ${roomId}: ignoring settings ${JSON.stringify(legacySettings)} which caused error ${e}`);\r\n        }\r\n    }\r\n\r\n    logger.debug(`Completed room settings migration`);\r\n    await legacyStore.setMigrationState(MigrationState.ROOM_SETTINGS_MIGRATED);\r\n}\r\n\r\nasync function getAndDecryptCachedSecretKey(\r\n    legacyStore: CryptoStore,\r\n    legacyPickleKey: Uint8Array,\r\n    name: string,\r\n): Promise<string | undefined> {\r\n    const key = await new Promise<any>((resolve) => {\r\n        legacyStore.doTxn(\"readonly\", [IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {\r\n            legacyStore.getSecretStorePrivateKey(txn, resolve, name as keyof SecretStorePrivateKeys);\r\n        });\r\n    });\r\n\r\n    if (key && key.ciphertext && key.iv && key.mac) {\r\n        return await decryptAES(key as IEncryptedPayload, legacyPickleKey, name);\r\n    } else if (key instanceof Uint8Array) {\r\n        // This is a legacy backward compatibility case where the key was stored in clear.\r\n        return encodeBase64(key);\r\n    } else {\r\n        return undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Check if the user's published identity (ie, public cross-signing keys) was trusted by the legacy session,\r\n * and if so mark it as trusted in the Rust session if needed.\r\n *\r\n * By default, if the legacy session didn't have the private MSK, the migrated session will revert to unverified,\r\n * even if the user has verified the session in the past.\r\n *\r\n * This only occurs if the private MSK was not cached in the crypto store (USK and SSK private keys won't help\r\n * to establish trust: the trust is rooted in the MSK).\r\n *\r\n * Rust crypto will only consider the current session as trusted if we import the private MSK itself.\r\n *\r\n * We could prompt the user to verify the session again, but it's probably better to just mark the user identity\r\n * as locally verified if it was before.\r\n *\r\n * See https://github.com/element-hq/element-web/issues/27079\r\n *\r\n * @param args - Argument object.\r\n */\r\nexport async function migrateLegacyLocalTrustIfNeeded(args: {\r\n    /** The legacy crypto store that is migrated. */\r\n    legacyCryptoStore: CryptoStore;\r\n    /** The migrated rust crypto stack. */\r\n    rustCrypto: RustCrypto;\r\n    /** The logger to use */\r\n    logger: Logger;\r\n}): Promise<void> {\r\n    const { legacyCryptoStore, rustCrypto, logger } = args;\r\n    // Get the public cross-signing identity from rust.\r\n    const rustOwnIdentity = await rustCrypto.getOwnIdentity();\r\n    if (!rustOwnIdentity) {\r\n        // There are no cross-signing keys published server side, so nothing to do here.\r\n        return;\r\n    }\r\n    if (rustOwnIdentity.isVerified()) {\r\n        // The rust session already trusts the keys, so again, nothing to do.\r\n        return;\r\n    }\r\n\r\n    const legacyLocallyTrustedMSK = await getLegacyTrustedPublicMasterKeyBase64(legacyCryptoStore);\r\n    if (!legacyLocallyTrustedMSK) {\r\n        // The user never verified their identity in the legacy session, so nothing to do.\r\n        return;\r\n    }\r\n\r\n    const mskInfo: CrossSigningKeyInfo = JSON.parse(rustOwnIdentity.masterKey);\r\n    if (!mskInfo.keys || Object.keys(mskInfo.keys).length === 0) {\r\n        // This should not happen, but let's be safe\r\n        logger.error(\"Post Migration | Unexpected error: no master key in the rust session.\");\r\n        return;\r\n    }\r\n    const rustSeenMSK = Object.values(mskInfo.keys)[0];\r\n\r\n    if (rustSeenMSK && rustSeenMSK == legacyLocallyTrustedMSK) {\r\n        logger.info(`Post Migration: Migrating legacy trusted MSK: ${legacyLocallyTrustedMSK} to locally verified.`);\r\n        // Let's mark the user identity as locally verified as part of the migration.\r\n        await rustOwnIdentity!.verify();\r\n        // As well as marking the MSK as trusted, `OlmMachine.verify` returns a\r\n        // `SignatureUploadRequest` which will publish a signature of the MSK using\r\n        // this device. In this case, we ignore the request: since the user hasn't\r\n        // actually re-verified the MSK, we don't publish a new signature. (`.verify`\r\n        // doesn't store the signature, and if we drop the request here it won't be\r\n        // retried.)\r\n        //\r\n        // Not publishing the signature is consistent with the behaviour of\r\n        // matrix-crypto-sdk when the private key is imported via\r\n        // `importCrossSigningKeys`, and when the identity is verified via interactive\r\n        // verification.\r\n        //\r\n        // [Aside: device signatures on the MSK are not considered by the rust-sdk to\r\n        // establish the trust of the user identity so in any case, what we actually do\r\n        // here is somewhat moot.]\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the legacy store has a trusted public master key, and returns it if so.\r\n *\r\n * @param legacyStore - The legacy store to check.\r\n *\r\n * @returns `null` if there were no cross signing keys or if they were not trusted. The trusted public master key if it was.\r\n */\r\nasync function getLegacyTrustedPublicMasterKeyBase64(legacyStore: CryptoStore): Promise<string | null> {\r\n    let maybeTrustedKeys: string | null = null;\r\n    await legacyStore.doTxn(\"readonly\", \"account\", (txn) => {\r\n        legacyStore.getCrossSigningKeys(txn, (keys) => {\r\n            // can be an empty object after resetting cross-signing keys, see storeTrustedSelfKeys\r\n            const msk = keys?.master;\r\n            if (msk && Object.keys(msk.keys).length != 0) {\r\n                // `msk.keys` is an object with { [`ed25519:${pubKey}`]: pubKey }\r\n                maybeTrustedKeys = Object.values(msk.keys)[0];\r\n            }\r\n        });\r\n    });\r\n\r\n    return maybeTrustedKeys;\r\n}\r\n","/*\r\nCopyright 2022 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\nimport { StoreHandle } from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { RustCrypto } from \"./rust-crypto\";\r\nimport { IHttpOpts, MatrixHttpApi } from \"../http-api\";\r\nimport { ServerSideSecretStorage } from \"../secret-storage\";\r\nimport { ICryptoCallbacks } from \"../crypto\";\r\nimport { Logger } from \"../logger\";\r\nimport { CryptoStore, MigrationState } from \"../crypto/store/base\";\r\nimport {\r\n    migrateFromLegacyCrypto,\r\n    migrateLegacyLocalTrustIfNeeded,\r\n    migrateRoomSettingsFromLegacyCrypto,\r\n} from \"./libolm_migration\";\r\n\r\n/**\r\n * Create a new `RustCrypto` implementation\r\n *\r\n * @param args - Parameter object\r\n * @internal\r\n */\r\nexport async function initRustCrypto(args: {\r\n    /** A `Logger` instance that will be used for debug output. */\r\n    logger: Logger;\r\n\r\n    /**\r\n     * Low-level HTTP interface: used to make outgoing requests required by the rust SDK.\r\n     * We expect it to set the access token, etc.\r\n     */\r\n    http: MatrixHttpApi<IHttpOpts & { onlyData: true }>;\r\n\r\n    /** The local user's User ID. */\r\n    userId: string;\r\n\r\n    /** The local user's Device ID. */\r\n    deviceId: string;\r\n\r\n    /** Interface to server-side secret storage. */\r\n    secretStorage: ServerSideSecretStorage;\r\n\r\n    /** Crypto callbacks provided by the application. */\r\n    cryptoCallbacks: ICryptoCallbacks;\r\n\r\n    /**\r\n     * The prefix to use on the indexeddbs created by rust-crypto.\r\n     * If `null`, a memory store will be used.\r\n     */\r\n    storePrefix: string | null;\r\n\r\n    /**\r\n     * A passphrase to use to encrypt the indexeddb created by rust-crypto.\r\n     *\r\n     * Ignored if `storePrefix` is null, or `storeKey` is set.  If neither this nor `storeKey` is set\r\n     * (and `storePrefix` is not null), the indexeddb will be unencrypted.\r\n     */\r\n    storePassphrase?: string;\r\n\r\n    /**\r\n     * A key to use to encrypt the indexeddb created by rust-crypto.\r\n     *\r\n     * Ignored if `storePrefix` is null. Otherwise, if it is set, it must be a 32-byte cryptographic key, which\r\n     * will be used to encrypt the indexeddb. See also `storePassphrase`.\r\n     */\r\n    storeKey?: Uint8Array;\r\n\r\n    /** If defined, we will check if any data needs migrating from this store to the rust store. */\r\n    legacyCryptoStore?: CryptoStore;\r\n\r\n    /** The pickle key for `legacyCryptoStore` */\r\n    legacyPickleKey?: string;\r\n\r\n    /**\r\n     * A callback which will receive progress updates on migration from `legacyCryptoStore`.\r\n     *\r\n     * Called with (-1, -1) to mark the end of migration.\r\n     */\r\n    legacyMigrationProgressListener?: (progress: number, total: number) => void;\r\n}): Promise<RustCrypto> {\r\n    const { logger } = args;\r\n\r\n    // initialise the rust matrix-sdk-crypto-wasm, if it hasn't already been done\r\n    logger.debug(\"Initialising Rust crypto-sdk WASM artifact\");\r\n    await RustSdkCryptoJs.initAsync();\r\n\r\n    // enable tracing in the rust-sdk\r\n    new RustSdkCryptoJs.Tracing(RustSdkCryptoJs.LoggerLevel.Debug).turnOn();\r\n\r\n    logger.debug(\"Opening Rust CryptoStore\");\r\n    let storeHandle;\r\n    if (args.storePrefix) {\r\n        if (args.storeKey) {\r\n            storeHandle = await StoreHandle.openWithKey(args.storePrefix, args.storeKey);\r\n        } else {\r\n            storeHandle = await StoreHandle.open(args.storePrefix, args.storePassphrase);\r\n        }\r\n    } else {\r\n        storeHandle = await StoreHandle.open();\r\n    }\r\n\r\n    if (args.legacyCryptoStore) {\r\n        // We have a legacy crypto store, which we may need to migrate from.\r\n        await migrateFromLegacyCrypto({\r\n            legacyStore: args.legacyCryptoStore,\r\n            storeHandle,\r\n            ...args,\r\n        });\r\n    }\r\n\r\n    const rustCrypto = await initOlmMachine(\r\n        logger,\r\n        args.http,\r\n        args.userId,\r\n        args.deviceId,\r\n        args.secretStorage,\r\n        args.cryptoCallbacks,\r\n        storeHandle,\r\n        args.legacyCryptoStore,\r\n    );\r\n\r\n    storeHandle.free();\r\n\r\n    logger.debug(\"Completed rust crypto-sdk setup\");\r\n    return rustCrypto;\r\n}\r\n\r\nasync function initOlmMachine(\r\n    logger: Logger,\r\n    http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\r\n    userId: string,\r\n    deviceId: string,\r\n    secretStorage: ServerSideSecretStorage,\r\n    cryptoCallbacks: ICryptoCallbacks,\r\n    storeHandle: StoreHandle,\r\n    legacyCryptoStore?: CryptoStore,\r\n): Promise<RustCrypto> {\r\n    logger.debug(\"Init OlmMachine\");\r\n\r\n    const olmMachine = await RustSdkCryptoJs.OlmMachine.initFromStore(\r\n        new RustSdkCryptoJs.UserId(userId),\r\n        new RustSdkCryptoJs.DeviceId(deviceId),\r\n        storeHandle,\r\n    );\r\n\r\n    // A final migration step, now that we have an OlmMachine.\r\n    if (legacyCryptoStore) {\r\n        await migrateRoomSettingsFromLegacyCrypto({\r\n            logger,\r\n            legacyStore: legacyCryptoStore,\r\n            olmMachine,\r\n        });\r\n    }\r\n\r\n    // Disable room key requests, per https://github.com/vector-im/element-web/issues/26524.\r\n    olmMachine.roomKeyRequestsEnabled = false;\r\n\r\n    const rustCrypto = new RustCrypto(logger, olmMachine, http, userId, deviceId, secretStorage, cryptoCallbacks);\r\n\r\n    await olmMachine.registerRoomKeyUpdatedCallback((sessions: RustSdkCryptoJs.RoomKeyInfo[]) =>\r\n        rustCrypto.onRoomKeysUpdated(sessions),\r\n    );\r\n    await olmMachine.registerRoomKeysWithheldCallback((withheld: RustSdkCryptoJs.RoomKeyWithheldInfo[]) =>\r\n        rustCrypto.onRoomKeysWithheld(withheld),\r\n    );\r\n    await olmMachine.registerUserIdentityUpdatedCallback((userId: RustSdkCryptoJs.UserId) =>\r\n        rustCrypto.onUserIdentityUpdated(userId),\r\n    );\r\n    await olmMachine.registerDevicesUpdatedCallback((userIds: string[]) => rustCrypto.onDevicesUpdated(userIds));\r\n\r\n    // Check if there are any key backup secrets pending processing. There may be multiple secrets to process if several devices have gossiped them.\r\n    // The `registerReceiveSecretCallback` function will only be triggered for new secrets. If the client is restarted before processing them, the secrets will need to be manually handled.\r\n    rustCrypto.checkSecrets(\"m.megolm_backup.v1\");\r\n\r\n    // Register a callback to be notified when a new secret is received, as for now only the key backup secret is supported (the cross signing secrets are handled automatically by the OlmMachine)\r\n    await olmMachine.registerReceiveSecretCallback((name: string, _value: string) =>\r\n        // Instead of directly checking the secret value, we poll the inbox to get all values for that secret type.\r\n        // Once we have all the values, we can safely clear the secret inbox.\r\n        rustCrypto.checkSecrets(name),\r\n    );\r\n\r\n    // Tell the OlmMachine to think about its outgoing requests before we hand control back to the application.\r\n    //\r\n    // This is primarily a fudge to get it to correctly populate the `users_for_key_query` list, so that future\r\n    // calls to getIdentity (etc) block until the key queries are performed.\r\n    //\r\n    // Note that we don't actually need to *make* any requests here; it is sufficient to tell the Rust side to think\r\n    // about them.\r\n    //\r\n    // XXX: find a less hacky way to do this.\r\n    await olmMachine.outgoingRequests();\r\n\r\n    if (legacyCryptoStore && (await legacyCryptoStore.containsData())) {\r\n        const migrationState = await legacyCryptoStore.getMigrationState();\r\n        if (migrationState < MigrationState.INITIAL_OWN_KEY_QUERY_DONE) {\r\n            logger.debug(`Performing initial key query after migration`);\r\n            // We need to do an initial keys query so that the rust stack can properly update trust of\r\n            // the user device and identity from the migrated private keys.\r\n            // If not done, there is a short period where the own device/identity trust will be undefined after migration.\r\n            let initialKeyQueryDone = false;\r\n            while (!initialKeyQueryDone) {\r\n                try {\r\n                    await rustCrypto.userHasCrossSigningKeys(userId);\r\n                    initialKeyQueryDone = true;\r\n                } catch (e) {\r\n                    // If the initial key query fails, we retry until it succeeds.\r\n                    logger.error(\"Failed to check for cross-signing keys after migration, retrying\", e);\r\n                }\r\n            }\r\n\r\n            // If the private master cross-signing key was not cached in the legacy store, the rust session\r\n            // will not be able to establish the trust of the user identity.\r\n            // That means that after migration the session could revert to unverified.\r\n            // In order to avoid asking the users to re-verify their sessions, we need to migrate the legacy local trust\r\n            // (if the legacy session was already verified) to the new session.\r\n            await migrateLegacyLocalTrustIfNeeded({ legacyCryptoStore, rustCrypto, logger });\r\n\r\n            await legacyCryptoStore.setMigrationState(MigrationState.INITIAL_OWN_KEY_QUERY_DONE);\r\n        }\r\n    }\r\n\r\n    return rustCrypto;\r\n}\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport {\r\n    KeysBackupRequest,\r\n    KeysClaimRequest,\r\n    KeysQueryRequest,\r\n    KeysUploadRequest,\r\n    OlmMachine,\r\n    PutDehydratedDeviceRequest,\r\n    RoomMessageRequest,\r\n    SignatureUploadRequest,\r\n    ToDeviceRequest,\r\n    UploadSigningKeysRequest,\r\n} from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { logger } from \"../logger\";\r\nimport { calculateRetryBackoff, IHttpOpts, MatrixHttpApi, Method } from \"../http-api\";\r\nimport { logDuration, QueryDict, sleep } from \"../utils\";\r\nimport { AuthDict, UIAuthCallback } from \"../interactive-auth\";\r\nimport { UIAResponse } from \"../@types/uia\";\r\nimport { ToDeviceMessageId } from \"../@types/event\";\r\nimport { UnstablePrefix as DehydrationUnstablePrefix } from \"./DehydratedDeviceManager\";\r\n\r\n/**\r\n * Common interface for all the request types returned by `OlmMachine.outgoingRequests`.\r\n *\r\n * @internal\r\n */\r\nexport interface OutgoingRequest {\r\n    readonly id: string | undefined;\r\n    readonly type: number;\r\n}\r\n\r\n/**\r\n * OutgoingRequestManager: turns `OutgoingRequest`s from the rust sdk into HTTP requests\r\n *\r\n * We have one of these per `RustCrypto` (and hence per `MatrixClient`), not that it does anything terribly complicated.\r\n * It's responsible for:\r\n *\r\n *   * holding the reference to the `MatrixHttpApi`\r\n *   * turning `OutgoingRequest`s from the rust backend into HTTP requests, and sending them\r\n *   * sending the results of such requests back to the rust backend.\r\n *\r\n * @internal\r\n */\r\nexport class OutgoingRequestProcessor {\r\n    public constructor(\r\n        private readonly olmMachine: OlmMachine,\r\n        private readonly http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\r\n    ) {}\r\n\r\n    public async makeOutgoingRequest<T>(\r\n        msg: OutgoingRequest | UploadSigningKeysRequest | PutDehydratedDeviceRequest,\r\n        uiaCallback?: UIAuthCallback<T>,\r\n    ): Promise<void> {\r\n        let resp: string;\r\n\r\n        /* refer https://docs.rs/matrix-sdk-crypto/0.6.0/matrix_sdk_crypto/requests/enum.OutgoingRequests.html\r\n         * for the complete list of request types\r\n         */\r\n        if (msg instanceof KeysUploadRequest) {\r\n            resp = await this.requestWithRetry(Method.Post, \"/_matrix/client/v3/keys/upload\", {}, msg.body);\r\n        } else if (msg instanceof KeysQueryRequest) {\r\n            resp = await this.requestWithRetry(Method.Post, \"/_matrix/client/v3/keys/query\", {}, msg.body);\r\n        } else if (msg instanceof KeysClaimRequest) {\r\n            resp = await this.requestWithRetry(Method.Post, \"/_matrix/client/v3/keys/claim\", {}, msg.body);\r\n        } else if (msg instanceof SignatureUploadRequest) {\r\n            resp = await this.requestWithRetry(Method.Post, \"/_matrix/client/v3/keys/signatures/upload\", {}, msg.body);\r\n        } else if (msg instanceof KeysBackupRequest) {\r\n            resp = await this.requestWithRetry(\r\n                Method.Put,\r\n                \"/_matrix/client/v3/room_keys/keys\",\r\n                { version: msg.version },\r\n                msg.body,\r\n            );\r\n        } else if (msg instanceof ToDeviceRequest) {\r\n            resp = await this.sendToDeviceRequest(msg);\r\n        } else if (msg instanceof RoomMessageRequest) {\r\n            const path =\r\n                `/_matrix/client/v3/rooms/${encodeURIComponent(msg.room_id)}/send/` +\r\n                `${encodeURIComponent(msg.event_type)}/${encodeURIComponent(msg.txn_id)}`;\r\n            resp = await this.requestWithRetry(Method.Put, path, {}, msg.body);\r\n        } else if (msg instanceof UploadSigningKeysRequest) {\r\n            await this.makeRequestWithUIA(\r\n                Method.Post,\r\n                \"/_matrix/client/v3/keys/device_signing/upload\",\r\n                {},\r\n                msg.body,\r\n                uiaCallback,\r\n            );\r\n            // SigningKeysUploadRequest does not implement OutgoingRequest and does not need to be marked as sent.\r\n            return;\r\n        } else if (msg instanceof PutDehydratedDeviceRequest) {\r\n            const path = DehydrationUnstablePrefix + \"/dehydrated_device\";\r\n            await this.rawJsonRequest(Method.Put, path, {}, msg.body);\r\n            // PutDehydratedDeviceRequest does not implement OutgoingRequest and does not need to be marked as sent.\r\n            return;\r\n        } else {\r\n            logger.warn(\"Unsupported outgoing message\", Object.getPrototypeOf(msg));\r\n            resp = \"\";\r\n        }\r\n\r\n        if (msg.id) {\r\n            try {\r\n                await logDuration(logger, `Mark Request as sent ${msg.type}`, async () => {\r\n                    await this.olmMachine.markRequestAsSent(msg.id!, msg.type, resp);\r\n                });\r\n            } catch (e) {\r\n                // Ignore errors which are caused by the olmMachine having been freed. The exact error message depends\r\n                // on whether we are using a release or develop build of rust-sdk-crypto-wasm.\r\n                if (\r\n                    e instanceof Error &&\r\n                    (e.message === \"Attempt to use a moved value\" || e.message === \"null pointer passed to rust\")\r\n                ) {\r\n                    logger.log(`Ignoring error '${e.message}': client is likely shutting down`);\r\n                } else {\r\n                    throw e;\r\n                }\r\n            }\r\n        } else {\r\n            logger.trace(`Outgoing request type:${msg.type} does not have an ID`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send the HTTP request for a `ToDeviceRequest`\r\n     *\r\n     * @param request - request to send\r\n     * @returns JSON-serialized body of the response, if successful\r\n     */\r\n    private async sendToDeviceRequest(request: ToDeviceRequest): Promise<string> {\r\n        // a bit of extra logging, to help trace to-device messages through the system\r\n        const parsedBody: { messages: Record<string, Record<string, Record<string, any>>> } = JSON.parse(request.body);\r\n\r\n        const messageList = [];\r\n        for (const [userId, perUserMessages] of Object.entries(parsedBody.messages)) {\r\n            for (const [deviceId, message] of Object.entries(perUserMessages)) {\r\n                messageList.push(`${userId}/${deviceId} (msgid ${message[ToDeviceMessageId]})`);\r\n            }\r\n        }\r\n\r\n        logger.info(\r\n            `Sending batch of to-device messages. type=${request.event_type} txnid=${request.txn_id}`,\r\n            messageList,\r\n        );\r\n\r\n        const path =\r\n            `/_matrix/client/v3/sendToDevice/${encodeURIComponent(request.event_type)}/` +\r\n            encodeURIComponent(request.txn_id);\r\n        return await this.requestWithRetry(Method.Put, path, {}, request.body);\r\n    }\r\n\r\n    private async makeRequestWithUIA<T>(\r\n        method: Method,\r\n        path: string,\r\n        queryParams: QueryDict,\r\n        body: string,\r\n        uiaCallback: UIAuthCallback<T> | undefined,\r\n    ): Promise<string> {\r\n        if (!uiaCallback) {\r\n            return await this.requestWithRetry(method, path, queryParams, body);\r\n        }\r\n\r\n        const parsedBody = JSON.parse(body);\r\n        const makeRequest = async (auth: AuthDict | null): Promise<UIAResponse<T>> => {\r\n            const newBody: Record<string, any> = {\r\n                ...parsedBody,\r\n            };\r\n            if (auth !== null) {\r\n                newBody.auth = auth;\r\n            }\r\n            const resp = await this.requestWithRetry(method, path, queryParams, JSON.stringify(newBody));\r\n            return JSON.parse(resp) as T;\r\n        };\r\n\r\n        const resp = await uiaCallback(makeRequest);\r\n        return JSON.stringify(resp);\r\n    }\r\n\r\n    private async requestWithRetry(\r\n        method: Method,\r\n        path: string,\r\n        queryParams: QueryDict,\r\n        body: string,\r\n    ): Promise<string> {\r\n        let currentRetryCount = 0;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            try {\r\n                return await this.rawJsonRequest(method, path, queryParams, body);\r\n            } catch (e) {\r\n                currentRetryCount++;\r\n                const backoff = calculateRetryBackoff(e, currentRetryCount, true);\r\n                if (backoff < 0) {\r\n                    // Max number of retries reached, or error is not retryable. rethrow the error\r\n                    throw e;\r\n                }\r\n                // wait for the specified time and then retry the request\r\n                await sleep(backoff);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async rawJsonRequest(method: Method, path: string, queryParams: QueryDict, body: string): Promise<string> {\r\n        const opts = {\r\n            // inhibit the JSON stringification and parsing within HttpApi.\r\n            json: false,\r\n\r\n            // nevertheless, we are sending, and accept, JSON.\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n                \"Accept\": \"application/json\",\r\n            },\r\n\r\n            // we use the full prefix\r\n            prefix: \"\",\r\n        };\r\n\r\n        return await this.http.authedRequest<string>(method, path, queryParams, body, opts);\r\n    }\r\n}\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\nimport { QrState } from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport {\r\n    GeneratedSas,\r\n    ShowQrCodeCallbacks,\r\n    ShowSasCallbacks,\r\n    VerificationPhase,\r\n    VerificationRequest,\r\n    VerificationRequestEvent,\r\n    VerificationRequestEventHandlerMap,\r\n    Verifier,\r\n    VerifierEvent,\r\n    VerifierEventHandlerMap,\r\n} from \"../crypto-api/verification\";\r\nimport { TypedEventEmitter } from \"../models/typed-event-emitter\";\r\nimport { OutgoingRequest, OutgoingRequestProcessor } from \"./OutgoingRequestProcessor\";\r\nimport { TypedReEmitter } from \"../ReEmitter\";\r\nimport { MatrixEvent } from \"../models/event\";\r\nimport { EventType, MsgType } from \"../@types/event\";\r\nimport { defer, IDeferred } from \"../utils\";\r\nimport { VerificationMethod } from \"../types\";\r\n\r\n/**\r\n * An incoming, or outgoing, request to verify a user or a device via cross-signing.\r\n *\r\n * @internal\r\n */\r\nexport class RustVerificationRequest\r\n    extends TypedEventEmitter<VerificationRequestEvent, VerificationRequestEventHandlerMap>\r\n    implements VerificationRequest\r\n{\r\n    /** a remitter which relays VerificationRequestEvent.Changed events emitted by the verifier */\r\n    private readonly reEmitter: TypedReEmitter<VerificationRequestEvent, VerificationRequestEventHandlerMap>;\r\n\r\n    /** Are we in the process of sending an `m.key.verification.ready` event? */\r\n    private _accepting = false;\r\n\r\n    /** Are we in the process of sending an `m.key.verification.cancellation` event? */\r\n    private _cancelling = false;\r\n\r\n    private _verifier: undefined | RustSASVerifier | RustQrCodeVerifier;\r\n\r\n    /**\r\n     * Construct a new RustVerificationRequest to wrap the rust-level `VerificationRequest`.\r\n     *\r\n     * @param olmMachine - The `OlmMachine` from the underlying rust crypto sdk.\r\n     * @param inner - VerificationRequest from the Rust SDK.\r\n     * @param outgoingRequestProcessor - `OutgoingRequestProcessor` to use for making outgoing HTTP requests.\r\n     * @param supportedVerificationMethods - Verification methods to use when `accept()` is called.\r\n     */\r\n    public constructor(\r\n        private readonly olmMachine: RustSdkCryptoJs.OlmMachine,\r\n        private readonly inner: RustSdkCryptoJs.VerificationRequest,\r\n        private readonly outgoingRequestProcessor: OutgoingRequestProcessor,\r\n        private readonly supportedVerificationMethods: string[],\r\n    ) {\r\n        super();\r\n        this.reEmitter = new TypedReEmitter(this);\r\n\r\n        // Obviously, the Rust object maintains a reference to the callback function. If the callback function maintains\r\n        // a reference to the Rust object, then we have a reference cycle which means that `RustVerificationRequest`\r\n        // will never be garbage-collected, and hence the underlying rust object will never be freed.\r\n        //\r\n        // To avoid this reference cycle, use a weak reference in the callback function. If the `RustVerificationRequest`\r\n        // gets garbage-collected, then there is nothing to update!\r\n        const weakThis = new WeakRef(this);\r\n        inner.registerChangesCallback(async () => weakThis.deref()?.onChange());\r\n    }\r\n\r\n    /**\r\n     * Hook which is called when the underlying rust class notifies us that there has been a change.\r\n     */\r\n    private onChange(): void {\r\n        const verification: RustSdkCryptoJs.Qr | RustSdkCryptoJs.Sas | undefined = this.inner.getVerification();\r\n\r\n        // Set the _verifier object (wrapping the rust `Verification` as a js-sdk Verifier) if:\r\n        // - we now have a `Verification` where we lacked one before\r\n        // - we have transitioned from QR to SAS\r\n        // - we are verifying with SAS, but we need to replace our verifier with a new one because both parties\r\n        //   tried to start verification at the same time, and we lost the tie breaking\r\n        if (verification instanceof RustSdkCryptoJs.Sas) {\r\n            if (this._verifier === undefined || this._verifier instanceof RustQrCodeVerifier) {\r\n                this.setVerifier(new RustSASVerifier(verification, this, this.outgoingRequestProcessor));\r\n            } else if (this._verifier instanceof RustSASVerifier) {\r\n                this._verifier.replaceInner(verification);\r\n            }\r\n        } else if (verification instanceof RustSdkCryptoJs.Qr && this._verifier === undefined) {\r\n            this.setVerifier(new RustQrCodeVerifier(verification, this.outgoingRequestProcessor));\r\n        }\r\n\r\n        this.emit(VerificationRequestEvent.Change);\r\n    }\r\n\r\n    private setVerifier(verifier: RustSASVerifier | RustQrCodeVerifier): void {\r\n        // if we already have a verifier, unsubscribe from its events\r\n        if (this._verifier) {\r\n            this.reEmitter.stopReEmitting(this._verifier, [VerificationRequestEvent.Change]);\r\n        }\r\n        this._verifier = verifier;\r\n        this.reEmitter.reEmit(this._verifier, [VerificationRequestEvent.Change]);\r\n    }\r\n\r\n    /**\r\n     * Unique ID for this verification request.\r\n     *\r\n     * An ID isn't assigned until the first message is sent, so this may be `undefined` in the early phases.\r\n     */\r\n    public get transactionId(): string | undefined {\r\n        return this.inner.flowId;\r\n    }\r\n\r\n    /**\r\n     * For an in-room verification, the ID of the room.\r\n     *\r\n     * For to-device verifications, `undefined`.\r\n     */\r\n    public get roomId(): string | undefined {\r\n        return this.inner.roomId?.toString();\r\n    }\r\n\r\n    /**\r\n     * True if this request was initiated by the local client.\r\n     *\r\n     * For in-room verifications, the initiator is who sent the `m.key.verification.request` event.\r\n     * For to-device verifications, the initiator is who sent the `m.key.verification.start` event.\r\n     */\r\n    public get initiatedByMe(): boolean {\r\n        return this.inner.weStarted();\r\n    }\r\n\r\n    /** The user id of the other party in this request */\r\n    public get otherUserId(): string {\r\n        return this.inner.otherUserId.toString();\r\n    }\r\n\r\n    /** For verifications via to-device messages: the ID of the other device. Otherwise, undefined. */\r\n    public get otherDeviceId(): string | undefined {\r\n        return this.inner.otherDeviceId?.toString();\r\n    }\r\n\r\n    /** Get the other device involved in the verification, if it is known */\r\n    private async getOtherDevice(): Promise<undefined | RustSdkCryptoJs.Device> {\r\n        const otherDeviceId = this.inner.otherDeviceId;\r\n        if (!otherDeviceId) {\r\n            return undefined;\r\n        }\r\n        return await this.olmMachine.getDevice(this.inner.otherUserId, otherDeviceId, 5);\r\n    }\r\n\r\n    /** True if the other party in this request is one of this user's own devices. */\r\n    public get isSelfVerification(): boolean {\r\n        return this.inner.isSelfVerification();\r\n    }\r\n\r\n    /** current phase of the request. */\r\n    public get phase(): VerificationPhase {\r\n        const phase = this.inner.phase();\r\n\r\n        switch (phase) {\r\n            case RustSdkCryptoJs.VerificationRequestPhase.Created:\r\n            case RustSdkCryptoJs.VerificationRequestPhase.Requested:\r\n                return VerificationPhase.Requested;\r\n            case RustSdkCryptoJs.VerificationRequestPhase.Ready:\r\n                // if we're still sending the `m.key.verification.ready`, that counts as \"Requested\" in the js-sdk's\r\n                // parlance.\r\n                return this._accepting ? VerificationPhase.Requested : VerificationPhase.Ready;\r\n            case RustSdkCryptoJs.VerificationRequestPhase.Transitioned:\r\n                if (!this._verifier) {\r\n                    // this shouldn't happen, because the onChange handler should have created a _verifier.\r\n                    throw new Error(\"VerificationRequest: inner phase == Transitioned but no verifier!\");\r\n                }\r\n                return this._verifier.verificationPhase;\r\n            case RustSdkCryptoJs.VerificationRequestPhase.Done:\r\n                return VerificationPhase.Done;\r\n            case RustSdkCryptoJs.VerificationRequestPhase.Cancelled:\r\n                return VerificationPhase.Cancelled;\r\n        }\r\n\r\n        throw new Error(`Unknown verification phase ${phase}`);\r\n    }\r\n\r\n    /** True if the request has sent its initial event and needs more events to complete\r\n     * (ie it is in phase `Requested`, `Ready` or `Started`).\r\n     */\r\n    public get pending(): boolean {\r\n        if (this.inner.isPassive()) return false;\r\n        const phase = this.phase;\r\n        return phase !== VerificationPhase.Done && phase !== VerificationPhase.Cancelled;\r\n    }\r\n\r\n    /**\r\n     * True if we have started the process of sending an `m.key.verification.ready` (but have not necessarily received\r\n     * the remote echo which causes a transition to {@link VerificationPhase.Ready}.\r\n     */\r\n    public get accepting(): boolean {\r\n        return this._accepting;\r\n    }\r\n\r\n    /**\r\n     * True if we have started the process of sending an `m.key.verification.cancel` (but have not necessarily received\r\n     * the remote echo which causes a transition to {@link VerificationPhase.Cancelled}).\r\n     */\r\n    public get declining(): boolean {\r\n        return this._cancelling;\r\n    }\r\n\r\n    /**\r\n     * The remaining number of ms before the request will be automatically cancelled.\r\n     *\r\n     * `null` indicates that there is no timeout\r\n     */\r\n    public get timeout(): number | null {\r\n        return this.inner.timeRemainingMillis();\r\n    }\r\n\r\n    /** once the phase is Started (and !initiatedByMe) or Ready: common methods supported by both sides */\r\n    public get methods(): string[] {\r\n        throw new Error(\"not implemented\");\r\n    }\r\n\r\n    /** the method picked in the .start event */\r\n    public get chosenMethod(): string | null {\r\n        if (this.phase !== VerificationPhase.Started) return null;\r\n\r\n        const verification: RustSdkCryptoJs.Qr | RustSdkCryptoJs.Sas | undefined = this.inner.getVerification();\r\n        if (verification instanceof RustSdkCryptoJs.Sas) {\r\n            return VerificationMethod.Sas;\r\n        } else if (verification instanceof RustSdkCryptoJs.Qr) {\r\n            return VerificationMethod.Reciprocate;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether the other party supports a given verification method.\r\n     * This is useful when setting up the QR code UI, as it is somewhat asymmetrical:\r\n     * if the other party supports SCAN_QR, we should show a QR code in the UI, and vice versa.\r\n     * For methods that need to be supported by both ends, use the `methods` property.\r\n     *\r\n     * @param method - the method to check\r\n     * @returns true if the other party said they supported the method\r\n     */\r\n    public otherPartySupportsMethod(method: string): boolean {\r\n        const theirMethods: RustSdkCryptoJs.VerificationMethod[] | undefined = this.inner.theirSupportedMethods;\r\n        if (theirMethods === undefined) {\r\n            // no message from the other side yet\r\n            return false;\r\n        }\r\n\r\n        const requiredMethod = verificationMethodsByIdentifier[method];\r\n        return theirMethods.some((m) => m === requiredMethod);\r\n    }\r\n\r\n    /**\r\n     * Accepts the request, sending a .ready event to the other party\r\n     *\r\n     * @returns Promise which resolves when the event has been sent.\r\n     */\r\n    public async accept(): Promise<void> {\r\n        if (this.inner.phase() !== RustSdkCryptoJs.VerificationRequestPhase.Requested || this._accepting) {\r\n            throw new Error(`Cannot accept a verification request in phase ${this.phase}`);\r\n        }\r\n\r\n        this._accepting = true;\r\n        try {\r\n            const req: undefined | OutgoingRequest = this.inner.acceptWithMethods(\r\n                this.supportedVerificationMethods.map(verificationMethodIdentifierToMethod),\r\n            );\r\n            if (req) {\r\n                await this.outgoingRequestProcessor.makeOutgoingRequest(req);\r\n            }\r\n        } finally {\r\n            this._accepting = false;\r\n        }\r\n\r\n        // phase may have changed, so emit a 'change' event\r\n        this.emit(VerificationRequestEvent.Change);\r\n    }\r\n\r\n    /**\r\n     * Cancels the request, sending a cancellation to the other party\r\n     *\r\n     * @param params - Details for the cancellation, including `reason` (defaults to \"User declined\"), and `code`\r\n     *    (defaults to `m.user`).\r\n     *\r\n     * @returns Promise which resolves when the event has been sent.\r\n     */\r\n    public async cancel(params?: { reason?: string; code?: string }): Promise<void> {\r\n        if (this._cancelling) {\r\n            // already cancelling; do nothing\r\n            return;\r\n        }\r\n\r\n        this._cancelling = true;\r\n        try {\r\n            const req: undefined | OutgoingRequest = this.inner.cancel();\r\n            if (req) {\r\n                await this.outgoingRequestProcessor.makeOutgoingRequest(req);\r\n            }\r\n        } finally {\r\n            this._cancelling = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a {@link Verifier} to do this verification via a particular method.\r\n     *\r\n     * If a verifier has already been created for this request, returns that verifier.\r\n     *\r\n     * This does *not* send the `m.key.verification.start` event - to do so, call {@link Verifier#verifier} on the\r\n     * returned verifier.\r\n     *\r\n     * If no previous events have been sent, pass in `targetDevice` to set who to direct this request to.\r\n     *\r\n     * @param method - the name of the verification method to use.\r\n     * @param targetDevice - details of where to send the request to.\r\n     *\r\n     * @returns The verifier which will do the actual verification.\r\n     */\r\n    public beginKeyVerification(method: string, targetDevice?: { userId?: string; deviceId?: string }): Verifier {\r\n        throw new Error(\"not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Send an `m.key.verification.start` event to start verification via a particular method.\r\n     *\r\n     * Implementation of {@link Crypto.VerificationRequest#startVerification}.\r\n     *\r\n     * @param method - the name of the verification method to use.\r\n     */\r\n    public async startVerification(method: string): Promise<Verifier> {\r\n        if (method !== VerificationMethod.Sas) {\r\n            throw new Error(`Unsupported verification method ${method}`);\r\n        }\r\n\r\n        // make sure that we have a list of the other user's devices (workaround https://github.com/matrix-org/matrix-rust-sdk/issues/2896)\r\n        if (!(await this.getOtherDevice())) {\r\n            throw new Error(\"startVerification(): other device is unknown\");\r\n        }\r\n\r\n        const res:\r\n            | [RustSdkCryptoJs.Sas, RustSdkCryptoJs.RoomMessageRequest | RustSdkCryptoJs.ToDeviceRequest]\r\n            | undefined = await this.inner.startSas();\r\n\r\n        if (res) {\r\n            const [, req] = res;\r\n            await this.outgoingRequestProcessor.makeOutgoingRequest(req);\r\n        }\r\n\r\n        // this should have triggered the onChange callback, and we should now have a verifier\r\n        if (!this._verifier) {\r\n            throw new Error(\"Still no verifier after startSas() call\");\r\n        }\r\n\r\n        return this._verifier;\r\n    }\r\n\r\n    /**\r\n     * Start a QR code verification by providing a scanned QR code for this verification flow.\r\n     *\r\n     * Implementation of {@link Crypto.VerificationRequest#scanQRCode}.\r\n     *\r\n     * @param qrCodeData - the decoded QR code.\r\n     * @returns A verifier; call `.verify()` on it to wait for the other side to complete the verification flow.\r\n     */\r\n    public async scanQRCode(uint8Array: Uint8Array): Promise<Verifier> {\r\n        const scan = RustSdkCryptoJs.QrCodeScan.fromBytes(new Uint8ClampedArray(uint8Array));\r\n        const verifier: RustSdkCryptoJs.Qr = await this.inner.scanQrCode(scan);\r\n\r\n        // this should have triggered the onChange callback, and we should now have a verifier\r\n        if (!this._verifier) {\r\n            throw new Error(\"Still no verifier after scanQrCode() call\");\r\n        }\r\n\r\n        // we can immediately trigger the reciprocate request\r\n        const req: undefined | OutgoingRequest = verifier.reciprocate();\r\n        if (req) {\r\n            await this.outgoingRequestProcessor.makeOutgoingRequest(req);\r\n        }\r\n\r\n        return this._verifier;\r\n    }\r\n\r\n    /**\r\n     * The verifier which is doing the actual verification, once the method has been established.\r\n     * Only defined when the `phase` is Started.\r\n     */\r\n    public get verifier(): Verifier | undefined {\r\n        // It's possible for us to have a Verifier before a method has been chosen (in particular,\r\n        // if we are showing a QR code which the other device has not yet scanned. At that point, we could\r\n        // still switch to SAS).\r\n        //\r\n        // In that case, we should not return it to the application yet, since the application will not expect the\r\n        // Verifier to be replaced during the lifetime of the VerificationRequest.\r\n        return this.phase === VerificationPhase.Started ? this._verifier : undefined;\r\n    }\r\n\r\n    /**\r\n     * Stub implementation of {@link Crypto.VerificationRequest#getQRCodeBytes}.\r\n     */\r\n    public getQRCodeBytes(): Buffer | undefined {\r\n        throw new Error(\"getQRCodeBytes() unsupported in Rust Crypto; use generateQRCode() instead.\");\r\n    }\r\n\r\n    /**\r\n     * Generate the data for a QR code allowing the other device to verify this one, if it supports it.\r\n     *\r\n     * Implementation of {@link Crypto.VerificationRequest#generateQRCode}.\r\n     */\r\n    public async generateQRCode(): Promise<Buffer | undefined> {\r\n        // make sure that we have a list of the other user's devices (workaround https://github.com/matrix-org/matrix-rust-sdk/issues/2896)\r\n        if (!(await this.getOtherDevice())) {\r\n            throw new Error(\"generateQRCode(): other device is unknown\");\r\n        }\r\n\r\n        const innerVerifier: RustSdkCryptoJs.Qr | undefined = await this.inner.generateQrCode();\r\n        // If we are unable to generate a QRCode, we return undefined\r\n        if (!innerVerifier) return;\r\n\r\n        return Buffer.from(innerVerifier.toBytes());\r\n    }\r\n\r\n    /**\r\n     * If this request has been cancelled, the cancellation code (e.g `m.user`) which is responsible for cancelling\r\n     * this verification.\r\n     */\r\n    public get cancellationCode(): string | null {\r\n        return this.inner.cancelInfo?.cancelCode() ?? null;\r\n    }\r\n\r\n    /**\r\n     * The id of the user that cancelled the request.\r\n     *\r\n     * Only defined when phase is Cancelled\r\n     */\r\n    public get cancellingUserId(): string | undefined {\r\n        const cancelInfo = this.inner.cancelInfo;\r\n        if (!cancelInfo) {\r\n            return undefined;\r\n        } else if (cancelInfo.cancelledbyUs()) {\r\n            return this.olmMachine.userId.toString();\r\n        } else {\r\n            return this.inner.otherUserId.toString();\r\n        }\r\n    }\r\n}\r\n\r\n/** Common base class for `Verifier` implementations which wrap rust classes.\r\n *\r\n * The generic parameter `InnerType` is the type of the rust Verification class which we wrap.\r\n *\r\n * @internal\r\n */\r\nabstract class BaseRustVerifer<InnerType extends RustSdkCryptoJs.Qr | RustSdkCryptoJs.Sas> extends TypedEventEmitter<\r\n    VerifierEvent | VerificationRequestEvent,\r\n    VerifierEventHandlerMap & VerificationRequestEventHandlerMap\r\n> {\r\n    /** A deferred which completes when the verification completes (or rejects when it is cancelled/fails) */\r\n    protected readonly completionDeferred: IDeferred<void>;\r\n\r\n    public constructor(\r\n        protected inner: InnerType,\r\n        protected readonly outgoingRequestProcessor: OutgoingRequestProcessor,\r\n    ) {\r\n        super();\r\n\r\n        this.completionDeferred = defer();\r\n\r\n        // As with RustVerificationRequest, we need to avoid a reference cycle.\r\n        // See the comments in RustVerificationRequest.\r\n        const weakThis = new WeakRef(this);\r\n        inner.registerChangesCallback(async () => weakThis.deref()?.onChange());\r\n\r\n        // stop the runtime complaining if nobody catches a failure\r\n        this.completionDeferred.promise.catch(() => null);\r\n    }\r\n\r\n    /**\r\n     * Hook which is called when the underlying rust class notifies us that there has been a change.\r\n     *\r\n     * Can be overridden by subclasses to see if we can notify the application about an update. The overriding method\r\n     * must call `super.onChange()`.\r\n     */\r\n    protected onChange(): void {\r\n        if (this.inner.isDone()) {\r\n            this.completionDeferred.resolve(undefined);\r\n        } else if (this.inner.isCancelled()) {\r\n            const cancelInfo = this.inner.cancelInfo()!;\r\n            this.completionDeferred.reject(\r\n                new Error(\r\n                    `Verification cancelled by ${\r\n                        cancelInfo.cancelledbyUs() ? \"us\" : \"them\"\r\n                    } with code ${cancelInfo.cancelCode()}: ${cancelInfo.reason()}`,\r\n                ),\r\n            );\r\n        }\r\n\r\n        this.emit(VerificationRequestEvent.Change);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the verification has been cancelled, either by us or the other side.\r\n     */\r\n    public get hasBeenCancelled(): boolean {\r\n        return this.inner.isCancelled();\r\n    }\r\n\r\n    /**\r\n     * The ID of the other user in the verification process.\r\n     */\r\n    public get userId(): string {\r\n        return this.inner.otherUserId.toString();\r\n    }\r\n\r\n    /**\r\n     * Cancel a verification.\r\n     *\r\n     * We will send an `m.key.verification.cancel` if the verification is still in flight. The verification promise\r\n     * will reject, and a {@link Crypto.VerifierEvent#Cancel} will be emitted.\r\n     *\r\n     * @param e - the reason for the cancellation.\r\n     */\r\n    public cancel(e?: Error): void {\r\n        // TODO: something with `e`\r\n        const req: undefined | OutgoingRequest = this.inner.cancel();\r\n        if (req) {\r\n            this.outgoingRequestProcessor.makeOutgoingRequest(req);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the details for an SAS verification, if one is in progress\r\n     *\r\n     * Returns `null`, unless this verifier is for a SAS-based verification and we are waiting for the user to confirm\r\n     * the SAS matches.\r\n     */\r\n    public getShowSasCallbacks(): ShowSasCallbacks | null {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the details for reciprocating QR code verification, if one is in progress\r\n     *\r\n     * Returns `null`, unless this verifier is for reciprocating a QR-code-based verification (ie, the other user has\r\n     * already scanned our QR code), and we are waiting for the user to confirm.\r\n     */\r\n    public getReciprocateQrCodeCallbacks(): ShowQrCodeCallbacks | null {\r\n        return null;\r\n    }\r\n}\r\n\r\n/** A Verifier instance which is used to show and/or scan a QR code. */\r\nexport class RustQrCodeVerifier extends BaseRustVerifer<RustSdkCryptoJs.Qr> implements Verifier {\r\n    private callbacks: ShowQrCodeCallbacks | null = null;\r\n\r\n    public constructor(inner: RustSdkCryptoJs.Qr, outgoingRequestProcessor: OutgoingRequestProcessor) {\r\n        super(inner, outgoingRequestProcessor);\r\n    }\r\n\r\n    protected onChange(): void {\r\n        // if the other side has scanned our QR code and sent us a \"reciprocate\" message, it is now time for the\r\n        // application to prompt the user to confirm their side.\r\n        if (this.callbacks === null && this.inner.hasBeenScanned()) {\r\n            this.callbacks = {\r\n                confirm: (): void => {\r\n                    this.confirmScanning();\r\n                },\r\n                cancel: (): void => this.cancel(),\r\n            };\r\n        }\r\n\r\n        super.onChange();\r\n    }\r\n\r\n    /**\r\n     * Start the key verification, if it has not already been started.\r\n     *\r\n     * @returns Promise which resolves when the verification has completed, or rejects if the verification is cancelled\r\n     *    or times out.\r\n     */\r\n    public async verify(): Promise<void> {\r\n        // Some applications (hello, matrix-react-sdk) may not check if there is a `ShowQrCodeCallbacks` and instead\r\n        // register a `ShowReciprocateQr` listener which they expect to be called once `.verify` is called.\r\n        if (this.callbacks !== null) {\r\n            this.emit(VerifierEvent.ShowReciprocateQr, this.callbacks);\r\n        }\r\n        // Nothing to do here but wait.\r\n        await this.completionDeferred.promise;\r\n    }\r\n\r\n    /**\r\n     * Calculate an appropriate VerificationPhase for a VerificationRequest where this is the verifier.\r\n     *\r\n     * This is abnormally complicated because a rust-side QR Code verifier can span several verification phases.\r\n     */\r\n    public get verificationPhase(): VerificationPhase {\r\n        switch (this.inner.state()) {\r\n            case QrState.Created:\r\n                // we have created a QR for display; neither side has yet sent an `m.key.verification.start`.\r\n                return VerificationPhase.Ready;\r\n            case QrState.Scanned:\r\n                // other side has scanned our QR and sent an `m.key.verification.start` with `m.reciprocate.v1`\r\n                return VerificationPhase.Started;\r\n            case QrState.Confirmed:\r\n                // we have confirmed the other side's scan and sent an `m.key.verification.done`.\r\n                //\r\n                // However, the verification is not yet \"Done\", because we have to wait until we have received the\r\n                // `m.key.verification.done` from the other side (in particular, we don't mark the device/identity as\r\n                // verified until that happens). If we return \"Done\" too soon, we risk the user cancelling the flow.\r\n                return VerificationPhase.Started;\r\n            case QrState.Reciprocated:\r\n                // although the rust SDK doesn't immediately send the `m.key.verification.start` on transition into this\r\n                // state, `RustVerificationRequest.scanQrCode` immediately calls `reciprocate()` and does so, so in practice\r\n                // we can treat the two the same.\r\n                return VerificationPhase.Started;\r\n            case QrState.Done:\r\n                return VerificationPhase.Done;\r\n            case QrState.Cancelled:\r\n                return VerificationPhase.Cancelled;\r\n            default:\r\n                throw new Error(`Unknown qr code state ${this.inner.state()}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the details for reciprocating QR code verification, if one is in progress\r\n     *\r\n     * Returns `null`, unless this verifier is for reciprocating a QR-code-based verification (ie, the other user has\r\n     * already scanned our QR code), and we are waiting for the user to confirm.\r\n     */\r\n    public getReciprocateQrCodeCallbacks(): ShowQrCodeCallbacks | null {\r\n        return this.callbacks;\r\n    }\r\n\r\n    private async confirmScanning(): Promise<void> {\r\n        const req: undefined | OutgoingRequest = this.inner.confirmScanning();\r\n        if (req) {\r\n            await this.outgoingRequestProcessor.makeOutgoingRequest(req);\r\n        }\r\n    }\r\n}\r\n\r\n/** A Verifier instance which is used if we are exchanging emojis */\r\nexport class RustSASVerifier extends BaseRustVerifer<RustSdkCryptoJs.Sas> implements Verifier {\r\n    private callbacks: ShowSasCallbacks | null = null;\r\n\r\n    public constructor(\r\n        inner: RustSdkCryptoJs.Sas,\r\n        _verificationRequest: RustVerificationRequest,\r\n        outgoingRequestProcessor: OutgoingRequestProcessor,\r\n    ) {\r\n        super(inner, outgoingRequestProcessor);\r\n    }\r\n\r\n    /**\r\n     * Start the key verification, if it has not already been started.\r\n     *\r\n     * This means sending a `m.key.verification.start` if we are the first responder, or a `m.key.verification.accept`\r\n     * if the other side has already sent a start event.\r\n     *\r\n     * @returns Promise which resolves when the verification has completed, or rejects if the verification is cancelled\r\n     *    or times out.\r\n     */\r\n    public async verify(): Promise<void> {\r\n        await this.sendAccept();\r\n        await this.completionDeferred.promise;\r\n    }\r\n\r\n    /**\r\n     * Send the accept or start event, if it hasn't already been sent\r\n     */\r\n    private async sendAccept(): Promise<void> {\r\n        const req: undefined | OutgoingRequest = this.inner.accept();\r\n        if (req) {\r\n            await this.outgoingRequestProcessor.makeOutgoingRequest(req);\r\n        }\r\n    }\r\n\r\n    /** if we can now show the callbacks, do so */\r\n    protected onChange(): void {\r\n        super.onChange();\r\n\r\n        if (this.callbacks === null) {\r\n            const emoji = this.inner.emoji();\r\n            const decimal = this.inner.decimals();\r\n\r\n            if (emoji === undefined && decimal === undefined) {\r\n                return;\r\n            }\r\n\r\n            const sas: GeneratedSas = {};\r\n            if (emoji) {\r\n                sas.emoji = emoji.map((e) => [e.symbol, e.description]);\r\n            }\r\n            if (decimal) {\r\n                sas.decimal = [decimal[0], decimal[1], decimal[2]];\r\n            }\r\n\r\n            this.callbacks = {\r\n                sas,\r\n                confirm: async (): Promise<void> => {\r\n                    const requests: Array<OutgoingRequest> = await this.inner.confirm();\r\n                    for (const m of requests) {\r\n                        await this.outgoingRequestProcessor.makeOutgoingRequest(m);\r\n                    }\r\n                },\r\n                mismatch: (): void => {\r\n                    const request = this.inner.cancelWithCode(\"m.mismatched_sas\");\r\n                    if (request) {\r\n                        this.outgoingRequestProcessor.makeOutgoingRequest(request);\r\n                    }\r\n                },\r\n                cancel: (): void => {\r\n                    const request = this.inner.cancelWithCode(\"m.user\");\r\n                    if (request) {\r\n                        this.outgoingRequestProcessor.makeOutgoingRequest(request);\r\n                    }\r\n                },\r\n            };\r\n            this.emit(VerifierEvent.ShowSas, this.callbacks);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate an appropriate VerificationPhase for a VerificationRequest where this is the verifier.\r\n     */\r\n    public get verificationPhase(): VerificationPhase {\r\n        return VerificationPhase.Started;\r\n    }\r\n\r\n    /**\r\n     * Get the details for an SAS verification, if one is in progress\r\n     *\r\n     * Returns `null`, unless this verifier is for a SAS-based verification and we are waiting for the user to confirm\r\n     * the SAS matches.\r\n     */\r\n    public getShowSasCallbacks(): ShowSasCallbacks | null {\r\n        return this.callbacks;\r\n    }\r\n\r\n    /**\r\n     * Replace the inner Rust verifier with a different one.\r\n     *\r\n     * @param inner - the new Rust verifier\r\n     * @internal\r\n     */\r\n    public replaceInner(inner: RustSdkCryptoJs.Sas): void {\r\n        if (this.inner != inner) {\r\n            this.inner = inner;\r\n\r\n            // As with RustVerificationRequest, we need to avoid a reference cycle.\r\n            // See the comments in RustVerificationRequest.\r\n            const weakThis = new WeakRef(this);\r\n            inner.registerChangesCallback(async () => weakThis.deref()?.onChange());\r\n\r\n            // replaceInner will only get called if we started the verification at the same time as the other side, and we lost\r\n            // the tie breaker.  So we need to re-accept their verification.\r\n            this.sendAccept();\r\n            this.onChange();\r\n        }\r\n    }\r\n}\r\n\r\n/** For each specced verification method, the rust-side `VerificationMethod` corresponding to it */\r\nconst verificationMethodsByIdentifier: Record<string, RustSdkCryptoJs.VerificationMethod> = {\r\n    [VerificationMethod.Sas]: RustSdkCryptoJs.VerificationMethod.SasV1,\r\n    [VerificationMethod.ScanQrCode]: RustSdkCryptoJs.VerificationMethod.QrCodeScanV1,\r\n    [VerificationMethod.ShowQrCode]: RustSdkCryptoJs.VerificationMethod.QrCodeShowV1,\r\n    [VerificationMethod.Reciprocate]: RustSdkCryptoJs.VerificationMethod.ReciprocateV1,\r\n};\r\n\r\n/**\r\n * Convert a specced verification method identifier into a rust-side `VerificationMethod`.\r\n *\r\n * @param method - specced method identifier, for example `m.sas.v1`.\r\n * @returns Rust-side `VerificationMethod` corresponding to `method`.\r\n * @throws An error if the method is unknown.\r\n *\r\n * @internal\r\n */\r\nexport function verificationMethodIdentifierToMethod(method: string): RustSdkCryptoJs.VerificationMethod {\r\n    const meth = verificationMethodsByIdentifier[method];\r\n    if (meth === undefined) {\r\n        throw new Error(`Unknown verification method ${method}`);\r\n    }\r\n    return meth;\r\n}\r\n\r\n/**\r\n * Return true if the event's type matches that of an in-room verification event\r\n *\r\n * @param event - MatrixEvent\r\n * @returns\r\n *\r\n * @internal\r\n */\r\nexport function isVerificationEvent(event: MatrixEvent): boolean {\r\n    switch (event.getType()) {\r\n        case EventType.KeyVerificationCancel:\r\n        case EventType.KeyVerificationDone:\r\n        case EventType.KeyVerificationMac:\r\n        case EventType.KeyVerificationStart:\r\n        case EventType.KeyVerificationKey:\r\n        case EventType.KeyVerificationReady:\r\n        case EventType.KeyVerificationAccept:\r\n            return true;\r\n        case EventType.RoomMessage:\r\n            return event.getContent().msgtype === MsgType.KeyVerificationRequest;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { OlmMachine } from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { OutgoingRequest, OutgoingRequestProcessor } from \"./OutgoingRequestProcessor\";\r\nimport { Logger } from \"../logger\";\r\nimport { defer, IDeferred, logDuration } from \"../utils\";\r\n\r\n/**\r\n * OutgoingRequestsManager: responsible for processing outgoing requests from the OlmMachine.\r\n * Ensure that only one loop is going on at once, and that the requests are processed in order.\r\n */\r\nexport class OutgoingRequestsManager {\r\n    /** whether {@link stop} has been called */\r\n    private stopped = false;\r\n\r\n    /** whether {@link outgoingRequestLoop} is currently running */\r\n    private outgoingRequestLoopRunning = false;\r\n\r\n    /**\r\n     * If there are additional calls to doProcessOutgoingRequests() while there is a current call running\r\n     * we need to remember in order to call `doProcessOutgoingRequests` again (as there could be new requests).\r\n     *\r\n     * If this is defined, it is an indication that we need to do another iteration; in this case the deferred\r\n     * will resolve once that next iteration completes. If it is undefined, there have been no new calls\r\n     * to `doProcessOutgoingRequests` since the current iteration started.\r\n     */\r\n    private nextLoopDeferred?: IDeferred<void>;\r\n\r\n    public constructor(\r\n        private readonly logger: Logger,\r\n        private readonly olmMachine: OlmMachine,\r\n        public readonly outgoingRequestProcessor: OutgoingRequestProcessor,\r\n    ) {}\r\n\r\n    /**\r\n     * Shut down as soon as possible the current loop of outgoing requests processing.\r\n     */\r\n    public stop(): void {\r\n        this.stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Process the OutgoingRequests from the OlmMachine.\r\n     *\r\n     * This should be called at the end of each sync, to process any OlmMachine OutgoingRequests created by the rust sdk.\r\n     * In some cases if OutgoingRequests need to be sent immediately, this can be called directly.\r\n     *\r\n     * Calls to doProcessOutgoingRequests() are processed synchronously, one after the other, in order.\r\n     * If doProcessOutgoingRequests() is called while another call is still being processed, it will be queued.\r\n     * Multiple calls to doProcessOutgoingRequests() when a call is already processing will be batched together.\r\n     */\r\n    public doProcessOutgoingRequests(): Promise<void> {\r\n        // Flag that we need at least one more iteration of the loop.\r\n        //\r\n        // It is important that we do this even if the loop is currently running. There is potential for a race whereby\r\n        // a request is added to the queue *after* `OlmMachine.outgoingRequests` checks the queue, but *before* it\r\n        // returns. In such a case, the item could sit there unnoticed for some time.\r\n        //\r\n        // In order to circumvent the race, we set a flag which tells the loop to go round once again even if the\r\n        // queue appears to be empty.\r\n        if (!this.nextLoopDeferred) {\r\n            this.nextLoopDeferred = defer();\r\n        }\r\n\r\n        // ... and wait for it to complete.\r\n        const result = this.nextLoopDeferred.promise;\r\n\r\n        // set the loop going if it is not already.\r\n        if (!this.outgoingRequestLoopRunning) {\r\n            this.outgoingRequestLoop().catch((e) => {\r\n                // this should not happen; outgoingRequestLoop should return any errors via `nextLoopDeferred`.\r\n                /* istanbul ignore next */\r\n                this.logger.error(\"Uncaught error in outgoing request loop\", e);\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private async outgoingRequestLoop(): Promise<void> {\r\n        /* istanbul ignore if */\r\n        if (this.outgoingRequestLoopRunning) {\r\n            throw new Error(\"Cannot run two outgoing request loops\");\r\n        }\r\n        this.outgoingRequestLoopRunning = true;\r\n        try {\r\n            while (!this.stopped && this.nextLoopDeferred) {\r\n                const deferred = this.nextLoopDeferred;\r\n\r\n                // reset `nextLoopDeferred` so that any future calls to `doProcessOutgoingRequests` are queued\r\n                // for another additional iteration.\r\n                this.nextLoopDeferred = undefined;\r\n\r\n                // make the requests and feed the results back to the `nextLoopDeferred`\r\n                await this.processOutgoingRequests().then(deferred.resolve, deferred.reject);\r\n            }\r\n        } finally {\r\n            this.outgoingRequestLoopRunning = false;\r\n        }\r\n\r\n        if (this.nextLoopDeferred) {\r\n            // the loop was stopped, but there was a call to `doProcessOutgoingRequests`. Make sure that\r\n            // we reject the promise in case anything is waiting for it.\r\n            this.nextLoopDeferred.reject(new Error(\"OutgoingRequestsManager was stopped\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Make a single request to `olmMachine.outgoingRequests` and do the corresponding requests.\r\n     */\r\n    private async processOutgoingRequests(): Promise<void> {\r\n        if (this.stopped) return;\r\n\r\n        const outgoingRequests: OutgoingRequest[] = await this.olmMachine.outgoingRequests();\r\n\r\n        for (const request of outgoingRequests) {\r\n            if (this.stopped) return;\r\n            try {\r\n                await logDuration(this.logger, `Make outgoing request ${request.type}`, async () => {\r\n                    await this.outgoingRequestProcessor.makeOutgoingRequest(request);\r\n                });\r\n            } catch (e) {\r\n                // as part of the loop we silently ignore errors, but log them.\r\n                // The rust sdk will retry the request later as it won't have been marked as sent.\r\n                this.logger.error(`Failed to process outgoing request ${request.type}: ${e}`);\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { OlmMachine, CrossSigningStatus, CrossSigningBootstrapRequests } from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { BootstrapCrossSigningOpts } from \"../crypto-api\";\r\nimport { logger } from \"../logger\";\r\nimport { OutgoingRequestProcessor } from \"./OutgoingRequestProcessor\";\r\nimport { UIAuthCallback } from \"../interactive-auth\";\r\nimport { ServerSideSecretStorage } from \"../secret-storage\";\r\n\r\n/** Manages the cross-signing keys for our own user.\r\n *\r\n * @internal\r\n */\r\nexport class CrossSigningIdentity {\r\n    public constructor(\r\n        private readonly olmMachine: OlmMachine,\r\n        private readonly outgoingRequestProcessor: OutgoingRequestProcessor,\r\n        private readonly secretStorage: ServerSideSecretStorage,\r\n    ) {}\r\n\r\n    /**\r\n     * Initialise our cross-signing keys by creating new keys if they do not exist, and uploading to the server\r\n     */\r\n    public async bootstrapCrossSigning(opts: BootstrapCrossSigningOpts): Promise<void> {\r\n        if (opts.setupNewCrossSigning) {\r\n            await this.resetCrossSigning(opts.authUploadDeviceSigningKeys);\r\n            return;\r\n        }\r\n\r\n        const olmDeviceStatus: CrossSigningStatus = await this.olmMachine.crossSigningStatus();\r\n\r\n        // Try to fetch cross signing keys from the secret storage\r\n        const masterKeyFromSecretStorage = await this.secretStorage.get(\"m.cross_signing.master\");\r\n        const selfSigningKeyFromSecretStorage = await this.secretStorage.get(\"m.cross_signing.self_signing\");\r\n        const userSigningKeyFromSecretStorage = await this.secretStorage.get(\"m.cross_signing.user_signing\");\r\n        const privateKeysInSecretStorage = Boolean(\r\n            masterKeyFromSecretStorage && selfSigningKeyFromSecretStorage && userSigningKeyFromSecretStorage,\r\n        );\r\n\r\n        const olmDeviceHasKeys =\r\n            olmDeviceStatus.hasMaster && olmDeviceStatus.hasUserSigning && olmDeviceStatus.hasSelfSigning;\r\n\r\n        // Log all relevant state for easier parsing of debug logs.\r\n        logger.log(\"bootstrapCrossSigning: starting\", {\r\n            setupNewCrossSigning: opts.setupNewCrossSigning,\r\n            olmDeviceHasMaster: olmDeviceStatus.hasMaster,\r\n            olmDeviceHasUserSigning: olmDeviceStatus.hasUserSigning,\r\n            olmDeviceHasSelfSigning: olmDeviceStatus.hasSelfSigning,\r\n            privateKeysInSecretStorage,\r\n        });\r\n\r\n        if (olmDeviceHasKeys) {\r\n            if (!(await this.secretStorage.hasKey())) {\r\n                logger.warn(\r\n                    \"bootstrapCrossSigning: Olm device has private keys, but secret storage is not yet set up; doing nothing for now.\",\r\n                );\r\n                // the keys should get uploaded to 4S once that is set up.\r\n            } else if (!privateKeysInSecretStorage) {\r\n                // the device has the keys but they are not in 4S, so update it\r\n                logger.log(\"bootstrapCrossSigning: Olm device has private keys: exporting to secret storage\");\r\n                await this.exportCrossSigningKeysToStorage();\r\n            } else {\r\n                logger.log(\r\n                    \"bootstrapCrossSigning: Olm device has private keys and they are saved in secret storage; doing nothing\",\r\n                );\r\n            }\r\n        } /* (!olmDeviceHasKeys) */ else {\r\n            if (privateKeysInSecretStorage) {\r\n                // they are in 4S, so import from there\r\n                logger.log(\r\n                    \"bootstrapCrossSigning: Cross-signing private keys not found locally, but they are available \" +\r\n                        \"in secret storage, reading storage and caching locally\",\r\n                );\r\n                await this.olmMachine.importCrossSigningKeys(\r\n                    masterKeyFromSecretStorage,\r\n                    selfSigningKeyFromSecretStorage,\r\n                    userSigningKeyFromSecretStorage,\r\n                );\r\n\r\n                // Get the current device\r\n                const device: RustSdkCryptoJs.Device = await this.olmMachine.getDevice(\r\n                    this.olmMachine.userId,\r\n                    this.olmMachine.deviceId,\r\n                );\r\n                try {\r\n                    // Sign the device with our cross-signing key and upload the signature\r\n                    const request: RustSdkCryptoJs.SignatureUploadRequest = await device.verify();\r\n                    await this.outgoingRequestProcessor.makeOutgoingRequest(request);\r\n                } finally {\r\n                    device.free();\r\n                }\r\n            } else {\r\n                logger.log(\r\n                    \"bootstrapCrossSigning: Cross-signing private keys not found locally or in secret storage, creating new keys\",\r\n                );\r\n                await this.resetCrossSigning(opts.authUploadDeviceSigningKeys);\r\n            }\r\n        }\r\n\r\n        // TODO: we might previously have bootstrapped cross-signing but not completed uploading the keys to the\r\n        //   server -- in which case we should call OlmDevice.bootstrap_cross_signing. How do we know?\r\n        logger.log(\"bootstrapCrossSigning: complete\");\r\n    }\r\n\r\n    /** Reset our cross-signing keys\r\n     *\r\n     * This method will:\r\n     *   * Tell the OlmMachine to create new keys\r\n     *   * Upload the new public keys and the device signature to the server\r\n     *   * Upload the private keys to SSSS, if it is set up\r\n     */\r\n    private async resetCrossSigning(authUploadDeviceSigningKeys?: UIAuthCallback<void>): Promise<void> {\r\n        // XXX: We must find a way to make this atomic, currently if the user does not remember his account password\r\n        // or 4S passphrase/key the process will fail in a bad state, with keys rotated but not uploaded or saved in 4S.\r\n        const outgoingRequests: CrossSigningBootstrapRequests = await this.olmMachine.bootstrapCrossSigning(true);\r\n\r\n        // If 4S is configured we need to update it.\r\n        if (!(await this.secretStorage.hasKey())) {\r\n            logger.warn(\r\n                \"resetCrossSigning: Secret storage is not yet set up; not exporting keys to secret storage yet.\",\r\n            );\r\n            // the keys should get uploaded to 4S once that is set up.\r\n        } else {\r\n            // Update 4S before uploading cross-signing keys, to stay consistent with legacy that asks\r\n            // 4S passphrase before asking for account password.\r\n            // Ultimately should be made atomic and resistant to forgotten password/passphrase.\r\n            logger.log(\"resetCrossSigning: exporting to secret storage\");\r\n\r\n            await this.exportCrossSigningKeysToStorage();\r\n        }\r\n        logger.log(\"resetCrossSigning: publishing keys to server\");\r\n        for (const req of [\r\n            outgoingRequests.uploadKeysRequest,\r\n            outgoingRequests.uploadSigningKeysRequest,\r\n            outgoingRequests.uploadSignaturesRequest,\r\n        ]) {\r\n            if (req) {\r\n                await this.outgoingRequestProcessor.makeOutgoingRequest(req, authUploadDeviceSigningKeys);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract the cross-signing keys from the olm machine and save them to secret storage, if it is configured\r\n     *\r\n     * (If secret storage is *not* configured, we assume that the export will happen when it is set up)\r\n     */\r\n    private async exportCrossSigningKeysToStorage(): Promise<void> {\r\n        const exported: RustSdkCryptoJs.CrossSigningKeyExport | null = await this.olmMachine.exportCrossSigningKeys();\r\n        /* istanbul ignore else (this function is only called when we know the olm machine has keys) */\r\n        if (exported?.masterKey) {\r\n            await this.secretStorage.store(\"m.cross_signing.master\", exported.masterKey);\r\n        } else {\r\n            logger.error(`Cannot export MSK to secret storage, private key unknown`);\r\n        }\r\n        if (exported?.self_signing_key) {\r\n            await this.secretStorage.store(\"m.cross_signing.self_signing\", exported.self_signing_key);\r\n        } else {\r\n            logger.error(`Cannot export SSK to secret storage, private key unknown`);\r\n        }\r\n        if (exported?.userSigningKey) {\r\n            await this.secretStorage.store(\"m.cross_signing.user_signing\", exported.userSigningKey);\r\n        } else {\r\n            logger.error(`Cannot export USK to secret storage, private key unknown`);\r\n        }\r\n    }\r\n}\r\n","/*\r\nCopyright 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { ServerSideSecretStorage } from \"../secret-storage\";\r\n\r\n/**\r\n * Check that the private cross signing keys (master, self signing, user signing) are stored in the secret storage and encrypted with the default secret storage key.\r\n *\r\n * @param secretStorage - The secret store using account data\r\n * @returns True if the cross-signing keys are all stored and encrypted with the same secret storage key.\r\n *\r\n * @internal\r\n */\r\nexport async function secretStorageContainsCrossSigningKeys(secretStorage: ServerSideSecretStorage): Promise<boolean> {\r\n    return secretStorageCanAccessSecrets(secretStorage, [\r\n        \"m.cross_signing.master\",\r\n        \"m.cross_signing.user_signing\",\r\n        \"m.cross_signing.self_signing\",\r\n    ]);\r\n}\r\n\r\n/**\r\n *\r\n * Check that the secret storage can access the given secrets using the default key.\r\n *\r\n * @param secretStorage - The secret store using account data\r\n * @param secretNames - The secret names to check\r\n * @returns True if all the given secrets are accessible and encrypted with the given key.\r\n *\r\n * @internal\r\n */\r\nexport async function secretStorageCanAccessSecrets(\r\n    secretStorage: ServerSideSecretStorage,\r\n    secretNames: string[],\r\n): Promise<boolean> {\r\n    const defaultKeyId = await secretStorage.getDefaultKeyId();\r\n    if (!defaultKeyId) return false;\r\n\r\n    for (const secretName of secretNames) {\r\n        // check which keys this particular secret is encrypted with\r\n        const record = (await secretStorage.isStored(secretName)) || {};\r\n        // if it's not encrypted with the right key, there is no point continuing\r\n        if (!(defaultKeyId in record)) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n","/*\r\nCopyright 2024 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport * as RustSdkCryptoJs from \"@matrix-org/matrix-sdk-crypto-wasm\";\r\n\r\nimport { OutgoingRequestProcessor } from \"./OutgoingRequestProcessor\";\r\nimport { encodeUri } from \"../utils\";\r\nimport { IHttpOpts, MatrixError, MatrixHttpApi, Method } from \"../http-api\";\r\nimport { IToDeviceEvent } from \"../sync-accumulator\";\r\nimport { ServerSideSecretStorage } from \"../secret-storage\";\r\nimport { decodeBase64, encodeUnpaddedBase64 } from \"../base64\";\r\nimport { Logger } from \"../logger\";\r\n\r\n/**\r\n * The response body of `GET /_matrix/client/unstable/org.matrix.msc3814.v1/dehydrated_device`.\r\n */\r\ninterface DehydratedDeviceResp {\r\n    device_id: string;\r\n    device_data: {\r\n        algorithm: string;\r\n    };\r\n}\r\n/**\r\n * The response body of `POST /_matrix/client/unstable/org.matrix.msc3814.v1/dehydrated_device/events`.\r\n */\r\ninterface DehydratedDeviceEventsResp {\r\n    events: IToDeviceEvent[];\r\n    next_batch: string;\r\n}\r\n\r\n/**\r\n * The unstable URL prefix for dehydrated device endpoints\r\n */\r\nexport const UnstablePrefix = \"/_matrix/client/unstable/org.matrix.msc3814.v1\";\r\n/**\r\n * The name used for the dehydration key in Secret Storage\r\n */\r\nconst SECRET_STORAGE_NAME = \"org.matrix.msc3814\";\r\n\r\n/**\r\n * The interval between creating dehydrated devices. (one week)\r\n */\r\nconst DEHYDRATION_INTERVAL = 7 * 24 * 60 * 60 * 1000;\r\n\r\n/**\r\n * Manages dehydrated devices\r\n *\r\n * We have one of these per `RustCrypto`.  It's responsible for\r\n *\r\n * * determining server support for dehydrated devices\r\n * * creating new dehydrated devices when requested, including periodically\r\n *   replacing the dehydrated device with a new one\r\n * * rehydrating a device when requested, and when present\r\n *\r\n * @internal\r\n */\r\nexport class DehydratedDeviceManager {\r\n    /** the secret key used for dehydrating and rehydrating */\r\n    private key?: Uint8Array;\r\n    /** the ID of the interval for periodically replacing the dehydrated device */\r\n    private intervalId?: ReturnType<typeof setInterval>;\r\n\r\n    public constructor(\r\n        private readonly logger: Logger,\r\n        private readonly olmMachine: RustSdkCryptoJs.OlmMachine,\r\n        private readonly http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\r\n        private readonly outgoingRequestProcessor: OutgoingRequestProcessor,\r\n        private readonly secretStorage: ServerSideSecretStorage,\r\n    ) {}\r\n\r\n    /**\r\n     * Return whether the server supports dehydrated devices.\r\n     */\r\n    public async isSupported(): Promise<boolean> {\r\n        // call the endpoint to get a dehydrated device.  If it returns an\r\n        // M_UNRECOGNIZED error, then dehydration is unsupported.  If it returns\r\n        // a successful response, or an M_NOT_FOUND, then dehydration is supported.\r\n        // Any other exceptions are passed through.\r\n        try {\r\n            await this.http.authedRequest<DehydratedDeviceResp>(\r\n                Method.Get,\r\n                \"/dehydrated_device\",\r\n                undefined,\r\n                undefined,\r\n                {\r\n                    prefix: UnstablePrefix,\r\n                },\r\n            );\r\n        } catch (error) {\r\n            const err = error as MatrixError;\r\n            if (err.errcode === \"M_UNRECOGNIZED\") {\r\n                return false;\r\n            } else if (err.errcode === \"M_NOT_FOUND\") {\r\n                return true;\r\n            }\r\n            throw error;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Start using device dehydration.\r\n     *\r\n     * - Rehydrates a dehydrated device, if one is available.\r\n     * - Creates a new dehydration key, if necessary, and stores it in Secret\r\n     *   Storage.\r\n     *   - If `createNewKey` is set to true, always creates a new key.\r\n     *   - If a dehydration key is not available, creates a new one.\r\n     * - Creates a new dehydrated device, and schedules periodically creating\r\n     *   new dehydrated devices.\r\n     *\r\n     * @param createNewKey - whether to force creation of a new dehydration key.\r\n     *   This can be used, for example, if Secret Storage is being reset.\r\n     */\r\n    public async start(createNewKey?: boolean): Promise<void> {\r\n        this.stop();\r\n        try {\r\n            await this.rehydrateDeviceIfAvailable();\r\n        } catch (e) {\r\n            // If rehydration fails, there isn't much we can do about it.  Log\r\n            // the error, and create a new device.\r\n            this.logger.info(\"dehydration: Error rehydrating device:\", e);\r\n        }\r\n        if (createNewKey) {\r\n            await this.resetKey();\r\n        }\r\n        await this.scheduleDeviceDehydration();\r\n    }\r\n\r\n    /**\r\n     * Return whether the dehydration key is stored in Secret Storage.\r\n     */\r\n    public async isKeyStored(): Promise<boolean> {\r\n        return Boolean(await this.secretStorage.isStored(SECRET_STORAGE_NAME));\r\n    }\r\n\r\n    /**\r\n     * Reset the dehydration key.\r\n     *\r\n     * Creates a new key and stores it in secret storage.\r\n     */\r\n    public async resetKey(): Promise<void> {\r\n        const key = new Uint8Array(32);\r\n        globalThis.crypto.getRandomValues(key);\r\n        await this.secretStorage.store(SECRET_STORAGE_NAME, encodeUnpaddedBase64(key));\r\n        this.key = key;\r\n    }\r\n\r\n    /**\r\n     * Get and cache the encryption key from secret storage.\r\n     *\r\n     * If `create` is `true`, creates a new key if no existing key is present.\r\n     *\r\n     * @returns the key, if available, or `null` if no key is available\r\n     */\r\n    private async getKey(create: boolean): Promise<Uint8Array | null> {\r\n        if (this.key === undefined) {\r\n            const keyB64 = await this.secretStorage.get(SECRET_STORAGE_NAME);\r\n            if (keyB64 === undefined) {\r\n                if (!create) {\r\n                    return null;\r\n                }\r\n                await this.resetKey();\r\n            } else {\r\n                this.key = decodeBase64(keyB64);\r\n            }\r\n        }\r\n        return this.key!;\r\n    }\r\n\r\n    /**\r\n     * Rehydrate the dehydrated device stored on the server.\r\n     *\r\n     * Checks if there is a dehydrated device on the server.  If so, rehydrates\r\n     * the device and processes the to-device events.\r\n     *\r\n     * Returns whether or not a dehydrated device was found.\r\n     */\r\n    public async rehydrateDeviceIfAvailable(): Promise<boolean> {\r\n        const key = await this.getKey(false);\r\n        if (!key) {\r\n            return false;\r\n        }\r\n\r\n        let dehydratedDeviceResp;\r\n        try {\r\n            dehydratedDeviceResp = await this.http.authedRequest<DehydratedDeviceResp>(\r\n                Method.Get,\r\n                \"/dehydrated_device\",\r\n                undefined,\r\n                undefined,\r\n                {\r\n                    prefix: UnstablePrefix,\r\n                },\r\n            );\r\n        } catch (error) {\r\n            const err = error as MatrixError;\r\n            // We ignore M_NOT_FOUND (there is no dehydrated device, so nothing\r\n            // us to do) and M_UNRECOGNIZED (the server does not understand the\r\n            // endpoint).  We pass through any other errors.\r\n            if (err.errcode === \"M_NOT_FOUND\" || err.errcode === \"M_UNRECOGNIZED\") {\r\n                this.logger.info(\"dehydration: No dehydrated device\");\r\n                return false;\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        this.logger.info(\"dehydration: dehydrated device found\");\r\n\r\n        const rehydratedDevice = await this.olmMachine\r\n            .dehydratedDevices()\r\n            .rehydrate(\r\n                key,\r\n                new RustSdkCryptoJs.DeviceId(dehydratedDeviceResp.device_id),\r\n                JSON.stringify(dehydratedDeviceResp.device_data),\r\n            );\r\n\r\n        this.logger.info(\"dehydration: device rehydrated\");\r\n\r\n        let nextBatch: string | undefined = undefined;\r\n        let toDeviceCount = 0;\r\n        let roomKeyCount = 0;\r\n        const path = encodeUri(\"/dehydrated_device/$device_id/events\", {\r\n            $device_id: dehydratedDeviceResp.device_id,\r\n        });\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            const eventResp: DehydratedDeviceEventsResp = await this.http.authedRequest<DehydratedDeviceEventsResp>(\r\n                Method.Post,\r\n                path,\r\n                undefined,\r\n                nextBatch ? { next_batch: nextBatch } : {},\r\n                {\r\n                    prefix: UnstablePrefix,\r\n                },\r\n            );\r\n\r\n            if (eventResp.events.length === 0) {\r\n                break;\r\n            }\r\n            toDeviceCount += eventResp.events.length;\r\n            nextBatch = eventResp.next_batch;\r\n            const roomKeyInfos = await rehydratedDevice.receiveEvents(JSON.stringify(eventResp.events));\r\n            roomKeyCount += roomKeyInfos.length;\r\n        }\r\n        this.logger.info(`dehydration: received ${roomKeyCount} room keys from ${toDeviceCount} to-device events`);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates and uploads a new dehydrated device.\r\n     *\r\n     * Creates and stores a new key in secret storage if none is available.\r\n     */\r\n    public async createAndUploadDehydratedDevice(): Promise<void> {\r\n        const key = (await this.getKey(true))!;\r\n\r\n        const dehydratedDevice = await this.olmMachine.dehydratedDevices().create();\r\n        const request = await dehydratedDevice.keysForUpload(\"Dehydrated device\", key);\r\n\r\n        await this.outgoingRequestProcessor.makeOutgoingRequest(request);\r\n\r\n        this.logger.info(\"dehydration: uploaded device\");\r\n    }\r\n\r\n    /**\r\n     * Schedule periodic creation of dehydrated devices.\r\n     */\r\n    public async scheduleDeviceDehydration(): Promise<void> {\r\n        // cancel any previously-scheduled tasks\r\n        this.stop();\r\n\r\n        await this.createAndUploadDehydratedDevice();\r\n        this.intervalId = setInterval(() => {\r\n            this.createAndUploadDehydratedDevice().catch((error) => {\r\n                this.logger.error(\"Error creating dehydrated device:\", error);\r\n            });\r\n        }, DEHYDRATION_INTERVAL);\r\n    }\r\n\r\n    /**\r\n     * Stop the dehydrated device manager.\r\n     *\r\n     * Cancels any scheduled dehydration tasks.\r\n     */\r\n    public stop(): void {\r\n        if (this.intervalId) {\r\n            clearInterval(this.intervalId);\r\n            this.intervalId = undefined;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""}